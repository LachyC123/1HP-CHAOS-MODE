<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>1HP: CHAOS MODE</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background: #0a0a0f;
            font-family: 'Courier New', monospace;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        #gameCanvas {
            display: block;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
        }
        #ui {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        .ui-element {
            position: absolute;
            color: #fff;
            text-shadow: 0 0 10px currentColor;
        }
        #score {
            top: 10px; left: 10px;
            font-size: 24px;
            color: #0ff;
        }
        #level {
            top: 10px; right: 10px;
            font-size: 18px;
            color: #f0f;
        }
        #time {
            top: 40px; left: 10px;
            font-size: 16px;
            color: #ff0;
        }
        #mutators {
            bottom: 10px; left: 10px;
            font-size: 12px;
            color: #0f0;
            max-width: 50%;
        }
        #upgradeMenu {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            border: 2px solid #0ff;
            border-radius: 10px;
            padding: 20px;
            display: none;
            pointer-events: auto;
            z-index: 100;
            max-width: 90%;
            box-shadow: 0 0 30px #0ff;
        }
        #upgradeMenu h2 {
            color: #0ff;
            text-align: center;
            margin-bottom: 15px;
            text-shadow: 0 0 10px #0ff;
        }
        .upgrade-option {
            background: rgba(0,255,255,0.1);
            border: 1px solid #0ff;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.2s;
        }
        .upgrade-option:hover, .upgrade-option:active {
            background: rgba(0,255,255,0.3);
            transform: scale(1.02);
        }
        .upgrade-option h3 {
            color: #f0f;
            margin-bottom: 5px;
        }
        .upgrade-option p {
            color: #aaa;
            font-size: 12px;
        }
        #startScreen, #deathScreen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(10,10,15,0.98);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            pointer-events: auto;
        }
        #startScreen h1 {
            font-size: 36px;
            color: #f0f;
            text-shadow: 0 0 20px #f0f, 0 0 40px #f0f;
            margin-bottom: 10px;
        }
        #startScreen .subtitle {
            color: #0ff;
            font-size: 18px;
            margin-bottom: 30px;
        }
        .start-btn {
            background: linear-gradient(135deg, #f0f, #0ff);
            border: none;
            color: #000;
            padding: 15px 40px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 5px;
            margin: 10px;
            text-transform: uppercase;
        }
        #deathScreen {
            display: none;
        }
        #deathScreen h2 {
            color: #f00;
            font-size: 32px;
            text-shadow: 0 0 20px #f00;
            margin-bottom: 20px;
        }
        #deathScreen .stats {
            color: #fff;
            margin-bottom: 20px;
            text-align: center;
        }
        #metaProgress {
            position: absolute;
            bottom: 50px; right: 10px;
            color: #888;
            font-size: 10px;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .blink { animation: pulse 0.5s infinite; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
        <div id="score" class="ui-element">0</div>
        <div id="level" class="ui-element">LV 1</div>
        <div id="time" class="ui-element">0:00</div>
        <div id="mutators" class="ui-element"></div>
        <div id="metaProgress" class="ui-element"></div>
    </div>
    
    <div id="upgradeMenu">
        <h2>LEVEL UP</h2>
        <div id="upgradeOptions"></div>
    </div>
    
    <div id="startScreen">
        <h1>1HP</h1>
        <div class="subtitle">CHAOS MODE</div>
        <p style="color:#888;margin-bottom:20px;text-align:center;padding:0 20px;">One hit kills. React or die.<br>Swipe to move. Auto-attack enabled.</p>
        <button class="start-btn" id="startBtn">START</button>
        <p style="color:#666;font-size:12px;margin-top:20px;">Unlocks: <span id="unlockCount">0</span></p>
    </div>
    
    <div id="deathScreen">
        <h2>DEAD</h2>
        <div class="stats">
            <p>Score: <span id="finalScore">0</span></p>
            <p>Time: <span id="finalTime">0:00</span></p>
            <p>Level: <span id="finalLevel">1</span></p>
        </div>
        <button class="start-btn" id="restartBtn">TAP TO RESTART</button>
    </div>

<script>
// ============================================
// 1HP: CHAOS MODE - Complete Game Engine
// ============================================

(function() {
    'use strict';
    
    // ========== CONFIGURATION ==========
    const CONFIG = {
        CANVAS_WIDTH: 400,
        CANVAS_HEIGHT: 700,
        PLAYER_SIZE: 15,
        PLAYER_SPEED: 8,
        PLAYER_FRICTION: 0.85,
        BULLET_SPEED: 12,
        ENEMY_BASE_SPEED: 2,
        XP_TO_LEVEL: 100,
        XP_SCALE: 1.3,
        SPAWN_RATE_INITIAL: 2000,
        SPAWN_RATE_MIN: 400,
        NEAR_MISS_DISTANCE: 25,
    };
    
    // ========== AUDIO ENGINE (Web Audio API) ==========
    class AudioEngine {
        constructor() {
            this.ctx = null;
            this.enabled = true;
            this.musicGain = null;
            this.sfxGain = null;
            this.musicOsc = null;
            this.bassOsc = null;
            this.intensity = 0;
        }
        
        init() {
            try {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.musicGain = this.ctx.createGain();
                this.sfxGain = this.ctx.createGain();
                this.musicGain.gain.value = 0.15;
                this.sfxGain.gain.value = 0.3;
                this.musicGain.connect(this.ctx.destination);
                this.sfxGain.connect(this.ctx.destination);
            } catch(e) {
                this.enabled = false;
            }
        }
        
        resume() {
            if (this.ctx && this.ctx.state === 'suspended') {
                this.ctx.resume();
            }
        }
        
        startMusic() {
            if (!this.enabled || !this.ctx) return;
            this.stopMusic();
            
            // Bass drone
            this.bassOsc = this.ctx.createOscillator();
            this.bassOsc.type = 'sine';
            this.bassOsc.frequency.value = 55;
            const bassGain = this.ctx.createGain();
            bassGain.gain.value = 0.2;
            this.bassOsc.connect(bassGain);
            bassGain.connect(this.musicGain);
            this.bassOsc.start();
            
            // Arpeggio
            this.startArpeggio();
        }
        
        startArpeggio() {
            if (!this.enabled) return;
            const notes = [110, 138.59, 164.81, 220, 164.81, 138.59];
            let noteIndex = 0;
            
            const playNote = () => {
                if (!this.enabled || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.frequency.value = notes[noteIndex] * (1 + this.intensity * 0.5);
                gain.gain.setValueAtTime(0.1 + this.intensity * 0.05, this.ctx.currentTime);
                gain.gain.exponentialDecayTo && gain.gain.exponentialDecayTo(0.01, this.ctx.currentTime + 0.15);
                gain.gain.setTargetAtTime(0.01, this.ctx.currentTime + 0.1, 0.05);
                osc.connect(gain);
                gain.connect(this.musicGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.15);
                noteIndex = (noteIndex + 1) % notes.length;
                
                const tempo = 200 - this.intensity * 80;
                this.arpTimer = setTimeout(playNote, Math.max(80, tempo));
            };
            playNote();
        }
        
        stopMusic() {
            if (this.bassOsc) {
                try { this.bassOsc.stop(); } catch(e) {}
                this.bassOsc = null;
            }
            if (this.arpTimer) {
                clearTimeout(this.arpTimer);
                this.arpTimer = null;
            }
        }
        
        setIntensity(val) {
            this.intensity = Math.min(1, Math.max(0, val));
        }
        
        playSound(type) {
            if (!this.enabled || !this.ctx) return;
            
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.connect(gain);
            gain.connect(this.sfxGain);
            
            switch(type) {
                case 'shoot':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(880, this.ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(220, this.ctx.currentTime + 0.1);
                    gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.1);
                    break;
                    
                case 'kill':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(200, this.ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.15);
                    gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.15);
                    break;
                    
                case 'nearMiss':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(1200, this.ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(2400, this.ctx.currentTime + 0.05);
                    gain.gain.setValueAtTime(0.15, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.08);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.08);
                    break;
                    
                case 'death':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(400, this.ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(30, this.ctx.currentTime + 0.5);
                    gain.gain.setValueAtTime(0.4, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.5);
                    // Add noise burst
                    this.playNoise(0.3, 0.3);
                    break;
                    
                case 'levelUp':
                    [523, 659, 784, 1047].forEach((freq, i) => {
                        const o = this.ctx.createOscillator();
                        const g = this.ctx.createGain();
                        o.type = 'sine';
                        o.frequency.value = freq;
                        g.gain.setValueAtTime(0, this.ctx.currentTime + i * 0.1);
                        g.gain.linearRampToValueAtTime(0.15, this.ctx.currentTime + i * 0.1 + 0.05);
                        g.gain.linearRampToValueAtTime(0, this.ctx.currentTime + i * 0.1 + 0.2);
                        o.connect(g);
                        g.connect(this.sfxGain);
                        o.start(this.ctx.currentTime + i * 0.1);
                        o.stop(this.ctx.currentTime + i * 0.1 + 0.25);
                    });
                    break;
                    
                case 'elite':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(150, this.ctx.currentTime);
                    osc.frequency.setValueAtTime(200, this.ctx.currentTime + 0.1);
                    osc.frequency.setValueAtTime(150, this.ctx.currentTime + 0.2);
                    gain.gain.setValueAtTime(0.25, this.ctx.currentTime);
                    gain.gain.setValueAtTime(0.01, this.ctx.currentTime + 0.3);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.3);
                    break;
                    
                case 'mutator':
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(100, this.ctx.currentTime);
                    osc.frequency.linearRampToValueAtTime(800, this.ctx.currentTime + 0.3);
                    gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                    gain.gain.linearRampToValueAtTime(0.01, this.ctx.currentTime + 0.4);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.4);
                    break;
            }
        }
        
        playNoise(duration, volume) {
            if (!this.ctx) return;
            const bufferSize = this.ctx.sampleRate * duration;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
            }
            const noise = this.ctx.createBufferSource();
            const gain = this.ctx.createGain();
            noise.buffer = buffer;
            gain.gain.value = volume;
            noise.connect(gain);
            gain.connect(this.sfxGain);
            noise.start();
        }
    }
    
    // ========== PARTICLE SYSTEM ==========
    class Particle {
        constructor(x, y, vx, vy, color, size, life) {
            this.x = x;
            this.y = y;
            this.vx = vx;
            this.vy = vy;
            this.color = color;
            this.size = size;
            this.life = life;
            this.maxLife = life;
        }
        
        update(dt) {
            this.x += this.vx * dt;
            this.y += this.vy * dt;
            this.life -= dt;
            this.vx *= 0.98;
            this.vy *= 0.98;
        }
        
        draw(ctx) {
            const alpha = Math.max(0, this.life / this.maxLife);
            ctx.globalAlpha = alpha;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size * alpha, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }
    
    // ========== ENEMY DNA SYSTEM ==========
    const ENEMY_DNA = {
        BODY: {
            SMALL: { size: 10, hp: 1, speed: 1.5, color: '#0f0', xp: 10 },
            MEDIUM: { size: 18, hp: 2, speed: 1, color: '#ff0', xp: 20 },
            TANK: { size: 30, hp: 5, speed: 0.5, color: '#f80', xp: 50 },
            SPLITTER: { size: 22, hp: 2, speed: 0.8, color: '#0ff', xp: 30, splits: true },
            SHIELDED: { size: 20, hp: 3, speed: 0.7, color: '#88f', xp: 40, shield: true },
            SWARM: { size: 8, hp: 1, speed: 1.8, color: '#f0f', xp: 5 }
        },
        MOVEMENT: {
            STRAIGHT: (e, p, dt) => {
                const dx = p.x - e.x, dy = p.y - e.y;
                const d = Math.sqrt(dx*dx + dy*dy) || 1;
                e.vx = (dx/d) * e.speed * CONFIG.ENEMY_BASE_SPEED;
                e.vy = (dy/d) * e.speed * CONFIG.ENEMY_BASE_SPEED;
            },
            ZIGZAG: (e, p, dt) => {
                const dx = p.x - e.x, dy = p.y - e.y;
                const d = Math.sqrt(dx*dx + dy*dy) || 1;
                const angle = Math.atan2(dy, dx) + Math.sin(e.moveTimer * 5) * 0.8;
                e.vx = Math.cos(angle) * e.speed * CONFIG.ENEMY_BASE_SPEED;
                e.vy = Math.sin(angle) * e.speed * CONFIG.ENEMY_BASE_SPEED;
            },
            ORBIT: (e, p, dt) => {
                const dx = p.x - e.x, dy = p.y - e.y;
                const d = Math.sqrt(dx*dx + dy*dy) || 1;
                const targetDist = 120;
                const orbitSpeed = 2;
                const angle = Math.atan2(dy, dx) + (d > targetDist ? 0 : Math.PI/2 * orbitSpeed);
                e.vx = Math.cos(angle) * e.speed * CONFIG.ENEMY_BASE_SPEED;
                e.vy = Math.sin(angle) * e.speed * CONFIG.ENEMY_BASE_SPEED;
            },
            CHARGE: (e, p, dt) => {
                if (!e.chargeState) e.chargeState = 'tracking';
                if (e.chargeState === 'tracking') {
                    e.chargeTimer = (e.chargeTimer || 0) + dt;
                    const dx = p.x - e.x, dy = p.y - e.y;
                    const d = Math.sqrt(dx*dx + dy*dy) || 1;
                    e.vx = (dx/d) * e.speed * CONFIG.ENEMY_BASE_SPEED * 0.3;
                    e.vy = (dy/d) * e.speed * CONFIG.ENEMY_BASE_SPEED * 0.3;
                    e.chargeAngle = Math.atan2(dy, dx);
                    if (e.chargeTimer > 1.5) {
                        e.chargeState = 'charging';
                        e.chargeTimer = 0;
                    }
                } else {
                    e.vx = Math.cos(e.chargeAngle) * e.speed * CONFIG.ENEMY_BASE_SPEED * 4;
                    e.vy = Math.sin(e.chargeAngle) * e.speed * CONFIG.ENEMY_BASE_SPEED * 4;
                    e.chargeTimer += dt;
                    if (e.chargeTimer > 0.5) {
                        e.chargeState = 'tracking';
                        e.chargeTimer = 0;
                    }
                }
            },
            TELEPORT: (e, p, dt) => {
                e.teleportTimer = (e.teleportTimer || 0) + dt;
                if (e.teleportTimer > 2) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 50 + Math.random() * 100;
                    e.x = p.x + Math.cos(angle) * dist;
                    e.y = p.y + Math.sin(angle) * dist;
                    e.x = Math.max(e.size, Math.min(CONFIG.CANVAS_WIDTH - e.size, e.x));
                    e.y = Math.max(e.size, Math.min(CONFIG.CANVAS_HEIGHT - e.size, e.y));
                    e.teleportTimer = 0;
                    e.justTeleported = true;
                }
                const dx = p.x - e.x, dy = p.y - e.y;
                const d = Math.sqrt(dx*dx + dy*dy) || 1;
                e.vx = (dx/d) * e.speed * CONFIG.ENEMY_BASE_SPEED * 0.5;
                e.vy = (dy/d) * e.speed * CONFIG.ENEMY_BASE_SPEED * 0.5;
            },
            ERRATIC: (e, p, dt) => {
                e.erraticTimer = (e.erraticTimer || 0) + dt;
                if (e.erraticTimer > 0.3) {
                    e.erraticAngle = Math.random() * Math.PI * 2;
                    e.erraticTimer = 0;
                }
                const dx = p.x - e.x, dy = p.y - e.y;
                const baseAngle = Math.atan2(dy, dx);
                const angle = baseAngle + (e.erraticAngle || 0) * 0.5;
                e.vx = Math.cos(angle) * e.speed * CONFIG.ENEMY_BASE_SPEED * 1.2;
                e.vy = Math.sin(angle) * e.speed * CONFIG.ENEMY_BASE_SPEED * 1.2;
            }
        },
        ATTACK: {
            NONE: { cooldown: 9999, fire: () => [] },
            BULLET_SPRAY: {
                cooldown: 1.5,
                fire: (e, p) => {
                    const bullets = [];
                    const count = 5;
                    const spread = Math.PI / 3;
                    const baseAngle = Math.atan2(p.y - e.y, p.x - e.x);
                    for (let i = 0; i < count; i++) {
                        const angle = baseAngle - spread/2 + (spread * i / (count-1));
                        bullets.push({
                            x: e.x, y: e.y,
                            vx: Math.cos(angle) * 5,
                            vy: Math.sin(angle) * 5,
                            size: 5, color: '#f00'
                        });
                    }
                    return bullets;
                }
            },
            BURST: {
                cooldown: 2,
                fire: (e, p) => {
                    const bullets = [];
                    const angle = Math.atan2(p.y - e.y, p.x - e.x);
                    for (let i = 0; i < 3; i++) {
                        setTimeout(() => {
                            if (e.dead) return;
                            game.enemyBullets.push({
                                x: e.x, y: e.y,
                                vx: Math.cos(angle) * 6,
                                vy: Math.sin(angle) * 6,
                                size: 6, color: '#ff0'
                            });
                        }, i * 100);
                    }
                    return bullets;
                }
            },
            LASER: {
                cooldown: 3,
                fire: (e, p) => {
                    e.laserWarning = true;
                    e.laserAngle = Math.atan2(p.y - e.y, p.x - e.x);
                    setTimeout(() => {
                        if (e.dead) return;
                        e.laserWarning = false;
                        e.laserActive = true;
                        setTimeout(() => { e.laserActive = false; }, 300);
                    }, 500);
                    return [];
                }
            },
            MINES: {
                cooldown: 2.5,
                fire: (e, p) => {
                    game.hazards.push({
                        x: e.x, y: e.y,
                        size: 12,
                        color: '#f80',
                        type: 'mine',
                        timer: 3
                    });
                    return [];
                }
            },
            HOMING: {
                cooldown: 2.5,
                fire: (e, p) => {
                    return [{
                        x: e.x, y: e.y,
                        vx: 0, vy: 0,
                        size: 8, color: '#f0f',
                        homing: true, speed: 3,
                        life: 5
                    }];
                }
            },
            MELEE_DASH: {
                cooldown: 2,
                fire: (e, p) => {
                    e.dashAngle = Math.atan2(p.y - e.y, p.x - e.x);
                    e.dashing = true;
                    e.dashTimer = 0.3;
                    return [];
                }
            }
        },
        MODIFIER: {
            NONE: { onSpawn: () => {}, onUpdate: () => {}, onDeath: () => {} },
            EXPLODE: {
                onSpawn: () => {},
                onUpdate: () => {},
                onDeath: (e) => {
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI * 2 / 8) * i;
                        game.enemyBullets.push({
                            x: e.x, y: e.y,
                            vx: Math.cos(angle) * 4,
                            vy: Math.sin(angle) * 4,
                            size: 5, color: '#f80'
                        });
                    }
                }
            },
            TRAIL: {
                onSpawn: () => {},
                onUpdate: (e, dt) => {
                    e.trailTimer = (e.trailTimer || 0) + dt;
                    if (e.trailTimer > 0.2) {
                        game.hazards.push({
                            x: e.x, y: e.y,
                            size: 8,
                            color: '#0f08',
                            type: 'trail',
                            timer: 2
                        });
                        e.trailTimer = 0;
                    }
                },
                onDeath: () => {}
            },
            BUFF: {
                onSpawn: () => {},
                onUpdate: (e, dt) => {
                    game.enemies.forEach(other => {
                        if (other !== e && !other.dead) {
                            const dx = other.x - e.x, dy = other.y - e.y;
                            const d = Math.sqrt(dx*dx + dy*dy);
                            if (d < 80) other.buffed = true;
                        }
                    });
                },
                onDeath: () => {}
            },
            SPAWN_HAZARD: {
                onSpawn: () => {},
                onUpdate: (e, dt) => {
                    e.hazardTimer = (e.hazardTimer || 0) + dt;
                    if (e.hazardTimer > 3) {
                        game.hazards.push({
                            x: e.x + (Math.random() - 0.5) * 60,
                            y: e.y + (Math.random() - 0.5) * 60,
                            size: 20,
                            color: '#f008',
                            type: 'zone',
                            timer: 4
                        });
                        e.hazardTimer = 0;
                    }
                },
                onDeath: () => {}
            },
            SCREEN_EFFECT: {
                onSpawn: () => {},
                onUpdate: (e, dt) => {
                    const dx = game.player.x - e.x, dy = game.player.y - e.y;
                    const d = Math.sqrt(dx*dx + dy*dy);
                    if (d < 100) game.screenEffects.distort = Math.max(game.screenEffects.distort || 0, 1 - d/100);
                },
                onDeath: () => {}
            },
            ARENA_CHANGE: {
                onSpawn: () => {},
                onUpdate: () => {},
                onDeath: (e) => {
                    game.arena.shrinkAmount += 10;
                }
            }
        }
    };
    
    // ========== UPGRADE SYSTEM ==========
    const TRIGGERS = ['ON_MOVE', 'ON_STOP', 'ON_NEAR_MISS', 'ON_PERFECT_DODGE', 'ON_KILL', 'ON_MULTI_KILL', 'ON_WALL', 'ON_STREAK'];
    const EFFECTS = ['PROJECTILE', 'SHOCKWAVE', 'TIME_SLOW', 'AREA_BURST', 'CHAIN_LIGHTNING', 'CONVERT', 'SCORE_MULT', 'SHIELD_PULSE'];
    
    const UPGRADE_TRIGGERS = {
        ON_MOVE: { name: 'On Move', check: (g) => g.player.moving, cooldown: 0.5 },
        ON_STOP: { name: 'On Stop', check: (g) => !g.player.moving && g.player.wasMoving, cooldown: 0.3 },
        ON_NEAR_MISS: { name: 'On Near Miss', check: (g) => g.player.nearMiss, cooldown: 0.1 },
        ON_PERFECT_DODGE: { name: 'On Perfect Dodge', check: (g) => g.player.perfectDodge, cooldown: 0.1 },
        ON_KILL: { name: 'On Kill', check: (g) => g.player.justKilled, cooldown: 0.1 },
        ON_MULTI_KILL: { name: 'On Multi-Kill', check: (g) => g.player.multiKill >= 3, cooldown: 0.1 },
        ON_WALL: { name: 'On Wall Touch', check: (g) => g.player.nearWall, cooldown: 0.5 },
        ON_STREAK: { name: 'On Survival (5s)', check: (g) => g.player.streak >= 5 && g.player.streakTick, cooldown: 5 }
    };
    
    const UPGRADE_EFFECTS = {
        PROJECTILE: {
            name: 'Fire Projectile',
            desc: 'Shoots a bullet in move direction',
            apply: (g, stacks) => {
                const angle = Math.atan2(g.player.vy || 0.1, g.player.vx || 0.1);
                for (let i = 0; i < stacks; i++) {
                    const spread = (i - (stacks-1)/2) * 0.2;
                    g.playerBullets.push({
                        x: g.player.x, y: g.player.y,
                        vx: Math.cos(angle + spread) * CONFIG.BULLET_SPEED,
                        vy: Math.sin(angle + spread) * CONFIG.BULLET_SPEED,
                        size: 4, damage: 1 + Math.floor(stacks/3)
                    });
                }
            }
        },
        SHOCKWAVE: {
            name: 'Shockwave',
            desc: 'Pushes enemies away',
            apply: (g, stacks) => {
                const range = 60 + stacks * 20;
                g.enemies.forEach(e => {
                    const dx = e.x - g.player.x, dy = e.y - g.player.y;
                    const d = Math.sqrt(dx*dx + dy*dy);
                    if (d < range && d > 0) {
                        e.vx += (dx/d) * 10 * stacks;
                        e.vy += (dy/d) * 10 * stacks;
                    }
                });
                g.visualEffects.push({ type: 'shockwave', x: g.player.x, y: g.player.y, radius: range, timer: 0.3 });
            }
        },
        TIME_SLOW: {
            name: 'Time Slow',
            desc: 'Briefly slows time',
            apply: (g, stacks) => {
                g.timeScale = Math.max(0.1, 0.5 - stacks * 0.05);
                setTimeout(() => { g.timeScale = 1; }, 200 + stacks * 50);
            }
        },
        AREA_BURST: {
            name: 'Area Burst',
            desc: 'Damages nearby enemies',
            apply: (g, stacks) => {
                const range = 50 + stacks * 15;
                const damage = 1 + Math.floor(stacks/2);
                g.enemies.forEach(e => {
                    const dx = e.x - g.player.x, dy = e.y - g.player.y;
                    const d = Math.sqrt(dx*dx + dy*dy);
                    if (d < range) {
                        e.hp -= damage;
                        g.spawnHitEffect(e.x, e.y, e.dna.body.color);
                    }
                });
                g.visualEffects.push({ type: 'burst', x: g.player.x, y: g.player.y, radius: range, timer: 0.2, color: '#f0f' });
            }
        },
        CHAIN_LIGHTNING: {
            name: 'Chain Lightning',
            desc: 'Zaps nearby enemies',
            apply: (g, stacks) => {
                let targets = [...g.enemies].filter(e => !e.dead).sort((a, b) => {
                    const da = Math.hypot(a.x - g.player.x, a.y - g.player.y);
                    const db = Math.hypot(b.x - g.player.x, b.y - g.player.y);
                    return da - db;
                }).slice(0, 2 + stacks);
                
                let prev = g.player;
                targets.forEach(t => {
                    t.hp -= 1;
                    g.visualEffects.push({ type: 'lightning', x1: prev.x, y1: prev.y, x2: t.x, y2: t.y, timer: 0.2 });
                    prev = t;
                });
            }
        },
        CONVERT: {
            name: 'Convert Enemy',
            desc: 'Turns weak enemies friendly',
            apply: (g, stacks) => {
                const target = g.enemies.find(e => !e.dead && e.hp <= stacks && !e.friendly);
                if (target) {
                    target.friendly = true;
                    target.dna.body.color = '#0ff';
                    g.visualEffects.push({ type: 'convert', x: target.x, y: target.y, timer: 0.5 });
                }
            }
        },
        SCORE_MULT: {
            name: 'Score Boost',
            desc: 'Multiplies score gain',
            apply: (g, stacks) => {
                g.scoreMult = Math.max(g.scoreMult, 1 + stacks * 0.5);
                setTimeout(() => { g.scoreMult = 1; }, 2000);
            }
        },
        SHIELD_PULSE: {
            name: 'Shield Pulse',
            desc: 'Destroys nearby bullets',
            apply: (g, stacks) => {
                const range = 40 + stacks * 20;
                g.enemyBullets = g.enemyBullets.filter(b => {
                    const d = Math.hypot(b.x - g.player.x, b.y - g.player.y);
                    if (d < range) {
                        g.spawnHitEffect(b.x, b.y, '#0ff');
                        return false;
                    }
                    return true;
                });
                g.visualEffects.push({ type: 'shield', x: g.player.x, y: g.player.y, radius: range, timer: 0.2 });
            }
        }
    };
    
    // ========== MUTATOR SYSTEM ==========
    const MUTATORS = {
        BOUNCY_BULLETS: {
            name: 'Bouncy Bullets',
            desc: 'Enemy bullets bounce once',
            color: '#f80',
            apply: (g) => { g.rules.bouncyBullets = true; }
        },
        ROTATING_SCREEN: {
            name: 'Vertigo',
            desc: 'Screen slowly rotates',
            color: '#f0f',
            apply: (g) => { g.rules.rotatingScreen = true; }
        },
        ENEMY_TRAILS: {
            name: 'Slime Trail',
            desc: 'All enemies leave trails',
            color: '#0f0',
            apply: (g) => { g.rules.enemyTrails = true; }
        },
        DEATH_SLOW: {
            name: 'Last Chance',
            desc: 'Time slows near bullets',
            color: '#0ff',
            apply: (g) => { g.rules.deathSlow = true; }
        },
        GRAVITY_BULLETS: {
            name: 'Heavy Rounds',
            desc: 'Bullets affected by gravity',
            color: '#88f',
            apply: (g) => { g.rules.gravityBullets = true; }
        },
        ELITE_HUNTERS: {
            name: 'Elite Hunters',
            desc: 'Kill streaks spawn elites',
            color: '#f00',
            apply: (g) => { g.rules.eliteHunters = true; }
        },
        SHRINKING_ARENA: {
            name: 'Closing In',
            desc: 'Arena shrinks over time',
            color: '#ff0',
            apply: (g) => { g.rules.shrinkingArena = true; }
        },
        BULLET_HELL: {
            name: 'Bullet Hell',
            desc: 'Enemies shoot more often',
            color: '#f08',
            apply: (g) => { g.rules.bulletHell = true; }
        },
        SPEED_DEMON: {
            name: 'Speed Demon',
            desc: 'Everything moves faster',
            color: '#8f0',
            apply: (g) => { g.rules.speedDemon = true; }
        },
        CHAOS_SPAWN: {
            name: 'Chaos Spawn',
            desc: 'Enemies spawn in waves',
            color: '#f0f',
            apply: (g) => { g.rules.chaosSpawn = true; }
        },
        MAGNETIC: {
            name: 'Magnetic',
            desc: 'XP auto-collects nearby',
            color: '#ff0',
            apply: (g) => { g.rules.magnetic = true; }
        },
        ECHO: {
            name: 'Echo',
            desc: 'Player bullets split on hit',
            color: '#0ff',
            apply: (g) => { g.rules.echo = true; }
        }
    };
    
    // ========== META PROGRESSION ==========
    const META = {
        load() {
            try {
                const data = localStorage.getItem('1hp_chaos_meta');
                return data ? JSON.parse(data) : this.getDefault();
            } catch(e) {
                return this.getDefault();
            }
        },
        save(data) {
            try {
                localStorage.setItem('1hp_chaos_meta', JSON.stringify(data));
            } catch(e) {}
        },
        getDefault() {
            return {
                totalRuns: 0,
                bestScore: 0,
                bestTime: 0,
                totalKills: 0,
                unlocks: {
                    triggers: ['ON_KILL', 'ON_NEAR_MISS'],
                    effects: ['PROJECTILE', 'SHOCKWAVE'],
                    mutators: ['BOUNCY_BULLETS', 'ENEMY_TRAILS'],
                    bodies: ['SMALL', 'MEDIUM'],
                    movements: ['STRAIGHT', 'ZIGZAG'],
                    attacks: ['NONE', 'BULLET_SPRAY'],
                    modifiers: ['NONE', 'EXPLODE']
                }
            };
        },
        getUnlockCount(data) {
            const u = data.unlocks;
            return u.triggers.length + u.effects.length + u.mutators.length + 
                   u.bodies.length + u.movements.length + u.attacks.length + u.modifiers.length;
        },
        checkUnlocks(data, score, time, kills) {
            const newUnlocks = [];
            const u = data.unlocks;
            
            // Score unlocks
            if (score >= 500 && !u.effects.includes('AREA_BURST')) { u.effects.push('AREA_BURST'); newUnlocks.push('Area Burst'); }
            if (score >= 1000 && !u.triggers.includes('ON_MULTI_KILL')) { u.triggers.push('ON_MULTI_KILL'); newUnlocks.push('Multi-Kill Trigger'); }
            if (score >= 2000 && !u.effects.includes('CHAIN_LIGHTNING')) { u.effects.push('CHAIN_LIGHTNING'); newUnlocks.push('Chain Lightning'); }
            if (score >= 3000 && !u.mutators.includes('ELITE_HUNTERS')) { u.mutators.push('ELITE_HUNTERS'); newUnlocks.push('Elite Hunters Mutator'); }
            if (score >= 5000 && !u.effects.includes('CONVERT')) { u.effects.push('CONVERT'); newUnlocks.push('Convert Effect'); }
            
            // Time unlocks
            if (time >= 30 && !u.triggers.includes('ON_MOVE')) { u.triggers.push('ON_MOVE'); newUnlocks.push('On Move Trigger'); }
            if (time >= 60 && !u.triggers.includes('ON_STOP')) { u.triggers.push('ON_STOP'); newUnlocks.push('On Stop Trigger'); }
            if (time >= 90 && !u.mutators.includes('DEATH_SLOW')) { u.mutators.push('DEATH_SLOW'); newUnlocks.push('Last Chance Mutator'); }
            if (time >= 120 && !u.effects.includes('TIME_SLOW')) { u.effects.push('TIME_SLOW'); newUnlocks.push('Time Slow Effect'); }
            if (time >= 180 && !u.triggers.includes('ON_STREAK')) { u.triggers.push('ON_STREAK'); newUnlocks.push('Streak Trigger'); }
            
            // Kill unlocks
            if (kills >= 20 && !u.bodies.includes('TANK')) { u.bodies.push('TANK'); newUnlocks.push('Tank Enemy'); }
            if (kills >= 50 && !u.movements.includes('CHARGE')) { u.movements.push('CHARGE'); newUnlocks.push('Charge Movement'); }
            if (kills >= 100 && !u.bodies.includes('SPLITTER')) { u.bodies.push('SPLITTER'); newUnlocks.push('Splitter Enemy'); }
            if (kills >= 150 && !u.attacks.includes('BURST')) { u.attacks.push('BURST'); newUnlocks.push('Burst Attack'); }
            if (kills >= 200 && !u.bodies.includes('SHIELDED')) { u.bodies.push('SHIELDED'); newUnlocks.push('Shielded Enemy'); }
            if (kills >= 300 && !u.modifiers.includes('TRAIL')) { u.modifiers.push('TRAIL'); newUnlocks.push('Trail Modifier'); }
            
            // Run count unlocks
            if (data.totalRuns >= 5 && !u.mutators.includes('ROTATING_SCREEN')) { u.mutators.push('ROTATING_SCREEN'); newUnlocks.push('Vertigo Mutator'); }
            if (data.totalRuns >= 10 && !u.movements.includes('ORBIT')) { u.movements.push('ORBIT'); newUnlocks.push('Orbit Movement'); }
            if (data.totalRuns >= 15 && !u.attacks.includes('LASER')) { u.attacks.push('LASER'); newUnlocks.push('Laser Attack'); }
            if (data.totalRuns >= 20 && !u.mutators.includes('GRAVITY_BULLETS')) { u.mutators.push('GRAVITY_BULLETS'); newUnlocks.push('Heavy Rounds Mutator'); }
            if (data.totalRuns >= 25 && !u.movements.includes('TELEPORT')) { u.movements.push('TELEPORT'); newUnlocks.push('Teleport Movement'); }
            if (data.totalRuns >= 30 && !u.attacks.includes('HOMING')) { u.attacks.push('HOMING'); newUnlocks.push('Homing Attack'); }
            if (data.totalRuns >= 40 && !u.bodies.includes('SWARM')) { u.bodies.push('SWARM'); newUnlocks.push('Swarm Enemy'); }
            if (data.totalRuns >= 50 && !u.movements.includes('ERRATIC')) { u.movements.push('ERRATIC'); newUnlocks.push('Erratic Movement'); }
            if (data.totalRuns >= 60 && !u.attacks.includes('MINES')) { u.attacks.push('MINES'); newUnlocks.push('Mines Attack'); }
            if (data.totalRuns >= 70 && !u.attacks.includes('MELEE_DASH')) { u.attacks.push('MELEE_DASH'); newUnlocks.push('Melee Dash Attack'); }
            if (data.totalRuns >= 80 && !u.modifiers.includes('BUFF')) { u.modifiers.push('BUFF'); newUnlocks.push('Buff Modifier'); }
            if (data.totalRuns >= 90 && !u.modifiers.includes('SPAWN_HAZARD')) { u.modifiers.push('SPAWN_HAZARD'); newUnlocks.push('Hazard Spawner'); }
            if (data.totalRuns >= 100 && !u.modifiers.includes('SCREEN_EFFECT')) { u.modifiers.push('SCREEN_EFFECT'); newUnlocks.push('Screen Effect'); }
            
            // More mutator unlocks
            if (data.totalKills >= 500 && !u.mutators.includes('SHRINKING_ARENA')) { u.mutators.push('SHRINKING_ARENA'); newUnlocks.push('Shrinking Arena'); }
            if (data.totalKills >= 1000 && !u.mutators.includes('BULLET_HELL')) { u.mutators.push('BULLET_HELL'); newUnlocks.push('Bullet Hell'); }
            if (data.totalKills >= 2000 && !u.mutators.includes('SPEED_DEMON')) { u.mutators.push('SPEED_DEMON'); newUnlocks.push('Speed Demon'); }
            if (data.totalKills >= 3000 && !u.mutators.includes('CHAOS_SPAWN')) { u.mutators.push('CHAOS_SPAWN'); newUnlocks.push('Chaos Spawn'); }
            if (data.totalKills >= 4000 && !u.mutators.includes('MAGNETIC')) { u.mutators.push('MAGNETIC'); newUnlocks.push('Magnetic'); }
            if (data.totalKills >= 5000 && !u.mutators.includes('ECHO')) { u.mutators.push('ECHO'); newUnlocks.push('Echo'); }
            
            // Trigger unlocks
            if (data.bestScore >= 1500 && !u.triggers.includes('ON_PERFECT_DODGE')) { u.triggers.push('ON_PERFECT_DODGE'); newUnlocks.push('Perfect Dodge Trigger'); }
            if (data.bestScore >= 4000 && !u.triggers.includes('ON_WALL')) { u.triggers.push('ON_WALL'); newUnlocks.push('Wall Trigger'); }
            
            // Effect unlocks
            if (data.bestTime >= 150 && !u.effects.includes('SCORE_MULT')) { u.effects.push('SCORE_MULT'); newUnlocks.push('Score Multiplier'); }
            if (data.bestTime >= 240 && !u.effects.includes('SHIELD_PULSE')) { u.effects.push('SHIELD_PULSE'); newUnlocks.push('Shield Pulse'); }
            
            // Modifier unlocks
            if (data.totalRuns >= 110 && !u.modifiers.includes('ARENA_CHANGE')) { u.modifiers.push('ARENA_CHANGE'); newUnlocks.push('Arena Changer'); }
            
            return newUnlocks;
        }
    };
    
    // ========== MAIN GAME CLASS ==========
    class Game {
        constructor() {
            this.canvas = document.getElementById('gameCanvas');
            this.ctx = this.canvas.getContext('2d');
            this.audio = new AudioEngine();
            this.meta = META.load();
            
            this.resize();
            window.addEventListener('resize', () => this.resize());
            
            this.setupInput();
            this.showStartScreen();
        }
        
        resize() {
            const ratio = CONFIG.CANVAS_WIDTH / CONFIG.CANVAS_HEIGHT;
            let w = window.innerWidth;
            let h = window.innerHeight;
            
            if (w / h > ratio) {
                w = h * ratio;
            } else {
                h = w / ratio;
            }
            
            this.canvas.width = CONFIG.CANVAS_WIDTH;
            this.canvas.height = CONFIG.CANVAS_HEIGHT;
            this.canvas.style.width = w + 'px';
            this.canvas.style.height = h + 'px';
            this.scale = w / CONFIG.CANVAS_WIDTH;
        }
        
        setupInput() {
            this.touch = { active: false, x: 0, y: 0, startX: 0, startY: 0 };
            
            const getPos = (e) => {
                const rect = this.canvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return {
                    x: (clientX - rect.left) / this.scale,
                    y: (clientY - rect.top) / this.scale
                };
            };
            
            const start = (e) => {
                e.preventDefault();
                this.audio.resume();
                const pos = getPos(e);
                this.touch.active = true;
                this.touch.startX = pos.x;
                this.touch.startY = pos.y;
                this.touch.x = pos.x;
                this.touch.y = pos.y;
            };
            
            const move = (e) => {
                e.preventDefault();
                if (!this.touch.active) return;
                const pos = getPos(e);
                this.touch.x = pos.x;
                this.touch.y = pos.y;
            };
            
            const end = (e) => {
                e.preventDefault();
                this.touch.active = false;
            };
            
            this.canvas.addEventListener('touchstart', start, { passive: false });
            this.canvas.addEventListener('touchmove', move, { passive: false });
            this.canvas.addEventListener('touchend', end, { passive: false });
            this.canvas.addEventListener('mousedown', start);
            this.canvas.addEventListener('mousemove', move);
            this.canvas.addEventListener('mouseup', end);
            this.canvas.addEventListener('mouseleave', end);
        }
        
        showStartScreen() {
            document.getElementById('startScreen').style.display = 'flex';
            document.getElementById('deathScreen').style.display = 'none';
            document.getElementById('unlockCount').textContent = META.getUnlockCount(this.meta);
            
            document.getElementById('startBtn').onclick = () => {
                this.audio.init();
                this.startGame();
            };
        }
        
        startGame() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('deathScreen').style.display = 'none';
            
            // Reset game state
            this.player = {
                x: CONFIG.CANVAS_WIDTH / 2,
                y: CONFIG.CANVAS_HEIGHT * 0.7,
                vx: 0, vy: 0,
                size: CONFIG.PLAYER_SIZE,
                moving: false,
                wasMoving: false,
                nearMiss: false,
                perfectDodge: false,
                justKilled: false,
                multiKill: 0,
                multiKillTimer: 0,
                nearWall: false,
                streak: 0,
                streakTick: false,
                trail: []
            };
            
            this.enemies = [];
            this.enemyBullets = [];
            this.playerBullets = [];
            this.particles = [];
            this.xpOrbs = [];
            this.hazards = [];
            this.visualEffects = [];
            
            this.score = 0;
            this.scoreMult = 1;
            this.xp = 0;
            this.level = 1;
            this.time = 0;
            this.kills = 0;
            this.timeScale = 1;
            this.gameOver = false;
            this.paused = false;
            this.upgradeMenuOpen = false;
            
            this.arena = {
                shrinkAmount: 0,
                rotation: 0
            };
            
            this.rules = {};
            this.screenEffects = { shake: 0, flash: 0, distort: 0, chromatic: 0 };
            
            this.upgrades = {};
            this.upgradeCooldowns = {};
            
            this.spawnTimer = 0;
            this.spawnRate = CONFIG.SPAWN_RATE_INITIAL;
            this.waveNumber = 0;
            
            // Select mutators
            this.activeMutators = this.selectMutators();
            this.activeMutators.forEach(m => MUTATORS[m].apply(this));
            this.updateMutatorUI();
            
            this.autoAttackTimer = 0;
            
            this.audio.startMusic();
            this.lastTime = performance.now();
            this.gameLoop();
        }
        
        selectMutators() {
            const available = this.meta.unlocks.mutators;
            const count = 2 + Math.floor(Math.random() * 2); // 2-3 mutators
            const selected = [];
            const pool = [...available];
            
            for (let i = 0; i < Math.min(count, pool.length); i++) {
                const idx = Math.floor(Math.random() * pool.length);
                selected.push(pool.splice(idx, 1)[0]);
            }
            
            return selected;
        }
        
        updateMutatorUI() {
            const el = document.getElementById('mutators');
            el.innerHTML = this.activeMutators.map(m => 
                `<span style="color:${MUTATORS[m].color}">${MUTATORS[m].name}</span>`
            ).join(' â€¢ ');
        }
        
        gameLoop() {
            if (this.gameOver) return;
            
            const now = performance.now();
            let dt = (now - this.lastTime) / 1000;
            this.lastTime = now;
            
            // Cap delta time
            dt = Math.min(dt, 0.1);
            
            if (!this.paused && !this.upgradeMenuOpen) {
                dt *= this.timeScale;
                this.update(dt);
            }
            
            this.render();
            requestAnimationFrame(() => this.gameLoop());
        }
        
        update(dt) {
            this.time += dt;
            this.player.streak += dt;
            this.player.streakTick = Math.floor(this.player.streak) % 5 === 0 && Math.floor(this.player.streak - dt) % 5 !== 0;
            
            // Update music intensity
            const intensity = Math.min(1, this.time / 120 + this.enemies.length / 20);
            this.audio.setIntensity(intensity);
            
            // Reset per-frame flags
            this.player.nearMiss = false;
            this.player.perfectDodge = false;
            this.player.justKilled = false;
            this.player.wasMoving = this.player.moving;
            
            // Multi-kill timer
            if (this.player.multiKillTimer > 0) {
                this.player.multiKillTimer -= dt;
                if (this.player.multiKillTimer <= 0) {
                    this.player.multiKill = 0;
                }
            }
            
            this.updatePlayer(dt);
            this.updateAutoAttack(dt);
            this.updateEnemies(dt);
            this.updateBullets(dt);
            this.updateHazards(dt);
            this.updateXPOrbs(dt);
            this.updateParticles(dt);
            this.updateVisualEffects(dt);
            this.checkCollisions();
            this.updateTriggers(dt);
            this.updateSpawning(dt);
            this.updateArena(dt);
            this.updateUI();
            
            // Decay screen effects
            this.screenEffects.shake *= 0.9;
            this.screenEffects.flash *= 0.85;
            this.screenEffects.distort *= 0.95;
            this.screenEffects.chromatic *= 0.9;
            
            // Death slow mutator
            if (this.rules.deathSlow) {
                let minDist = Infinity;
                this.enemyBullets.forEach(b => {
                    const d = Math.hypot(b.x - this.player.x, b.y - this.player.y);
                    minDist = Math.min(minDist, d);
                });
                if (minDist < 50) {
                    this.timeScale = 0.3 + (minDist / 50) * 0.7;
                } else {
                    this.timeScale = Math.min(1, this.timeScale + dt * 2);
                }
            }
        }
        
        updatePlayer(dt) {
            const p = this.player;
            
            // Input handling
            if (this.touch.active) {
                const dx = this.touch.x - this.touch.startX;
                const dy = this.touch.y - this.touch.startY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist > 5) {
                    const speed = Math.min(dist / 30, 1) * CONFIG.PLAYER_SPEED;
                    p.vx += (dx / dist) * speed * dt * 60;
                    p.vy += (dy / dist) * speed * dt * 60;
                    p.moving = true;
                } else {
                    p.moving = false;
                }
            } else {
                p.moving = false;
            }
            
            // Apply friction
            p.vx *= CONFIG.PLAYER_FRICTION;
            p.vy *= CONFIG.PLAYER_FRICTION;
            
            // Move player
            p.x += p.vx;
            p.y += p.vy;
            
            // Arena bounds (with shrink)
            const margin = this.arena.shrinkAmount;
            p.x = Math.max(p.size + margin, Math.min(CONFIG.CANVAS_WIDTH - p.size - margin, p.x));
            p.y = Math.max(p.size + margin, Math.min(CONFIG.CANVAS_HEIGHT - p.size - margin, p.y));
            
            // Wall proximity check
            p.nearWall = p.x < p.size + margin + 30 || p.x > CONFIG.CANVAS_WIDTH - p.size - margin - 30 ||
                         p.y < p.size + margin + 30 || p.y > CONFIG.CANVAS_HEIGHT - p.size - margin - 30;
            
            // Trail
            p.trail.unshift({ x: p.x, y: p.y });
            if (p.trail.length > 10) p.trail.pop();
        }
        
        updateAutoAttack(dt) {
            this.autoAttackTimer += dt;
            const fireRate = 0.15;
            
            if (this.autoAttackTimer >= fireRate) {
                this.autoAttackTimer = 0;
                
                // Find nearest enemy
                let nearest = null;
                let minDist = Infinity;
                this.enemies.forEach(e => {
                    if (e.dead || e.friendly) return;
                    const d = Math.hypot(e.x - this.player.x, e.y - this.player.y);
                    if (d < minDist) {
                        minDist = d;
                        nearest = e;
                    }
                });
                
                if (nearest) {
                    const angle = Math.atan2(nearest.y - this.player.y, nearest.x - this.player.x);
                    this.playerBullets.push({
                        x: this.player.x,
                        y: this.player.y,
                        vx: Math.cos(angle) * CONFIG.BULLET_SPEED,
                        vy: Math.sin(angle) * CONFIG.BULLET_SPEED,
                        size: 4,
                        damage: 1
                    });
                    this.audio.playSound('shoot');
                }
            }
        }
        
        updateEnemies(dt) {
            const speedMult = this.rules.speedDemon ? 1.5 : 1;
            
            this.enemies.forEach(e => {
                if (e.dead) return;
                
                e.moveTimer = (e.moveTimer || 0) + dt;
                
                // Movement
                if (e.dashing) {
                    e.x += Math.cos(e.dashAngle) * 15 * speedMult;
                    e.y += Math.sin(e.dashAngle) * 15 * speedMult;
                    e.dashTimer -= dt;
                    if (e.dashTimer <= 0) e.dashing = false;
                } else {
                    const moveFn = ENEMY_DNA.MOVEMENT[e.dna.movement];
                    if (moveFn && !e.friendly) {
                        moveFn(e, this.player, dt);
                    } else if (e.friendly) {
                        // Friendly enemies attack other enemies
                        let target = this.enemies.find(other => !other.dead && !other.friendly && other !== e);
                        if (target) {
                            const dx = target.x - e.x, dy = target.y - e.y;
                            const d = Math.sqrt(dx*dx + dy*dy) || 1;
                            e.vx = (dx/d) * e.speed * CONFIG.ENEMY_BASE_SPEED;
                            e.vy = (dy/d) * e.speed * CONFIG.ENEMY_BASE_SPEED;
                        }
                    }
                    
                    const actualSpeed = speedMult * (e.buffed ? 1.5 : 1);
                    e.x += (e.vx || 0) * actualSpeed;
                    e.y += (e.vy || 0) * actualSpeed;
                }
                
                // Bounds
                const margin = this.arena.shrinkAmount;
                e.x = Math.max(e.size + margin, Math.min(CONFIG.CANVAS_WIDTH - e.size - margin, e.x));
                e.y = Math.max(e.size + margin, Math.min(CONFIG.CANVAS_HEIGHT - e.size - margin, e.y));
                
                // Attack
                const attack = ENEMY_DNA.ATTACK[e.dna.attack];
                if (attack && !e.friendly) {
                    e.attackTimer = (e.attackTimer || attack.cooldown) - dt;
                    const cooldownMult = this.rules.bulletHell ? 0.5 : 1;
                    if (e.attackTimer <= 0) {
                        const bullets = attack.fire(e, this.player);
                        bullets.forEach(b => this.enemyBullets.push(b));
                        e.attackTimer = attack.cooldown * cooldownMult;
                    }
                }
                
                // Modifier update
                const mod = ENEMY_DNA.MODIFIER[e.dna.modifier];
                if (mod && mod.onUpdate) mod.onUpdate(e, dt);
                
                // Trail mutator
                if (this.rules.enemyTrails && !e.friendly) {
                    e.globalTrailTimer = (e.globalTrailTimer || 0) + dt;
                    if (e.globalTrailTimer > 0.3) {
                        this.hazards.push({
                            x: e.x, y: e.y,
                            size: 6,
                            color: '#0f04',
                            type: 'trail',
                            timer: 1.5
                        });
                        e.globalTrailTimer = 0;
                    }
                }
                
                // Laser handling
                if (e.laserActive) {
                    // Check laser collision with player
                    const laserLength = 400;
                    const px = this.player.x - e.x;
                    const py = this.player.y - e.y;
                    const lx = Math.cos(e.laserAngle);
                    const ly = Math.sin(e.laserAngle);
                    const dot = px * lx + py * ly;
                    if (dot > 0 && dot < laserLength) {
                        const perpDist = Math.abs(px * ly - py * lx);
                        if (perpDist < this.player.size + 5) {
                            this.playerDeath();
                        }
                    }
                }
                
                // Reset buffed state
                e.buffed = false;
            });
            
            // Remove dead enemies
            this.enemies = this.enemies.filter(e => !e.dead);
        }
        
        updateBullets(dt) {
            const speedMult = this.rules.speedDemon ? 1.5 : 1;
            
            // Player bullets
            this.playerBullets.forEach(b => {
                b.x += b.vx * speedMult;
                b.y += b.vy * speedMult;
            });
            this.playerBullets = this.playerBullets.filter(b => 
                b.x > -10 && b.x < CONFIG.CANVAS_WIDTH + 10 &&
                b.y > -10 && b.y < CONFIG.CANVAS_HEIGHT + 10
            );
            
            // Enemy bullets
            this.enemyBullets.forEach(b => {
                // Homing behavior
                if (b.homing) {
                    const dx = this.player.x - b.x;
                    const dy = this.player.y - b.y;
                    const d = Math.sqrt(dx*dx + dy*dy) || 1;
                    b.vx += (dx/d) * b.speed * 0.1;
                    b.vy += (dy/d) * b.speed * 0.1;
                    const currentSpeed = Math.sqrt(b.vx*b.vx + b.vy*b.vy);
                    if (currentSpeed > b.speed) {
                        b.vx = (b.vx / currentSpeed) * b.speed;
                        b.vy = (b.vy / currentSpeed) * b.speed;
                    }
                    b.life -= dt;
                }
                
                // Gravity
                if (this.rules.gravityBullets) {
                    b.vy += 2 * dt;
                }
                
                b.x += b.vx * speedMult;
                b.y += b.vy * speedMult;
                
                // Bouncing
                if (this.rules.bouncyBullets && !b.bounced) {
                    const margin = this.arena.shrinkAmount;
                    if (b.x < margin || b.x > CONFIG.CANVAS_WIDTH - margin) {
                        b.vx *= -1;
                        b.bounced = true;
                    }
                    if (b.y < margin || b.y > CONFIG.CANVAS_HEIGHT - margin) {
                        b.vy *= -1;
                        b.bounced = true;
                    }
                }
            });
            
            this.enemyBullets = this.enemyBullets.filter(b => {
                if (b.homing && b.life <= 0) return false;
                const margin = this.arena.shrinkAmount - 20;
                return b.x > margin && b.x < CONFIG.CANVAS_WIDTH - margin &&
                       b.y > margin && b.y < CONFIG.CANVAS_HEIGHT - margin;
            });
        }
        
        updateHazards(dt) {
            this.hazards.forEach(h => {
                h.timer -= dt;
                
                if (h.type === 'mine' && h.timer <= 0 && !h.exploded) {
                    h.exploded = true;
                    // Explode
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI * 2 / 8) * i;
                        this.enemyBullets.push({
                            x: h.x, y: h.y,
                            vx: Math.cos(angle) * 4,
                            vy: Math.sin(angle) * 4,
                            size: 5, color: '#f80'
                        });
                    }
                    this.screenEffects.shake = 5;
                }
            });
            
            this.hazards = this.hazards.filter(h => {
                if (h.type === 'mine') return h.timer > -0.5;
                return h.timer > 0;
            });
        }
        
        updateXPOrbs(dt) {
            const magnetRange = this.rules.magnetic ? 150 : 50;
            
            this.xpOrbs.forEach(orb => {
                const dx = this.player.x - orb.x;
                const dy = this.player.y - orb.y;
                const d = Math.sqrt(dx*dx + dy*dy);
                
                if (d < magnetRange) {
                    const speed = 5 + (1 - d/magnetRange) * 10;
                    orb.x += (dx/d) * speed;
                    orb.y += (dy/d) * speed;
                }
                
                // Collection
                if (d < this.player.size + orb.size) {
                    orb.collected = true;
                    this.xp += orb.value;
                    this.checkLevelUp();
                }
            });
            
            this.xpOrbs = this.xpOrbs.filter(o => !o.collected);
        }
        
        updateParticles(dt) {
            this.particles.forEach(p => p.update(dt));
            this.particles = this.particles.filter(p => p.life > 0);
        }
        
        updateVisualEffects(dt) {
            this.visualEffects.forEach(e => e.timer -= dt);
            this.visualEffects = this.visualEffects.filter(e => e.timer > 0);
        }
        
        checkCollisions() {
            const p = this.player;
            
            // Player bullets vs enemies
            this.playerBullets.forEach(b => {
                this.enemies.forEach(e => {
                    if (e.dead || b.hit) return;
                    
                    // Shield check
                    if (e.dna.body.shield) {
                        const bulletAngle = Math.atan2(b.y - e.y, b.x - e.x);
                        const enemyFacing = Math.atan2(p.y - e.y, p.x - e.x);
                        const angleDiff = Math.abs(bulletAngle - enemyFacing);
                        if (angleDiff < Math.PI / 2) {
                            // Blocked by shield
                            b.hit = true;
                            this.spawnHitEffect(b.x, b.y, '#88f');
                            return;
                        }
                    }
                    
                    const d = Math.hypot(b.x - e.x, b.y - e.y);
                    if (d < b.size + e.size) {
                        b.hit = true;
                        e.hp -= b.damage;
                        this.spawnHitEffect(b.x, b.y, e.dna.body.color);
                        
                        // Echo mutator
                        if (this.rules.echo) {
                            for (let i = 0; i < 2; i++) {
                                const angle = Math.random() * Math.PI * 2;
                                this.playerBullets.push({
                                    x: b.x, y: b.y,
                                    vx: Math.cos(angle) * CONFIG.BULLET_SPEED * 0.7,
                                    vy: Math.sin(angle) * CONFIG.BULLET_SPEED * 0.7,
                                    size: 3, damage: 1
                                });
                            }
                        }
                        
                        if (e.hp <= 0) {
                            this.killEnemy(e);
                        }
                    }
                });
            });
            this.playerBullets = this.playerBullets.filter(b => !b.hit);
            
            // Friendly enemies vs other enemies
            this.enemies.forEach(friendly => {
                if (!friendly.friendly || friendly.dead) return;
                this.enemies.forEach(e => {
                    if (e.friendly || e.dead || e === friendly) return;
                    const d = Math.hypot(friendly.x - e.x, friendly.y - e.y);
                    if (d < friendly.size + e.size) {
                        e.hp -= 1;
                        if (e.hp <= 0) this.killEnemy(e);
                    }
                });
            });
            
            // Enemy bullets vs player
            this.enemyBullets.forEach(b => {
                const d = Math.hypot(b.x - p.x, b.y - p.y);
                
                // Near miss check
                if (d < CONFIG.NEAR_MISS_DISTANCE && d > p.size) {
                    p.nearMiss = true;
                    this.screenEffects.chromatic = 0.3;
                    this.audio.playSound('nearMiss');
                    this.score += Math.round(10 * this.scoreMult);
                }
                
                // Perfect dodge (very close)
                if (d < p.size + 5 && d > p.size) {
                    p.perfectDodge = true;
                    this.screenEffects.flash = 0.3;
                    this.score += Math.round(50 * this.scoreMult);
                }
                
                // Hit
                if (d < p.size + b.size) {
                    this.playerDeath();
                }
            });
            
            // Enemies vs player
            this.enemies.forEach(e => {
                if (e.dead || e.friendly) return;
                const d = Math.hypot(e.x - p.x, e.y - p.y);
                if (d < e.size + p.size) {
                    this.playerDeath();
                }
            });
            
            // Hazards vs player
            this.hazards.forEach(h => {
                if (h.type === 'mine' && h.timer > 0) return; // Mines only dangerous when exploding
                const d = Math.hypot(h.x - p.x, h.y - p.y);
                if (d < h.size + p.size) {
                    this.playerDeath();
                }
            });
        }
        
        killEnemy(e) {
            e.dead = true;
            this.kills++;
            this.player.justKilled = true;
            this.player.multiKill++;
            this.player.multiKillTimer = 1;
            this.player.streak = 0;
            
            this.score += Math.round(e.dna.body.xp * this.scoreMult);
            this.audio.playSound('kill');
            
            // Spawn XP
            this.xpOrbs.push({
                x: e.x, y: e.y,
                size: 6,
                value: e.dna.body.xp,
                color: '#0ff'
            });
            
            // Death particles
            for (let i = 0; i < 12; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 4;
                this.particles.push(new Particle(
                    e.x, e.y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    e.dna.body.color,
                    3 + Math.random() * 3,
                    0.5 + Math.random() * 0.5
                ));
            }
            
            // Modifier death effect
            const mod = ENEMY_DNA.MODIFIER[e.dna.modifier];
            if (mod && mod.onDeath) mod.onDeath(e);
            
            // Splitter
            if (e.dna.body.splits) {
                for (let i = 0; i < 2; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    this.spawnEnemy(e.x + Math.cos(angle) * 20, e.y + Math.sin(angle) * 20, 'SMALL');
                }
            }
            
            // Elite hunter spawn
            if (this.rules.eliteHunters && this.player.multiKill >= 5) {
                this.spawnElite();
                this.player.multiKill = 0;
            }
        }
        
        updateTriggers(dt) {
            // Update cooldowns
            Object.keys(this.upgradeCooldowns).forEach(key => {
                if (this.upgradeCooldowns[key] > 0) {
                    this.upgradeCooldowns[key] -= dt;
                }
            });
            
            // Check triggers
            Object.keys(this.upgrades).forEach(upgradeKey => {
                const [trigger, effect] = upgradeKey.split('_');
                const triggerDef = UPGRADE_TRIGGERS[trigger];
                const effectDef = UPGRADE_EFFECTS[effect];
                
                if (!triggerDef || !effectDef) return;
                
                const cooldownKey = upgradeKey;
                if ((this.upgradeCooldowns[cooldownKey] || 0) <= 0 && triggerDef.check(this)) {
                    effectDef.apply(this, this.upgrades[upgradeKey]);
                    this.upgradeCooldowns[cooldownKey] = triggerDef.cooldown;
                }
            });
        }
        
        checkLevelUp() {
            const xpNeeded = CONFIG.XP_TO_LEVEL * Math.pow(CONFIG.XP_SCALE, this.level - 1);
            if (this.xp >= xpNeeded) {
                this.xp -= xpNeeded;
                this.level++;
                this.audio.playSound('levelUp');
                this.showUpgradeMenu();
            }
        }
        
        showUpgradeMenu() {
            this.upgradeMenuOpen = true;
            this.timeScale = 0.1;
            
            const menu = document.getElementById('upgradeMenu');
            const options = document.getElementById('upgradeOptions');
            options.innerHTML = '';
            
            // Generate 3 random upgrade options
            const available = [];
            this.meta.unlocks.triggers.forEach(t => {
                this.meta.unlocks.effects.forEach(e => {
                    available.push({ trigger: t, effect: e });
                });
            });
            
            // Shuffle and pick 3
            for (let i = available.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [available[i], available[j]] = [available[j], available[i]];
            }
            
            const choices = available.slice(0, 3);
            
            choices.forEach(choice => {
                const div = document.createElement('div');
                div.className = 'upgrade-option';
                const triggerDef = UPGRADE_TRIGGERS[choice.trigger];
                const effectDef = UPGRADE_EFFECTS[choice.effect];
                const key = `${choice.trigger}_${choice.effect}`;
                const stacks = this.upgrades[key] || 0;
                
                div.innerHTML = `
                    <h3>${triggerDef.name} â†’ ${effectDef.name}</h3>
                    <p>${effectDef.desc}</p>
                    <p style="color:#0ff;">Stack: ${stacks + 1}</p>
                `;
                
                div.onclick = () => {
                    this.upgrades[key] = (this.upgrades[key] || 0) + 1;
                    this.closeUpgradeMenu();
                };
                
                options.appendChild(div);
            });
            
            menu.style.display = 'block';
        }
        
        closeUpgradeMenu() {
            document.getElementById('upgradeMenu').style.display = 'none';
            this.upgradeMenuOpen = false;
            this.timeScale = 1;
        }
        
        updateSpawning(dt) {
            this.spawnTimer += dt * 1000;
            
            // Decrease spawn rate over time
            this.spawnRate = Math.max(
                CONFIG.SPAWN_RATE_MIN,
                CONFIG.SPAWN_RATE_INITIAL - this.time * 10
            );
            
            // Chaos spawn mutator - wave-based spawning
            if (this.rules.chaosSpawn) {
                if (this.spawnTimer >= this.spawnRate * 3) {
                    this.spawnTimer = 0;
                    const waveSize = 3 + Math.floor(this.time / 30);
                    for (let i = 0; i < waveSize; i++) {
                        setTimeout(() => this.spawnRandomEnemy(), i * 100);
                    }
                }
            } else {
                if (this.spawnTimer >= this.spawnRate) {
                    this.spawnTimer = 0;
                    this.spawnRandomEnemy();
                }
            }
        }
        
        spawnRandomEnemy() {
            // Pick spawn position (edges)
            let x, y;
            const margin = this.arena.shrinkAmount + 20;
            const side = Math.floor(Math.random() * 4);
            
            switch(side) {
                case 0: x = margin; y = margin + Math.random() * (CONFIG.CANVAS_HEIGHT - margin * 2); break;
                case 1: x = CONFIG.CANVAS_WIDTH - margin; y = margin + Math.random() * (CONFIG.CANVAS_HEIGHT - margin * 2); break;
                case 2: x = margin + Math.random() * (CONFIG.CANVAS_WIDTH - margin * 2); y = margin; break;
                case 3: x = margin + Math.random() * (CONFIG.CANVAS_WIDTH - margin * 2); y = CONFIG.CANVAS_HEIGHT - margin; break;
            }
            
            this.spawnEnemy(x, y);
        }
        
        spawnEnemy(x, y, forceBody = null) {
            const u = this.meta.unlocks;
            
            // Select random DNA
            const bodyType = forceBody || u.bodies[Math.floor(Math.random() * u.bodies.length)];
            const movement = u.movements[Math.floor(Math.random() * u.movements.length)];
            
            // More complex enemies over time
            const complexity = Math.min(3, 1 + Math.floor(this.time / 45));
            const hasAttack = complexity >= 2 || Math.random() < 0.3;
            const hasModifier = complexity >= 3 || Math.random() < 0.2;
            
            const attack = hasAttack ? u.attacks[Math.floor(Math.random() * u.attacks.length)] : 'NONE';
            const modifier = hasModifier ? u.modifiers[Math.floor(Math.random() * u.modifiers.length)] : 'NONE';
            
            const body = ENEMY_DNA.BODY[bodyType];
            
            const enemy = {
                x, y,
                vx: 0, vy: 0,
                size: body.size,
                hp: body.hp,
                speed: body.speed,
                dna: {
                    body: { ...body, type: bodyType },
                    movement,
                    attack,
                    modifier
                },
                dead: false,
                moveTimer: Math.random() * 2
            };
            
            // Apply spawn modifier
            const mod = ENEMY_DNA.MODIFIER[modifier];
            if (mod && mod.onSpawn) mod.onSpawn(enemy);
            
            this.enemies.push(enemy);
        }
        
        spawnElite() {
            const margin = this.arena.shrinkAmount + 30;
            const angle = Math.random() * Math.PI * 2;
            const dist = 150;
            let x = this.player.x + Math.cos(angle) * dist;
            let y = this.player.y + Math.sin(angle) * dist;
            x = Math.max(margin, Math.min(CONFIG.CANVAS_WIDTH - margin, x));
            y = Math.max(margin, Math.min(CONFIG.CANVAS_HEIGHT - margin, y));
            
            const enemy = {
                x, y,
                vx: 0, vy: 0,
                size: 25,
                hp: 8,
                speed: 1.2,
                elite: true,
                dna: {
                    body: { ...ENEMY_DNA.BODY.TANK, color: '#f00', xp: 100, type: 'ELITE' },
                    movement: 'CHARGE',
                    attack: 'BURST',
                    modifier: 'EXPLODE'
                },
                dead: false,
                moveTimer: 0
            };
            
            this.enemies.push(enemy);
            this.audio.playSound('elite');
            this.screenEffects.shake = 10;
        }
        
        updateArena(dt) {
            // Shrinking arena mutator
            if (this.rules.shrinkingArena) {
                this.arena.shrinkAmount += dt * 2;
                this.arena.shrinkAmount = Math.min(this.arena.shrinkAmount, 100);
            }
            
            // Rotating screen mutator
            if (this.rules.rotatingScreen) {
                this.arena.rotation += dt * 0.1;
            }
        }
        
        spawnHitEffect(x, y, color) {
            for (let i = 0; i < 6; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 3;
                this.particles.push(new Particle(
                    x, y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    color,
                    2 + Math.random() * 2,
                    0.3 + Math.random() * 0.2
                ));
            }
        }
        
        playerDeath() {
            if (this.gameOver) return;
            this.gameOver = true;
            
            this.audio.playSound('death');
            this.audio.stopMusic();
            
            // Death explosion
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 3 + Math.random() * 8;
                this.particles.push(new Particle(
                    this.player.x, this.player.y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    ['#0ff', '#f0f', '#ff0', '#f00'][Math.floor(Math.random() * 4)],
                    4 + Math.random() * 6,
                    0.8 + Math.random() * 0.4
                ));
            }
            
            this.screenEffects.shake = 20;
            this.screenEffects.flash = 1;
            
            // Update meta
            this.meta.totalRuns++;
            this.meta.totalKills += this.kills;
            if (this.score > this.meta.bestScore) this.meta.bestScore = this.score;
            if (this.time > this.meta.bestTime) this.meta.bestTime = this.time;
            
            const newUnlocks = META.checkUnlocks(this.meta, this.score, this.time, this.kills);
            META.save(this.meta);
            
            // Show death screen after brief delay
            setTimeout(() => {
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('finalTime').textContent = this.formatTime(this.time);
                document.getElementById('finalLevel').textContent = this.level;
                
                if (newUnlocks.length > 0) {
                    const unlockText = document.createElement('p');
                    unlockText.style.color = '#0f0';
                    unlockText.innerHTML = '<br>NEW UNLOCKS:<br>' + newUnlocks.join('<br>');
                    document.getElementById('deathScreen').querySelector('.stats').appendChild(unlockText);
                }
                
                document.getElementById('deathScreen').style.display = 'flex';
                
                document.getElementById('restartBtn').onclick = () => {
                    // Clean up unlock text for next run
                    const extra = document.getElementById('deathScreen').querySelector('.stats p[style]');
                    if (extra) extra.remove();
                    this.startGame();
                };
                
                // Also allow tap anywhere to restart
                document.getElementById('deathScreen').onclick = (e) => {
                    if (e.target === document.getElementById('deathScreen')) {
                        const extra = document.getElementById('deathScreen').querySelector('.stats p[style]');
                        if (extra) extra.remove();
                        this.startGame();
                    }
                };
            }, 500);
        }
        
        updateUI() {
            document.getElementById('score').textContent = this.score;
            document.getElementById('level').textContent = 'LV ' + this.level;
            document.getElementById('time').textContent = this.formatTime(this.time);
        }
        
        formatTime(t) {
            const mins = Math.floor(t / 60);
            const secs = Math.floor(t % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        render() {
            const ctx = this.ctx;
            
            // Apply screen rotation
            ctx.save();
            if (this.arena.rotation) {
                ctx.translate(CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT / 2);
                ctx.rotate(this.arena.rotation);
                ctx.translate(-CONFIG.CANVAS_WIDTH / 2, -CONFIG.CANVAS_HEIGHT / 2);
            }
            
            // Apply screen shake
            if (this.screenEffects.shake > 0.5) {
                ctx.translate(
                    (Math.random() - 0.5) * this.screenEffects.shake,
                    (Math.random() - 0.5) * this.screenEffects.shake
                );
            }
            
            // Background
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
            
            // Arena border
            const margin = this.arena.shrinkAmount;
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.strokeRect(margin, margin, CONFIG.CANVAS_WIDTH - margin * 2, CONFIG.CANVAS_HEIGHT - margin * 2);
            
            // Danger zone (shrinking arena)
            if (margin > 0) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
                ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, margin);
                ctx.fillRect(0, CONFIG.CANVAS_HEIGHT - margin, CONFIG.CANVAS_WIDTH, margin);
                ctx.fillRect(0, margin, margin, CONFIG.CANVAS_HEIGHT - margin * 2);
                ctx.fillRect(CONFIG.CANVAS_WIDTH - margin, margin, margin, CONFIG.CANVAS_HEIGHT - margin * 2);
            }
            
            // Grid lines
            ctx.strokeStyle = '#1a1a2e';
            ctx.lineWidth = 1;
            const gridSize = 40;
            for (let x = margin; x < CONFIG.CANVAS_WIDTH - margin; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, margin);
                ctx.lineTo(x, CONFIG.CANVAS_HEIGHT - margin);
                ctx.stroke();
            }
            for (let y = margin; y < CONFIG.CANVAS_HEIGHT - margin; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(margin, y);
                ctx.lineTo(CONFIG.CANVAS_WIDTH - margin, y);
                ctx.stroke();
            }
            
            // Hazards
            this.hazards.forEach(h => {
                ctx.fillStyle = h.color;
                ctx.beginPath();
                ctx.arc(h.x, h.y, h.size, 0, Math.PI * 2);
                ctx.fill();
                
                if (h.type === 'mine' && h.timer > 0) {
                    // Warning pulse
                    const pulse = 1 + Math.sin(h.timer * 10) * 0.3;
                    ctx.strokeStyle = '#f80';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(h.x, h.y, h.size * pulse, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });
            
            // XP Orbs
            this.xpOrbs.forEach(orb => {
                ctx.fillStyle = orb.color;
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, orb.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, orb.size * 0.4, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Enemies
            this.enemies.forEach(e => {
                if (e.dead) return;
                
                ctx.fillStyle = e.dna.body.color;
                
                // Different shapes based on body type
                const bodyType = e.dna.body.type;
                ctx.beginPath();
                
                if (bodyType === 'SMALL' || bodyType === 'SWARM') {
                    // Triangle
                    const angle = Math.atan2(this.player.y - e.y, this.player.x - e.x);
                    ctx.moveTo(e.x + Math.cos(angle) * e.size, e.y + Math.sin(angle) * e.size);
                    ctx.lineTo(e.x + Math.cos(angle + 2.4) * e.size, e.y + Math.sin(angle + 2.4) * e.size);
                    ctx.lineTo(e.x + Math.cos(angle - 2.4) * e.size, e.y + Math.sin(angle - 2.4) * e.size);
                    ctx.closePath();
                } else if (bodyType === 'TANK' || bodyType === 'ELITE') {
                    // Hexagon
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i;
                        const px = e.x + Math.cos(angle) * e.size;
                        const py = e.y + Math.sin(angle) * e.size;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                } else if (bodyType === 'SPLITTER') {
                    // Diamond
                    ctx.moveTo(e.x, e.y - e.size);
                    ctx.lineTo(e.x + e.size, e.y);
                    ctx.lineTo(e.x, e.y + e.size);
                    ctx.lineTo(e.x - e.size, e.y);
                    ctx.closePath();
                } else if (bodyType === 'SHIELDED') {
                    // Pentagon with shield indicator
                    for (let i = 0; i < 5; i++) {
                        const angle = (Math.PI * 2 / 5) * i - Math.PI / 2;
                        const px = e.x + Math.cos(angle) * e.size;
                        const py = e.y + Math.sin(angle) * e.size;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                } else {
                    // Circle (default)
                    ctx.arc(e.x, e.y, e.size, 0, Math.PI * 2);
                }
                
                ctx.fill();
                
                // Shield visual
                if (e.dna.body.shield) {
                    const shieldAngle = Math.atan2(this.player.y - e.y, this.player.x - e.x);
                    ctx.strokeStyle = '#88f';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, e.size + 5, shieldAngle - 0.8, shieldAngle + 0.8);
                    ctx.stroke();
                }
                
                // Buffed indicator
                if (e.buffed) {
                    ctx.strokeStyle = '#f0f';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, e.size + 8, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Elite glow
                if (e.elite) {
                    ctx.shadowColor = '#f00';
                    ctx.shadowBlur = 15;
                    ctx.strokeStyle = '#f00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, e.size + 3, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
                
                // Friendly indicator
                if (e.friendly) {
                    ctx.strokeStyle = '#0ff';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, e.size + 5, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Charge warning
                if (e.chargeState === 'tracking' && e.chargeTimer > 1) {
                    ctx.strokeStyle = '#ff0';
                    ctx.lineWidth = 2;
                    const progress = (e.chargeTimer - 1) / 0.5;
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, e.size + 10, 0, Math.PI * 2 * progress);
                    ctx.stroke();
                }
                
                // Laser warning/active
                if (e.laserWarning || e.laserActive) {
                    const color = e.laserActive ? '#f00' : '#f008';
                    const width = e.laserActive ? 8 : 2;
                    ctx.strokeStyle = color;
                    ctx.lineWidth = width;
                    ctx.beginPath();
                    ctx.moveTo(e.x, e.y);
                    ctx.lineTo(
                        e.x + Math.cos(e.laserAngle) * 400,
                        e.y + Math.sin(e.laserAngle) * 400
                    );
                    ctx.stroke();
                }
                
                // Teleport flash
                if (e.justTeleported) {
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, e.size * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    e.justTeleported = false;
                }
            });
            
            // Enemy bullets
            this.enemyBullets.forEach(b => {
                ctx.fillStyle = b.color || '#f00';
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Glow
                ctx.shadowColor = b.color || '#f00';
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // Homing indicator
                if (b.homing) {
                    ctx.strokeStyle = '#f0f';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.size + 3, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });
            
            // Player bullets
            ctx.fillStyle = '#0ff';
            this.playerBullets.forEach(b => {
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Player trail
            if (this.player && this.player.trail) {
                this.player.trail.forEach((pos, i) => {
                    const alpha = 1 - i / this.player.trail.length;
                    ctx.fillStyle = `rgba(0, 255, 255, ${alpha * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, this.player.size * (1 - i / this.player.trail.length * 0.5), 0, Math.PI * 2);
                    ctx.fill();
                });
            }
            
            // Player
            if (this.player && !this.gameOver) {
                // Glow
                ctx.shadowColor = '#0ff';
                ctx.shadowBlur = 15;
                
                // Main body (diamond)
                ctx.fillStyle = '#0ff';
                ctx.beginPath();
                ctx.moveTo(this.player.x, this.player.y - this.player.size);
                ctx.lineTo(this.player.x + this.player.size, this.player.y);
                ctx.lineTo(this.player.x, this.player.y + this.player.size);
                ctx.lineTo(this.player.x - this.player.size, this.player.y);
                ctx.closePath();
                ctx.fill();
                
                // Core
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(this.player.x, this.player.y, this.player.size * 0.3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                
                // Hitbox indicator
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(this.player.x, this.player.y, this.player.size, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Particles
            this.particles.forEach(p => p.draw(ctx));
            
            // Visual effects
            this.visualEffects.forEach(e => {
                const alpha = e.timer / 0.3;
                
                if (e.type === 'shockwave' || e.type === 'burst' || e.type === 'shield') {
                    ctx.strokeStyle = e.color || '#0ff';
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = alpha;
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, e.radius * (1 - alpha * 0.5), 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                } else if (e.type === 'lightning') {
                    ctx.strokeStyle = '#0ff';
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = alpha;
                    ctx.beginPath();
                    ctx.moveTo(e.x1, e.y1);
                    // Jagged line
                    const steps = 5;
                    for (let i = 1; i <= steps; i++) {
                        const t = i / steps;
                        const x = e.x1 + (e.x2 - e.x1) * t + (Math.random() - 0.5) * 20;
                        const y = e.y1 + (e.y2 - e.y1) * t + (Math.random() - 0.5) * 20;
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                } else if (e.type === 'convert') {
                    ctx.fillStyle = '#0ff';
                    ctx.globalAlpha = alpha * 0.5;
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, 30 * (1 - alpha), 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            });
            
            // Screen flash
            if (this.screenEffects.flash > 0.1) {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.screenEffects.flash * 0.5})`;
                ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
            }
            
            // Chromatic aberration effect
            if (this.screenEffects.chromatic > 0.1) {
                ctx.fillStyle = `rgba(255, 0, 0, ${this.screenEffects.chromatic * 0.1})`;
                ctx.fillRect(-3, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
                ctx.fillStyle = `rgba(0, 0, 255, ${this.screenEffects.chromatic * 0.1})`;
                ctx.fillRect(3, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
            }
            
            // XP bar
            const xpNeeded = CONFIG.XP_TO_LEVEL * Math.pow(CONFIG.XP_SCALE, this.level - 1);
            const xpPercent = this.xp / xpNeeded;
            ctx.fillStyle = '#333';
            ctx.fillRect(10, CONFIG.CANVAS_HEIGHT - 20, CONFIG.CANVAS_WIDTH - 20, 10);
            ctx.fillStyle = '#0ff';
            ctx.fillRect(10, CONFIG.CANVAS_HEIGHT - 20, (CONFIG.CANVAS_WIDTH - 20) * xpPercent, 10);
            
            // Score multiplier indicator
            if (this.scoreMult > 1) {
                ctx.fillStyle = '#ff0';
                ctx.font = '14px Courier New';
                ctx.fillText(`x${this.scoreMult.toFixed(1)}`, CONFIG.CANVAS_WIDTH - 50, 60);
            }
            
            ctx.restore();
        }
    }
    
    // Initialize game
    let game;
    window.addEventListener('load', () => {
        game = new Game();
        window.game = game; // For debugging
    });
})();
</script>
</body>
</html>
