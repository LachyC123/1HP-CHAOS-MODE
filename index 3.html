<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>1HP: CHAOS MODE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;500;600;700&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --primary: #00ffff;
            --secondary: #ff00ff;
            --accent: #ffff00;
            --danger: #ff0040;
            --success: #00ff88;
            --bg-dark: #0a0a0f;
            --bg-card: rgba(20, 20, 35, 0.95);
            --text: #ffffff;
            --text-dim: #888899;
        }
        
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background: var(--bg-dark);
            font-family: 'Rajdhani', sans-serif;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            color: var(--text);
        }
        
        #gameCanvas {
            display: block;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
        }
        
        /* ========== UI LAYER ========== */
        #ui {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .ui-element {
            position: absolute;
            text-shadow: 0 0 10px currentColor;
        }
        
        #score {
            top: 15px; left: 15px;
            font-family: 'Orbitron', monospace;
            font-size: 28px;
            font-weight: 700;
            color: var(--primary);
        }
        
        #level {
            top: 15px; right: 15px;
            font-family: 'Orbitron', monospace;
            font-size: 18px;
            font-weight: 600;
            color: var(--secondary);
            background: rgba(255,0,255,0.1);
            padding: 5px 12px;
            border-radius: 20px;
            border: 1px solid var(--secondary);
        }
        
        #time {
            top: 50px; left: 15px;
            font-size: 16px;
            color: var(--accent);
            font-weight: 500;
        }
        
        #mutators {
            bottom: 15px; left: 15px;
            font-size: 13px;
            color: var(--success);
            max-width: 60%;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .mutator-tag {
            background: rgba(0,255,136,0.15);
            border: 1px solid currentColor;
            padding: 3px 10px;
            border-radius: 12px;
            font-weight: 500;
        }
        
        #upgradeList {
            top: 80px; left: 15px;
            font-size: 11px;
            color: var(--primary);
            opacity: 0.7;
            max-width: 150px;
        }
        
        /* ========== SCREENS BASE ========== */
        .screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: var(--bg-dark);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            pointer-events: auto;
            overflow-y: auto;
            padding: 20px;
        }
        
        .screen.active { display: flex; }
        
        /* ========== ANIMATED BACKGROUND ========== */
        .animated-bg {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            overflow: hidden;
            pointer-events: none;
        }
        
        .animated-bg::before {
            content: '';
            position: absolute;
            top: -50%; left: -50%;
            width: 200%; height: 200%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(0,255,255,0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255,0,255,0.03) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(255,255,0,0.02) 0%, transparent 50%);
            animation: bgRotate 60s linear infinite;
        }
        
        @keyframes bgRotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .grid-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-image: 
                linear-gradient(rgba(0,255,255,0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0,255,255,0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: gridMove 20s linear infinite;
        }
        
        @keyframes gridMove {
            from { transform: translateY(0); }
            to { transform: translateY(50px); }
        }
        
        /* ========== TITLE ANIMATION ========== */
        .title-container {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .game-title {
            font-family: 'Orbitron', monospace;
            font-size: 72px;
            font-weight: 900;
            color: var(--secondary);
            text-shadow: 
                0 0 20px var(--secondary),
                0 0 40px var(--secondary),
                0 0 80px rgba(255,0,255,0.5);
            animation: titlePulse 2s ease-in-out infinite;
            letter-spacing: 8px;
        }
        
        @keyframes titlePulse {
            0%, 100% { 
                text-shadow: 0 0 20px var(--secondary), 0 0 40px var(--secondary), 0 0 80px rgba(255,0,255,0.5);
                transform: scale(1);
            }
            50% { 
                text-shadow: 0 0 30px var(--secondary), 0 0 60px var(--secondary), 0 0 100px rgba(255,0,255,0.7);
                transform: scale(1.02);
            }
        }
        
        .subtitle {
            font-family: 'Orbitron', monospace;
            font-size: 24px;
            font-weight: 400;
            color: var(--primary);
            text-shadow: 0 0 15px var(--primary);
            letter-spacing: 12px;
            margin-top: 5px;
            animation: subtitleGlow 3s ease-in-out infinite alternate;
        }
        
        @keyframes subtitleGlow {
            from { opacity: 0.7; }
            to { opacity: 1; }
        }
        
        .tagline {
            color: var(--text-dim);
            font-size: 16px;
            margin-top: 15px;
            font-weight: 400;
        }
        
        /* ========== BUTTONS ========== */
        .btn {
            font-family: 'Orbitron', monospace;
            background: transparent;
            border: 2px solid var(--primary);
            color: var(--primary);
            padding: 15px 40px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            border-radius: 8px;
            margin: 8px;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0,255,255,0.2), transparent);
            transition: left 0.5s ease;
        }
        
        .btn:hover::before, .btn:active::before {
            left: 100%;
        }
        
        .btn:hover, .btn:active {
            background: rgba(0,255,255,0.15);
            box-shadow: 0 0 20px rgba(0,255,255,0.3), inset 0 0 20px rgba(0,255,255,0.1);
            transform: translateY(-2px);
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--secondary), var(--primary));
            border: none;
            color: #000;
            font-size: 20px;
            padding: 18px 60px;
        }
        
        .btn-primary:hover {
            box-shadow: 0 0 30px rgba(255,0,255,0.5), 0 0 60px rgba(0,255,255,0.3);
            transform: translateY(-3px) scale(1.02);
        }
        
        .btn-small {
            padding: 10px 25px;
            font-size: 13px;
        }
        
        .btn-back {
            position: absolute;
            top: 20px; left: 20px;
            padding: 10px 20px;
            font-size: 14px;
        }
        
        /* ========== MENU GRID ========== */
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 30px;
        }
        
        .best-score {
            margin-top: 30px;
            text-align: center;
        }
        
        .best-score-label {
            color: var(--text-dim);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .best-score-value {
            font-family: 'Orbitron', monospace;
            font-size: 32px;
            color: var(--accent);
            text-shadow: 0 0 20px var(--accent);
        }
        
        /* ========== PROGRESSION SCREEN ========== */
        #progressionScreen {
            justify-content: flex-start;
            padding-top: 60px;
        }
        
        .progression-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .progression-header h2 {
            font-family: 'Orbitron', monospace;
            font-size: 32px;
            color: var(--primary);
            text-shadow: 0 0 20px var(--primary);
        }
        
        .stats-dashboard {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            width: 100%;
            max-width: 600px;
            margin-bottom: 25px;
        }
        
        .stat-card {
            background: var(--bg-card);
            border: 1px solid rgba(0,255,255,0.2);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .stat-card:hover {
            border-color: var(--primary);
            box-shadow: 0 0 15px rgba(0,255,255,0.2);
        }
        
        .stat-value {
            font-family: 'Orbitron', monospace;
            font-size: 24px;
            color: var(--primary);
            font-weight: 700;
        }
        
        .stat-label {
            font-size: 11px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 5px;
        }
        
        .completion-bar {
            width: 100%;
            max-width: 600px;
            margin-bottom: 25px;
        }
        
        .completion-bar-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .completion-bar-label {
            color: var(--text-dim);
            font-size: 14px;
        }
        
        .completion-bar-percent {
            font-family: 'Orbitron', monospace;
            color: var(--success);
            font-weight: 600;
        }
        
        .completion-bar-track {
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .completion-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success), var(--primary));
            border-radius: 4px;
            transition: width 0.5s ease;
        }
        
        .unlock-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .unlock-tab {
            background: transparent;
            border: 1px solid var(--text-dim);
            color: var(--text-dim);
            padding: 8px 20px;
            font-size: 13px;
            cursor: pointer;
            border-radius: 20px;
            transition: all 0.3s ease;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 600;
        }
        
        .unlock-tab.active, .unlock-tab:hover {
            border-color: var(--primary);
            color: var(--primary);
            background: rgba(0,255,255,0.1);
        }
        
        .unlock-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 12px;
            width: 100%;
            max-width: 650px;
            max-height: 300px;
            overflow-y: auto;
            padding: 10px;
        }
        
        .unlock-card {
            background: var(--bg-card);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 12px;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .unlock-card.unlocked {
            border-color: rgba(0,255,255,0.3);
        }
        
        .unlock-card.unlocked:hover {
            border-color: var(--primary);
            transform: translateY(-3px);
            box-shadow: 0 5px 20px rgba(0,255,255,0.2);
        }
        
        .unlock-card.locked {
            opacity: 0.5;
        }
        
        .unlock-card.locked::after {
            content: 'üîí';
            position: absolute;
            top: 8px; right: 8px;
            font-size: 14px;
        }
        
        .unlock-icon {
            width: 50px;
            height: 50px;
            margin: 0 auto 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            border-radius: 10px;
            background: rgba(255,255,255,0.05);
        }
        
        .unlock-name {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 4px;
            color: var(--text);
        }
        
        .unlock-desc {
            font-size: 10px;
            color: var(--text-dim);
            line-height: 1.3;
        }
        
        .unlock-progress {
            margin-top: 8px;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .unlock-progress-fill {
            height: 100%;
            background: var(--primary);
            transition: width 0.3s ease;
        }
        
        .unlock-req {
            font-size: 9px;
            color: var(--accent);
            margin-top: 5px;
        }
        
        /* ========== CHARACTER SELECT ========== */
        #characterScreen {
            justify-content: flex-start;
            padding-top: 60px;
        }
        
        .character-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
            gap: 15px;
            width: 100%;
            max-width: 500px;
            margin-top: 20px;
        }
        
        .character-card {
            background: var(--bg-card);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .character-card.selected {
            border-color: var(--primary);
            box-shadow: 0 0 25px rgba(0,255,255,0.3);
        }
        
        .character-card.locked {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .character-card:not(.locked):hover {
            transform: translateY(-5px);
            border-color: var(--secondary);
        }
        
        .character-preview {
            width: 60px;
            height: 60px;
            margin: 0 auto 10px;
        }
        
        .character-name {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 5px;
        }
        
        .character-req {
            font-size: 10px;
            color: var(--text-dim);
        }
        
        /* ========== SETTINGS SCREEN ========== */
        .settings-group {
            width: 100%;
            max-width: 400px;
            margin: 10px 0;
        }
        
        .settings-group label {
            display: block;
            color: var(--text-dim);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }
        
        .settings-slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255,255,255,0.1);
            -webkit-appearance: none;
            appearance: none;
            outline: none;
        }
        
        .settings-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            box-shadow: 0 0 10px var(--primary);
        }
        
        .settings-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .toggle-switch {
            width: 50px;
            height: 26px;
            background: rgba(255,255,255,0.1);
            border-radius: 13px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .toggle-switch.active {
            background: var(--primary);
        }
        
        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 3px; left: 3px;
            width: 20px; height: 20px;
            background: #fff;
            border-radius: 50%;
            transition: all 0.3s ease;
        }
        
        .toggle-switch.active::after {
            left: 27px;
        }
        
        .btn-danger {
            border-color: var(--danger);
            color: var(--danger);
            margin-top: 30px;
        }
        
        .btn-danger:hover {
            background: rgba(255,0,64,0.2);
            box-shadow: 0 0 20px rgba(255,0,64,0.3);
        }
        
        /* ========== HOW TO PLAY ========== */
        .tutorial-section {
            width: 100%;
            max-width: 500px;
            margin: 15px 0;
        }
        
        .tutorial-section h3 {
            color: var(--primary);
            font-size: 18px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .tutorial-section p {
            color: var(--text-dim);
            font-size: 14px;
            line-height: 1.6;
        }
        
        .tutorial-highlight {
            background: var(--bg-card);
            border-left: 3px solid var(--accent);
            padding: 15px;
            border-radius: 0 8px 8px 0;
            margin: 10px 0;
        }
        
        .tutorial-highlight strong {
            color: var(--accent);
        }
        
        /* ========== UPGRADE MENU ========== */
        #upgradeMenu {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(10,10,15,0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 100;
            padding: 20px;
        }
        
        #upgradeMenu h2 {
            font-family: 'Orbitron', monospace;
            color: var(--primary);
            text-shadow: 0 0 20px var(--primary);
            margin-bottom: 25px;
            font-size: 28px;
            animation: titlePulse 1.5s ease-in-out infinite;
        }
        
        .upgrade-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
            max-width: 400px;
        }
        
        .upgrade-option {
            background: var(--bg-card);
            border: 2px solid rgba(0,255,255,0.3);
            border-radius: 12px;
            padding: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .upgrade-option:hover, .upgrade-option:active {
            border-color: var(--primary);
            background: rgba(0,255,255,0.1);
            transform: scale(1.02);
            box-shadow: 0 0 25px rgba(0,255,255,0.3);
        }
        
        .upgrade-icon {
            width: 50px;
            height: 50px;
            background: rgba(255,0,255,0.2);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            flex-shrink: 0;
        }
        
        .upgrade-info {
            flex: 1;
        }
        
        .upgrade-info h3 {
            color: var(--secondary);
            font-size: 15px;
            margin-bottom: 4px;
            font-weight: 600;
        }
        
        .upgrade-info p {
            color: var(--text-dim);
            font-size: 12px;
            margin-bottom: 4px;
        }
        
        .upgrade-stack {
            color: var(--primary);
            font-family: 'Orbitron', monospace;
            font-size: 12px;
        }
        
        /* ========== DEATH SCREEN ========== */
        #deathScreen {
            background: rgba(10,10,15,0.98);
        }
        
        #deathScreen h2 {
            font-family: 'Orbitron', monospace;
            color: var(--danger);
            font-size: 48px;
            text-shadow: 0 0 30px var(--danger);
            margin-bottom: 30px;
            animation: deathPulse 0.5s ease-out;
        }
        
        @keyframes deathPulse {
            0% { transform: scale(2); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .death-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .death-stat {
            text-align: center;
        }
        
        .death-stat-value {
            font-family: 'Orbitron', monospace;
            font-size: 28px;
            color: var(--primary);
        }
        
        .death-stat-label {
            font-size: 12px;
            color: var(--text-dim);
            text-transform: uppercase;
        }
        
        .new-unlocks {
            background: rgba(0,255,136,0.1);
            border: 1px solid var(--success);
            border-radius: 10px;
            padding: 15px 25px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .new-unlocks h4 {
            color: var(--success);
            font-size: 14px;
            margin-bottom: 8px;
        }
        
        .new-unlocks-list {
            color: var(--success);
            font-size: 13px;
        }
        
        .progress-preview {
            background: var(--bg-card);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 25px;
            text-align: center;
        }
        
        .progress-preview-label {
            color: var(--text-dim);
            font-size: 12px;
            margin-bottom: 5px;
        }
        
        .progress-preview-name {
            color: var(--accent);
            font-weight: 600;
        }
        
        /* ========== CONFIRM DIALOG ========== */
        .confirm-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 500;
        }
        
        .confirm-overlay.active { display: flex; }
        
        .confirm-dialog {
            background: var(--bg-card);
            border: 2px solid var(--danger);
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            max-width: 350px;
        }
        
        .confirm-dialog h3 {
            color: var(--danger);
            margin-bottom: 15px;
        }
        
        .confirm-dialog p {
            color: var(--text-dim);
            margin-bottom: 25px;
        }
        
        .confirm-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        
        /* ========== SCROLLBAR ========== */
        ::-webkit-scrollbar {
            width: 6px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.05);
            border-radius: 3px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 3px;
        }
        
        /* ========== RESPONSIVE ========== */
        @media (max-width: 500px) {
            .game-title { font-size: 48px; letter-spacing: 4px; }
            .subtitle { font-size: 18px; letter-spacing: 6px; }
            .stats-dashboard { grid-template-columns: repeat(2, 1fr); }
            .death-stats { grid-template-columns: repeat(3, 1fr); gap: 10px; }
            .death-stat-value { font-size: 22px; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div id="score" class="ui-element">0</div>
        <div id="level" class="ui-element">LV 1</div>
        <div id="time" class="ui-element">0:00</div>
        <div id="mutators" class="ui-element"></div>
        <div id="upgradeList" class="ui-element"></div>
    </div>
    
    <!-- UPGRADE MENU -->
    <div id="upgradeMenu">
        <h2>‚ö° LEVEL UP ‚ö°</h2>
        <div id="upgradeOptions" class="upgrade-options"></div>
    </div>
    
    <!-- START SCREEN -->
    <div id="startScreen" class="screen active">
        <div class="animated-bg">
            <div class="grid-overlay"></div>
        </div>
        <div class="title-container">
            <h1 class="game-title">1HP</h1>
            <div class="subtitle">CHAOS MODE</div>
            <p class="tagline">One hit kills. React or die.</p>
        </div>
        <div class="menu-buttons">
            <button class="btn btn-primary" id="startBtn">START GAME</button>
            <button class="btn" id="progressionBtn">PROGRESSION</button>
            <button class="btn" id="characterBtn">CHARACTER</button>
            <button class="btn" id="settingsBtn">SETTINGS</button>
            <button class="btn" id="tutorialBtn">HOW TO PLAY</button>
        </div>
        <div class="best-score">
            <div class="best-score-label">Best Score</div>
            <div class="best-score-value" id="bestScoreDisplay">0</div>
        </div>
    </div>
    
    <!-- PROGRESSION SCREEN -->
    <div id="progressionScreen" class="screen">
        <div class="animated-bg"><div class="grid-overlay"></div></div>
        <button class="btn btn-back" id="progressionBack">‚Üê BACK</button>
        <div class="progression-header">
            <h2>üìä PROGRESSION</h2>
        </div>
        <div class="stats-dashboard" id="statsDashboard">
            <div class="stat-card">
                <div class="stat-value" id="statRuns">0</div>
                <div class="stat-label">Total Runs</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="statBestScore">0</div>
                <div class="stat-label">Best Score</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="statBestTime">0:00</div>
                <div class="stat-label">Best Time</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="statKills">0</div>
                <div class="stat-label">Total Kills</div>
            </div>
        </div>
        <div class="completion-bar">
            <div class="completion-bar-header">
                <span class="completion-bar-label">Unlock Progress</span>
                <span class="completion-bar-percent" id="completionPercent">0%</span>
            </div>
            <div class="completion-bar-track">
                <div class="completion-bar-fill" id="completionFill"></div>
            </div>
        </div>
        <div class="unlock-tabs" id="unlockTabs">
            <button class="unlock-tab active" data-category="skins">Skins</button>
            <button class="unlock-tab" data-category="triggers">Triggers</button>
            <button class="unlock-tab" data-category="effects">Effects</button>
            <button class="unlock-tab" data-category="mutators">Mutators</button>
            <button class="unlock-tab" data-category="enemies">Enemies</button>
        </div>
        <div class="unlock-grid" id="unlockGrid"></div>
    </div>
    
    <!-- CHARACTER SELECT SCREEN -->
    <div id="characterScreen" class="screen">
        <div class="animated-bg"><div class="grid-overlay"></div></div>
        <button class="btn btn-back" id="characterBack">‚Üê BACK</button>
        <div class="progression-header">
            <h2>üé≠ SELECT CHARACTER</h2>
        </div>
        <div class="character-grid" id="characterGrid"></div>
        <button class="btn btn-primary" id="confirmCharacter" style="margin-top: 25px;">CONFIRM</button>
    </div>
    
    <!-- SETTINGS SCREEN -->
    <div id="settingsScreen" class="screen">
        <div class="animated-bg"><div class="grid-overlay"></div></div>
        <button class="btn btn-back" id="settingsBack">‚Üê BACK</button>
        <div class="progression-header">
            <h2>‚öôÔ∏è SETTINGS</h2>
        </div>
        <div class="settings-group">
            <label>Music Volume</label>
            <input type="range" class="settings-slider" id="musicVolume" min="0" max="100" value="30">
        </div>
        <div class="settings-group">
            <label>SFX Volume</label>
            <input type="range" class="settings-slider" id="sfxVolume" min="0" max="100" value="60">
        </div>
        <div class="settings-group">
            <div class="settings-toggle">
                <span>Screen Shake</span>
                <div class="toggle-switch active" id="toggleShake"></div>
            </div>
            <div class="settings-toggle">
                <span>Visual Effects</span>
                <div class="toggle-switch active" id="toggleEffects"></div>
            </div>
            <div class="settings-toggle">
                <span>Show Trail</span>
                <div class="toggle-switch active" id="toggleTrail"></div>
            </div>
        </div>
        <button class="btn btn-danger btn-small" id="resetProgressBtn">RESET PROGRESS</button>
    </div>
    
    <!-- HOW TO PLAY SCREEN -->
    <div id="tutorialScreen" class="screen">
        <div class="animated-bg"><div class="grid-overlay"></div></div>
        <button class="btn btn-back" id="tutorialBack">‚Üê BACK</button>
        <div class="progression-header">
            <h2>üìñ HOW TO PLAY</h2>
        </div>
        <div class="tutorial-section">
            <h3>üéÆ Controls</h3>
            <p>Touch/click and drag to move your character. Movement is relative to your starting touch position.</p>
        </div>
        <div class="tutorial-section">
            <h3>üíÄ Core Mechanic</h3>
            <div class="tutorial-highlight">
                <strong>You have 1 HP.</strong> One hit from any enemy or bullet means instant death. Master dodging to survive!
            </div>
        </div>
        <div class="tutorial-section">
            <h3>‚ö° Auto-Attack</h3>
            <p>Your character automatically fires at the nearest enemy. Focus on dodging!</p>
        </div>
        <div class="tutorial-section">
            <h3>üî• Upgrades</h3>
            <p>Collect XP from defeated enemies. Level up to choose powerful Trigger ‚Üí Effect combinations that activate automatically.</p>
        </div>
        <div class="tutorial-section">
            <h3>üé≤ Mutators</h3>
            <p>Each run features random rule modifiers that change gameplay. Adapt your strategy!</p>
        </div>
        <div class="tutorial-section">
            <h3>üèÜ Progression</h3>
            <p>Unlock new triggers, effects, enemies, and skins by achieving score, time, and kill milestones.</p>
        </div>
    </div>
    
    <!-- DEATH SCREEN -->
    <div id="deathScreen" class="screen">
        <div class="animated-bg"><div class="grid-overlay"></div></div>
        <h2>DEAD</h2>
        <div class="death-stats">
            <div class="death-stat">
                <div class="death-stat-value" id="finalScore">0</div>
                <div class="death-stat-label">Score</div>
            </div>
            <div class="death-stat">
                <div class="death-stat-value" id="finalTime">0:00</div>
                <div class="death-stat-label">Time</div>
            </div>
            <div class="death-stat">
                <div class="death-stat-value" id="finalLevel">1</div>
                <div class="death-stat-label">Level</div>
            </div>
        </div>
        <div id="newUnlocksContainer" class="new-unlocks" style="display: none;">
            <h4>üéâ NEW UNLOCKS!</h4>
            <div id="newUnlocksList" class="new-unlocks-list"></div>
        </div>
        <div id="progressPreview" class="progress-preview" style="display: none;">
            <div class="progress-preview-label">Progress toward next unlock:</div>
            <div class="progress-preview-name" id="nextUnlockName"></div>
            <div class="unlock-progress" style="margin-top: 10px;">
                <div class="unlock-progress-fill" id="nextUnlockProgress"></div>
            </div>
        </div>
        <button class="btn btn-primary" id="restartBtn">PLAY AGAIN</button>
        <button class="btn btn-small" id="menuBtn">MAIN MENU</button>
    </div>
    
    <!-- CONFIRM DIALOG -->
    <div id="confirmOverlay" class="confirm-overlay">
        <div class="confirm-dialog">
            <h3>‚ö†Ô∏è Reset Progress?</h3>
            <p>This will delete ALL your unlocks and statistics. This cannot be undone!</p>
            <div class="confirm-buttons">
                <button class="btn btn-small" id="confirmCancel">Cancel</button>
                <button class="btn btn-danger btn-small" id="confirmReset">Reset</button>
            </div>
        </div>
    </div>

<script>
// ============================================
// 1HP: CHAOS MODE - Professional Edition
// ============================================

(function() {
    'use strict';
    
    // ========== CONFIGURATION ==========
    const CONFIG = {
        CANVAS_WIDTH: 400,
        CANVAS_HEIGHT: 700,
        PLAYER_SIZE: 15,
        PLAYER_SPEED: 8,
        PLAYER_FRICTION: 0.85,
        BULLET_SPEED: 12,
        ENEMY_BASE_SPEED: 2,
        XP_TO_LEVEL: 100,
        XP_SCALE: 1.3,
        SPAWN_RATE_INITIAL: 2000,
        SPAWN_RATE_MIN: 400,
        NEAR_MISS_DISTANCE: 25,
    };
    
    // ========== PLAYER SKINS ==========
    const PLAYER_SKINS = {
        DIAMOND: {
            name: 'Diamond',
            shape: 'diamond',
            color: '#00ffff',
            glowColor: '#00ffff',
            trailColor: 'rgba(0,255,255,0.3)',
            unlocked: true,
            requirement: 'Default'
        },
        CIRCLE: {
            name: 'Orb',
            shape: 'circle',
            color: '#ff00ff',
            glowColor: '#ff00ff',
            trailColor: 'rgba(255,0,255,0.3)',
            unlocked: false,
            requirement: 'Reach 500 score',
            check: (m) => m.bestScore >= 500
        },
        TRIANGLE: {
            name: 'Arrow',
            shape: 'triangle',
            color: '#ffff00',
            glowColor: '#ffff00',
            trailColor: 'rgba(255,255,0,0.3)',
            unlocked: false,
            requirement: 'Survive 60 seconds',
            check: (m) => m.bestTime >= 60
        },
        HEXAGON: {
            name: 'Hex',
            shape: 'hexagon',
            color: '#00ff88',
            glowColor: '#00ff88',
            trailColor: 'rgba(0,255,136,0.3)',
            unlocked: false,
            requirement: 'Kill 100 enemies total',
            check: (m) => m.totalKills >= 100
        },
        STAR: {
            name: 'Nova',
            shape: 'star',
            color: '#ff8800',
            glowColor: '#ff8800',
            trailColor: 'rgba(255,136,0,0.3)',
            unlocked: false,
            requirement: 'Complete 10 runs',
            check: (m) => m.totalRuns >= 10
        },
        PENTAGON: {
            name: 'Shield',
            shape: 'pentagon',
            color: '#8888ff',
            glowColor: '#8888ff',
            trailColor: 'rgba(136,136,255,0.3)',
            unlocked: false,
            requirement: 'Reach level 10 in one run',
            check: (m) => m.bestLevel >= 10
        },
        CROSS: {
            name: 'Cross',
            shape: 'cross',
            color: '#ff0088',
            glowColor: '#ff0088',
            trailColor: 'rgba(255,0,136,0.3)',
            unlocked: false,
            requirement: 'Score 2000 points',
            check: (m) => m.bestScore >= 2000
        },
        GHOST: {
            name: 'Ghost',
            shape: 'ghost',
            color: '#aaffff',
            glowColor: '#aaffff',
            trailColor: 'rgba(170,255,255,0.4)',
            unlocked: false,
            requirement: 'Survive 120 seconds',
            check: (m) => m.bestTime >= 120
        },
        BLADE: {
            name: 'Blade',
            shape: 'blade',
            color: '#ff4444',
            glowColor: '#ff4444',
            trailColor: 'rgba(255,68,68,0.3)',
            unlocked: false,
            requirement: 'Kill 500 enemies total',
            check: (m) => m.totalKills >= 500
        },
        CHAOS: {
            name: 'Chaos',
            shape: 'chaos',
            color: '#ffffff',
            glowColor: '#ffffff',
            trailColor: 'rgba(255,255,255,0.4)',
            unlocked: false,
            requirement: 'Score 5000 points',
            check: (m) => m.bestScore >= 5000
        }
    };
    
    // ========== UPGRADE ICONS ==========
    const UPGRADE_ICONS = {
        PROJECTILE: 'üî´',
        SHOCKWAVE: 'üí®',
        TIME_SLOW: '‚è±Ô∏è',
        AREA_BURST: 'üí•',
        CHAIN_LIGHTNING: '‚ö°',
        CONVERT: 'üîÑ',
        SCORE_MULT: '‚ú®',
        SHIELD_PULSE: 'üõ°Ô∏è'
    };
    
    const TRIGGER_ICONS = {
        ON_MOVE: 'üèÉ',
        ON_STOP: 'üõë',
        ON_NEAR_MISS: 'üò∞',
        ON_PERFECT_DODGE: 'üòé',
        ON_KILL: 'üíÄ',
        ON_MULTI_KILL: 'üî•',
        ON_WALL: 'üß±',
        ON_STREAK: '‚è∞'
    };
    
    // ========== AUDIO ENGINE ==========
    class AudioEngine {
        constructor() {
            this.ctx = null;
            this.enabled = true;
            this.musicGain = null;
            this.sfxGain = null;
            this.musicOsc = null;
            this.bassOsc = null;
            this.intensity = 0;
            this.musicVolume = 0.15;
            this.sfxVolume = 0.3;
        }
        
        init() {
            try {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.musicGain = this.ctx.createGain();
                this.sfxGain = this.ctx.createGain();
                this.musicGain.gain.value = this.musicVolume;
                this.sfxGain.gain.value = this.sfxVolume;
                this.musicGain.connect(this.ctx.destination);
                this.sfxGain.connect(this.ctx.destination);
            } catch(e) {
                this.enabled = false;
            }
        }
        
        setMusicVolume(v) {
            this.musicVolume = v;
            if (this.musicGain) this.musicGain.gain.value = v;
        }
        
        setSfxVolume(v) {
            this.sfxVolume = v;
            if (this.sfxGain) this.sfxGain.gain.value = v;
        }
        
        resume() {
            if (this.ctx && this.ctx.state === 'suspended') {
                this.ctx.resume();
            }
        }
        
        startMusic() {
            if (!this.enabled || !this.ctx) return;
            this.stopMusic();
            
            this.bassOsc = this.ctx.createOscillator();
            this.bassOsc.type = 'sine';
            this.bassOsc.frequency.value = 55;
            const bassGain = this.ctx.createGain();
            bassGain.gain.value = 0.2;
            this.bassOsc.connect(bassGain);
            bassGain.connect(this.musicGain);
            this.bassOsc.start();
            
            this.startArpeggio();
        }
        
        startArpeggio() {
            if (!this.enabled) return;
            const notes = [110, 138.59, 164.81, 220, 164.81, 138.59];
            let noteIndex = 0;
            
            const playNote = () => {
                if (!this.enabled || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.frequency.value = notes[noteIndex] * (1 + this.intensity * 0.5);
                gain.gain.setValueAtTime(0.1 + this.intensity * 0.05, this.ctx.currentTime);
                gain.gain.setTargetAtTime(0.01, this.ctx.currentTime + 0.1, 0.05);
                osc.connect(gain);
                gain.connect(this.musicGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.15);
                noteIndex = (noteIndex + 1) % notes.length;
                
                const tempo = 200 - this.intensity * 80;
                this.arpTimer = setTimeout(playNote, Math.max(80, tempo));
            };
            playNote();
        }
        
        stopMusic() {
            if (this.bassOsc) {
                try { this.bassOsc.stop(); } catch(e) {}
                this.bassOsc = null;
            }
            if (this.arpTimer) {
                clearTimeout(this.arpTimer);
                this.arpTimer = null;
            }
        }
        
        setIntensity(val) {
            this.intensity = Math.min(1, Math.max(0, val));
        }
        
        playSound(type) {
            if (!this.enabled || !this.ctx) return;
            
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.connect(gain);
            gain.connect(this.sfxGain);
            
            switch(type) {
                case 'shoot':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(880, this.ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(220, this.ctx.currentTime + 0.1);
                    gain.gain.setValueAtTime(0.08, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.1);
                    break;
                    
                case 'kill':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(200, this.ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.15);
                    gain.gain.setValueAtTime(0.15, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.15);
                    break;
                    
                case 'nearMiss':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(1200, this.ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(2400, this.ctx.currentTime + 0.05);
                    gain.gain.setValueAtTime(0.12, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.08);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.08);
                    break;
                    
                case 'death':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(400, this.ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(30, this.ctx.currentTime + 0.5);
                    gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.5);
                    this.playNoise(0.3, 0.2);
                    break;
                    
                case 'levelUp':
                    [523, 659, 784, 1047].forEach((freq, i) => {
                        const o = this.ctx.createOscillator();
                        const g = this.ctx.createGain();
                        o.type = 'sine';
                        o.frequency.value = freq;
                        g.gain.setValueAtTime(0, this.ctx.currentTime + i * 0.08);
                        g.gain.linearRampToValueAtTime(0.12, this.ctx.currentTime + i * 0.08 + 0.04);
                        g.gain.linearRampToValueAtTime(0, this.ctx.currentTime + i * 0.08 + 0.18);
                        o.connect(g);
                        g.connect(this.sfxGain);
                        o.start(this.ctx.currentTime + i * 0.08);
                        o.stop(this.ctx.currentTime + i * 0.08 + 0.2);
                    });
                    break;
                    
                case 'elite':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(150, this.ctx.currentTime);
                    osc.frequency.setValueAtTime(200, this.ctx.currentTime + 0.1);
                    osc.frequency.setValueAtTime(150, this.ctx.currentTime + 0.2);
                    gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                    gain.gain.setValueAtTime(0.01, this.ctx.currentTime + 0.3);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.3);
                    break;
                    
                case 'mutator':
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(100, this.ctx.currentTime);
                    osc.frequency.linearRampToValueAtTime(800, this.ctx.currentTime + 0.3);
                    gain.gain.setValueAtTime(0.15, this.ctx.currentTime);
                    gain.gain.linearRampToValueAtTime(0.01, this.ctx.currentTime + 0.4);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.4);
                    break;
                    
                case 'click':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(800, this.ctx.currentTime);
                    gain.gain.setValueAtTime(0.08, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.05);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.05);
                    break;
                    
                case 'select':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(600, this.ctx.currentTime);
                    osc.frequency.linearRampToValueAtTime(900, this.ctx.currentTime + 0.1);
                    gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.12);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.12);
                    break;
            }
        }
        
        playNoise(duration, volume) {
            if (!this.ctx) return;
            const bufferSize = this.ctx.sampleRate * duration;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
            }
            const noise = this.ctx.createBufferSource();
            const gain = this.ctx.createGain();
            noise.buffer = buffer;
            gain.gain.value = volume;
            noise.connect(gain);
            gain.connect(this.sfxGain);
            noise.start();
        }
    }
    
    // ========== PARTICLE SYSTEM ==========
    class Particle {
        constructor(x, y, vx, vy, color, size, life, type = 'circle') {
            this.x = x;
            this.y = y;
            this.vx = vx;
            this.vy = vy;
            this.color = color;
            this.size = size;
            this.life = life;
            this.maxLife = life;
            this.type = type;
            this.rotation = Math.random() * Math.PI * 2;
            this.rotationSpeed = (Math.random() - 0.5) * 5;
        }
        
        update(dt) {
            this.x += this.vx * dt * 60;
            this.y += this.vy * dt * 60;
            this.life -= dt;
            this.vx *= 0.96;
            this.vy *= 0.96;
            this.rotation += this.rotationSpeed * dt;
        }
        
        draw(ctx) {
            const alpha = Math.max(0, this.life / this.maxLife);
            ctx.globalAlpha = alpha;
            ctx.fillStyle = this.color;
            
            if (this.type === 'square') {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                const s = this.size * alpha;
                ctx.fillRect(-s/2, -s/2, s, s);
                ctx.restore();
            } else if (this.type === 'star') {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                this.drawStar(ctx, 0, 0, 4, this.size * alpha, this.size * alpha * 0.5);
                ctx.restore();
            } else {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * alpha, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }
        
        drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
            let rot = Math.PI / 2 * 3;
            let x = cx;
            let y = cy;
            const step = Math.PI / spikes;

            ctx.beginPath();
            ctx.moveTo(cx, cy - outerRadius);
            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius;
                y = cy + Math.sin(rot) * outerRadius;
                ctx.lineTo(x, y);
                rot += step;
                x = cx + Math.cos(rot) * innerRadius;
                y = cy + Math.sin(rot) * innerRadius;
                ctx.lineTo(x, y);
                rot += step;
            }
            ctx.lineTo(cx, cy - outerRadius);
            ctx.closePath();
            ctx.fill();
        }
    }
    
    // ========== ENEMY DNA SYSTEM ==========
    const ENEMY_DNA = {
        BODY: {
            SMALL: { size: 10, hp: 1, speed: 1.5, color: '#0f0', xp: 10, name: 'Scout', icon: 'üü¢' },
            MEDIUM: { size: 18, hp: 2, speed: 1, color: '#ff0', xp: 20, name: 'Drone', icon: 'üü°' },
            TANK: { size: 30, hp: 5, speed: 0.5, color: '#f80', xp: 50, name: 'Tank', icon: 'üü†' },
            SPLITTER: { size: 22, hp: 2, speed: 0.8, color: '#0ff', xp: 30, splits: true, name: 'Splitter', icon: 'üîµ' },
            SHIELDED: { size: 20, hp: 3, speed: 0.7, color: '#88f', xp: 40, shield: true, name: 'Guardian', icon: 'üü£' },
            SWARM: { size: 8, hp: 1, speed: 1.8, color: '#f0f', xp: 5, name: 'Swarm', icon: 'ü©∑' }
        },
        MOVEMENT: {
            STRAIGHT: { fn: (e, p, dt) => {
                const dx = p.x - e.x, dy = p.y - e.y;
                const d = Math.sqrt(dx*dx + dy*dy) || 1;
                e.vx = (dx/d) * e.speed * CONFIG.ENEMY_BASE_SPEED;
                e.vy = (dy/d) * e.speed * CONFIG.ENEMY_BASE_SPEED;
            }, name: 'Chase', icon: '‚û°Ô∏è' },
            ZIGZAG: { fn: (e, p, dt) => {
                const dx = p.x - e.x, dy = p.y - e.y;
                const d = Math.sqrt(dx*dx + dy*dy) || 1;
                const angle = Math.atan2(dy, dx) + Math.sin(e.moveTimer * 5) * 0.8;
                e.vx = Math.cos(angle) * e.speed * CONFIG.ENEMY_BASE_SPEED;
                e.vy = Math.sin(angle) * e.speed * CONFIG.ENEMY_BASE_SPEED;
            }, name: 'Zigzag', icon: '„Ä∞Ô∏è' },
            ORBIT: { fn: (e, p, dt) => {
                const dx = p.x - e.x, dy = p.y - e.y;
                const d = Math.sqrt(dx*dx + dy*dy) || 1;
                const targetDist = 120;
                const orbitSpeed = 2;
                const angle = Math.atan2(dy, dx) + (d > targetDist ? 0 : Math.PI/2 * orbitSpeed);
                e.vx = Math.cos(angle) * e.speed * CONFIG.ENEMY_BASE_SPEED;
                e.vy = Math.sin(angle) * e.speed * CONFIG.ENEMY_BASE_SPEED;
            }, name: 'Orbit', icon: 'üîÑ' },
            CHARGE: { fn: (e, p, dt) => {
                if (!e.chargeState) e.chargeState = 'tracking';
                if (e.chargeState === 'tracking') {
                    e.chargeTimer = (e.chargeTimer || 0) + dt;
                    const dx = p.x - e.x, dy = p.y - e.y;
                    const d = Math.sqrt(dx*dx + dy*dy) || 1;
                    e.vx = (dx/d) * e.speed * CONFIG.ENEMY_BASE_SPEED * 0.3;
                    e.vy = (dy/d) * e.speed * CONFIG.ENEMY_BASE_SPEED * 0.3;
                    e.chargeAngle = Math.atan2(dy, dx);
                    if (e.chargeTimer > 1.5) {
                        e.chargeState = 'charging';
                        e.chargeTimer = 0;
                    }
                } else {
                    e.vx = Math.cos(e.chargeAngle) * e.speed * CONFIG.ENEMY_BASE_SPEED * 4;
                    e.vy = Math.sin(e.chargeAngle) * e.speed * CONFIG.ENEMY_BASE_SPEED * 4;
                    e.chargeTimer += dt;
                    if (e.chargeTimer > 0.5) {
                        e.chargeState = 'tracking';
                        e.chargeTimer = 0;
                    }
                }
            }, name: 'Charge', icon: 'üèÉ' },
            TELEPORT: { fn: (e, p, dt) => {
                e.teleportTimer = (e.teleportTimer || 0) + dt;
                if (e.teleportTimer > 2) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 50 + Math.random() * 100;
                    e.x = p.x + Math.cos(angle) * dist;
                    e.y = p.y + Math.sin(angle) * dist;
                    e.x = Math.max(e.size, Math.min(CONFIG.CANVAS_WIDTH - e.size, e.x));
                    e.y = Math.max(e.size, Math.min(CONFIG.CANVAS_HEIGHT - e.size, e.y));
                    e.teleportTimer = 0;
                    e.justTeleported = true;
                }
                const dx = p.x - e.x, dy = p.y - e.y;
                const d = Math.sqrt(dx*dx + dy*dy) || 1;
                e.vx = (dx/d) * e.speed * CONFIG.ENEMY_BASE_SPEED * 0.5;
                e.vy = (dy/d) * e.speed * CONFIG.ENEMY_BASE_SPEED * 0.5;
            }, name: 'Teleport', icon: '‚ú®' },
            ERRATIC: { fn: (e, p, dt) => {
                e.erraticTimer = (e.erraticTimer || 0) + dt;
                if (e.erraticTimer > 0.3) {
                    e.erraticAngle = Math.random() * Math.PI * 2;
                    e.erraticTimer = 0;
                }
                const dx = p.x - e.x, dy = p.y - e.y;
                const baseAngle = Math.atan2(dy, dx);
                const angle = baseAngle + (e.erraticAngle || 0) * 0.5;
                e.vx = Math.cos(angle) * e.speed * CONFIG.ENEMY_BASE_SPEED * 1.2;
                e.vy = Math.sin(angle) * e.speed * CONFIG.ENEMY_BASE_SPEED * 1.2;
            }, name: 'Erratic', icon: 'üé≤' }
        },
        ATTACK: {
            NONE: { cooldown: 9999, fire: () => [], name: 'None', icon: '‚ûñ' },
            BULLET_SPRAY: {
                cooldown: 1.5,
                name: 'Spray',
                icon: 'üî´',
                fire: (e, p, game) => {
                    const bullets = [];
                    const count = 5;
                    const spread = Math.PI / 3;
                    const baseAngle = Math.atan2(p.y - e.y, p.x - e.x);
                    for (let i = 0; i < count; i++) {
                        const angle = baseAngle - spread/2 + (spread * i / (count-1));
                        bullets.push({
                            x: e.x, y: e.y,
                            vx: Math.cos(angle) * 5,
                            vy: Math.sin(angle) * 5,
                            size: 5, color: '#f00'
                        });
                    }
                    return bullets;
                }
            },
            BURST: {
                cooldown: 2,
                name: 'Burst',
                icon: 'üí®',
                fire: (e, p, game) => {
                    const angle = Math.atan2(p.y - e.y, p.x - e.x);
                    for (let i = 0; i < 3; i++) {
                        setTimeout(() => {
                            if (e.dead) return;
                            game.enemyBullets.push({
                                x: e.x, y: e.y,
                                vx: Math.cos(angle) * 6,
                                vy: Math.sin(angle) * 6,
                                size: 6, color: '#ff0'
                            });
                        }, i * 100);
                    }
                    return [];
                }
            },
            LASER: {
                cooldown: 3,
                name: 'Laser',
                icon: 'üî¥',
                fire: (e, p, game) => {
                    e.laserWarning = true;
                    e.laserAngle = Math.atan2(p.y - e.y, p.x - e.x);
                    setTimeout(() => {
                        if (e.dead) return;
                        e.laserWarning = false;
                        e.laserActive = true;
                        setTimeout(() => { e.laserActive = false; }, 300);
                    }, 500);
                    return [];
                }
            },
            MINES: {
                cooldown: 2.5,
                name: 'Mines',
                icon: 'üí£',
                fire: (e, p, game) => {
                    game.hazards.push({
                        x: e.x, y: e.y,
                        size: 12,
                        color: '#f80',
                        type: 'mine',
                        timer: 3
                    });
                    return [];
                }
            },
            HOMING: {
                cooldown: 2.5,
                name: 'Homing',
                icon: 'üéØ',
                fire: (e, p, game) => {
                    return [{
                        x: e.x, y: e.y,
                        vx: 0, vy: 0,
                        size: 8, color: '#f0f',
                        homing: true, speed: 3,
                        life: 5
                    }];
                }
            },
            MELEE_DASH: {
                cooldown: 2,
                name: 'Dash',
                icon: '‚öîÔ∏è',
                fire: (e, p, game) => {
                    e.dashAngle = Math.atan2(p.y - e.y, p.x - e.x);
                    e.dashing = true;
                    e.dashTimer = 0.3;
                    return [];
                }
            }
        },
        MODIFIER: {
            NONE: { onSpawn: () => {}, onUpdate: () => {}, onDeath: () => {}, name: 'None', icon: '‚ûñ' },
            EXPLODE: {
                name: 'Explode',
                icon: 'üí•',
                onSpawn: () => {},
                onUpdate: () => {},
                onDeath: (e, game) => {
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI * 2 / 8) * i;
                        game.enemyBullets.push({
                            x: e.x, y: e.y,
                            vx: Math.cos(angle) * 4,
                            vy: Math.sin(angle) * 4,
                            size: 5, color: '#f80'
                        });
                    }
                }
            },
            TRAIL: {
                name: 'Trail',
                icon: 'üü¢',
                onSpawn: () => {},
                onUpdate: (e, dt, game) => {
                    e.trailTimer = (e.trailTimer || 0) + dt;
                    if (e.trailTimer > 0.2) {
                        game.hazards.push({
                            x: e.x, y: e.y,
                            size: 8,
                            color: '#0f08',
                            type: 'trail',
                            timer: 2
                        });
                        e.trailTimer = 0;
                    }
                },
                onDeath: () => {}
            },
            BUFF: {
                name: 'Aura',
                icon: '‚ú®',
                onSpawn: () => {},
                onUpdate: (e, dt, game) => {
                    game.enemies.forEach(other => {
                        if (other !== e && !other.dead) {
                            const dx = other.x - e.x, dy = other.y - e.y;
                            const d = Math.sqrt(dx*dx + dy*dy);
                            if (d < 80) other.buffed = true;
                        }
                    });
                },
                onDeath: () => {}
            },
            SPAWN_HAZARD: {
                name: 'Spawner',
                icon: 'üåÄ',
                onSpawn: () => {},
                onUpdate: (e, dt, game) => {
                    e.hazardTimer = (e.hazardTimer || 0) + dt;
                    if (e.hazardTimer > 3) {
                        game.hazards.push({
                            x: e.x + (Math.random() - 0.5) * 60,
                            y: e.y + (Math.random() - 0.5) * 60,
                            size: 20,
                            color: '#f008',
                            type: 'zone',
                            timer: 4
                        });
                        e.hazardTimer = 0;
                    }
                },
                onDeath: () => {}
            },
            SCREEN_EFFECT: {
                name: 'Distort',
                icon: 'üëÅÔ∏è',
                onSpawn: () => {},
                onUpdate: (e, dt, game) => {
                    const dx = game.player.x - e.x, dy = game.player.y - e.y;
                    const d = Math.sqrt(dx*dx + dy*dy);
                    if (d < 100) game.screenEffects.distort = Math.max(game.screenEffects.distort || 0, 1 - d/100);
                },
                onDeath: () => {}
            },
            ARENA_CHANGE: {
                name: 'Shrinker',
                icon: 'üì¶',
                onSpawn: () => {},
                onUpdate: () => {},
                onDeath: (e, game) => {
                    game.arena.shrinkAmount += 10;
                }
            }
        }
    };
    
    // ========== UPGRADE SYSTEM ==========
    const UPGRADE_TRIGGERS = {
        ON_MOVE: { name: 'On Move', desc: 'While moving', check: (g) => g.player.moving, cooldown: 0.5 },
        ON_STOP: { name: 'On Stop', desc: 'When stopping', check: (g) => !g.player.moving && g.player.wasMoving, cooldown: 0.3 },
        ON_NEAR_MISS: { name: 'Near Miss', desc: 'Dodge bullets closely', check: (g) => g.player.nearMiss, cooldown: 0.1 },
        ON_PERFECT_DODGE: { name: 'Perfect Dodge', desc: 'Extremely close dodge', check: (g) => g.player.perfectDodge, cooldown: 0.1 },
        ON_KILL: { name: 'On Kill', desc: 'When defeating enemy', check: (g) => g.player.justKilled, cooldown: 0.1 },
        ON_MULTI_KILL: { name: 'Multi-Kill', desc: '3+ kills rapidly', check: (g) => g.player.multiKill >= 3, cooldown: 0.1 },
        ON_WALL: { name: 'Wall Touch', desc: 'Near arena edge', check: (g) => g.player.nearWall, cooldown: 0.5 },
        ON_STREAK: { name: 'Survival', desc: 'Every 5s no damage', check: (g) => g.player.streak >= 5 && g.player.streakTick, cooldown: 5 }
    };
    
    const UPGRADE_EFFECTS = {
        PROJECTILE: {
            name: 'Fire Projectile',
            desc: 'Shoots bullets in move direction',
            apply: (g, stacks) => {
                const angle = Math.atan2(g.player.vy || 0.1, g.player.vx || 0.1);
                for (let i = 0; i < stacks; i++) {
                    const spread = (i - (stacks-1)/2) * 0.2;
                    g.playerBullets.push({
                        x: g.player.x, y: g.player.y,
                        vx: Math.cos(angle + spread) * CONFIG.BULLET_SPEED,
                        vy: Math.sin(angle + spread) * CONFIG.BULLET_SPEED,
                        size: 4, damage: 1 + Math.floor(stacks/3)
                    });
                }
            }
        },
        SHOCKWAVE: {
            name: 'Shockwave',
            desc: 'Pushes enemies away',
            apply: (g, stacks) => {
                const range = 60 + stacks * 20;
                g.enemies.forEach(e => {
                    const dx = e.x - g.player.x, dy = e.y - g.player.y;
                    const d = Math.sqrt(dx*dx + dy*dy);
                    if (d < range && d > 0) {
                        e.vx += (dx/d) * 10 * stacks;
                        e.vy += (dy/d) * 10 * stacks;
                    }
                });
                g.visualEffects.push({ type: 'shockwave', x: g.player.x, y: g.player.y, radius: range, timer: 0.3 });
            }
        },
        TIME_SLOW: {
            name: 'Time Slow',
            desc: 'Briefly slows time',
            apply: (g, stacks) => {
                g.timeScale = Math.max(0.1, 0.5 - stacks * 0.05);
                setTimeout(() => { g.timeScale = 1; }, 200 + stacks * 50);
            }
        },
        AREA_BURST: {
            name: 'Area Burst',
            desc: 'Damages nearby enemies',
            apply: (g, stacks) => {
                const range = 50 + stacks * 15;
                const damage = 1 + Math.floor(stacks/2);
                g.enemies.forEach(e => {
                    const dx = e.x - g.player.x, dy = e.y - g.player.y;
                    const d = Math.sqrt(dx*dx + dy*dy);
                    if (d < range) {
                        e.hp -= damage;
                        g.spawnHitEffect(e.x, e.y, e.dna.body.color);
                    }
                });
                g.visualEffects.push({ type: 'burst', x: g.player.x, y: g.player.y, radius: range, timer: 0.2, color: '#f0f' });
            }
        },
        CHAIN_LIGHTNING: {
            name: 'Chain Lightning',
            desc: 'Zaps nearby enemies',
            apply: (g, stacks) => {
                let targets = [...g.enemies].filter(e => !e.dead).sort((a, b) => {
                    const da = Math.hypot(a.x - g.player.x, a.y - g.player.y);
                    const db = Math.hypot(b.x - g.player.x, b.y - g.player.y);
                    return da - db;
                }).slice(0, 2 + stacks);
                
                let prev = g.player;
                targets.forEach(t => {
                    t.hp -= 1;
                    g.visualEffects.push({ type: 'lightning', x1: prev.x, y1: prev.y, x2: t.x, y2: t.y, timer: 0.2 });
                    prev = t;
                });
            }
        },
        CONVERT: {
            name: 'Convert Enemy',
            desc: 'Turns weak enemies friendly',
            apply: (g, stacks) => {
                const target = g.enemies.find(e => !e.dead && e.hp <= stacks && !e.friendly);
                if (target) {
                    target.friendly = true;
                    target.dna.body.color = '#0ff';
                    g.visualEffects.push({ type: 'convert', x: target.x, y: target.y, timer: 0.5 });
                }
            }
        },
        SCORE_MULT: {
            name: 'Score Boost',
            desc: 'Multiplies score gain',
            apply: (g, stacks) => {
                g.scoreMult = Math.max(g.scoreMult, 1 + stacks * 0.5);
                setTimeout(() => { g.scoreMult = 1; }, 2000);
            }
        },
        SHIELD_PULSE: {
            name: 'Shield Pulse',
            desc: 'Destroys nearby bullets',
            apply: (g, stacks) => {
                const range = 40 + stacks * 20;
                g.enemyBullets = g.enemyBullets.filter(b => {
                    const d = Math.hypot(b.x - g.player.x, b.y - g.player.y);
                    if (d < range) {
                        g.spawnHitEffect(b.x, b.y, '#0ff');
                        return false;
                    }
                    return true;
                });
                g.visualEffects.push({ type: 'shield', x: g.player.x, y: g.player.y, radius: range, timer: 0.2 });
            }
        }
    };
    
    // ========== MUTATOR SYSTEM ==========
    const MUTATORS = {
        BOUNCY_BULLETS: { name: 'Bouncy Bullets', desc: 'Enemy bullets bounce once', color: '#f80', icon: 'üèÄ', apply: (g) => { g.rules.bouncyBullets = true; } },
        ROTATING_SCREEN: { name: 'Vertigo', desc: 'Screen slowly rotates', color: '#f0f', icon: 'üåÄ', apply: (g) => { g.rules.rotatingScreen = true; } },
        ENEMY_TRAILS: { name: 'Slime Trail', desc: 'All enemies leave trails', color: '#0f0', icon: 'üü¢', apply: (g) => { g.rules.enemyTrails = true; } },
        DEATH_SLOW: { name: 'Last Chance', desc: 'Time slows near bullets', color: '#0ff', icon: '‚è±Ô∏è', apply: (g) => { g.rules.deathSlow = true; } },
        GRAVITY_BULLETS: { name: 'Heavy Rounds', desc: 'Bullets affected by gravity', color: '#88f', icon: '‚¨áÔ∏è', apply: (g) => { g.rules.gravityBullets = true; } },
        ELITE_HUNTERS: { name: 'Elite Hunters', desc: 'Kill streaks spawn elites', color: '#f00', icon: 'üëπ', apply: (g) => { g.rules.eliteHunters = true; } },
        SHRINKING_ARENA: { name: 'Closing In', desc: 'Arena shrinks over time', color: '#ff0', icon: 'üì¶', apply: (g) => { g.rules.shrinkingArena = true; } },
        BULLET_HELL: { name: 'Bullet Hell', desc: 'Enemies shoot more often', color: '#f08', icon: 'üî•', apply: (g) => { g.rules.bulletHell = true; } },
        SPEED_DEMON: { name: 'Speed Demon', desc: 'Everything moves faster', color: '#8f0', icon: 'üí®', apply: (g) => { g.rules.speedDemon = true; } },
        CHAOS_SPAWN: { name: 'Chaos Spawn', desc: 'Enemies spawn in waves', color: '#f0f', icon: 'üåä', apply: (g) => { g.rules.chaosSpawn = true; } },
        MAGNETIC: { name: 'Magnetic', desc: 'XP auto-collects nearby', color: '#ff0', icon: 'üß≤', apply: (g) => { g.rules.magnetic = true; } },
        ECHO: { name: 'Echo', desc: 'Player bullets split on hit', color: '#0ff', icon: 'üîä', apply: (g) => { g.rules.echo = true; } }
    };
    
    // ========== META PROGRESSION ==========
    const META = {
        load() {
            try {
                const data = localStorage.getItem('1hp_chaos_meta_v2');
                return data ? JSON.parse(data) : this.getDefault();
            } catch(e) {
                return this.getDefault();
            }
        },
        save(data) {
            try {
                localStorage.setItem('1hp_chaos_meta_v2', JSON.stringify(data));
            } catch(e) {}
        },
        getDefault() {
            return {
                totalRuns: 0,
                bestScore: 0,
                bestTime: 0,
                bestLevel: 1,
                totalKills: 0,
                selectedSkin: 'DIAMOND',
                settings: {
                    musicVolume: 30,
                    sfxVolume: 60,
                    screenShake: true,
                    visualEffects: true,
                    showTrail: true
                },
                unlocks: {
                    skins: ['DIAMOND'],
                    triggers: ['ON_KILL', 'ON_NEAR_MISS'],
                    effects: ['PROJECTILE', 'SHOCKWAVE'],
                    mutators: ['BOUNCY_BULLETS', 'ENEMY_TRAILS'],
                    bodies: ['SMALL', 'MEDIUM'],
                    movements: ['STRAIGHT', 'ZIGZAG'],
                    attacks: ['NONE', 'BULLET_SPRAY'],
                    modifiers: ['NONE', 'EXPLODE']
                },
                recentUnlocks: []
            };
        },
        getUnlockCount(data) {
            const u = data.unlocks;
            return u.skins.length + u.triggers.length + u.effects.length + u.mutators.length + 
                   u.bodies.length + u.movements.length + u.attacks.length + u.modifiers.length;
        },
        getTotalUnlocks() {
            return Object.keys(PLAYER_SKINS).length + 
                   Object.keys(UPGRADE_TRIGGERS).length +
                   Object.keys(UPGRADE_EFFECTS).length +
                   Object.keys(MUTATORS).length +
                   Object.keys(ENEMY_DNA.BODY).length +
                   Object.keys(ENEMY_DNA.MOVEMENT).length +
                   Object.keys(ENEMY_DNA.ATTACK).length +
                   Object.keys(ENEMY_DNA.MODIFIER).length;
        },
        checkUnlocks(data, score, time, kills, level) {
            const newUnlocks = [];
            const u = data.unlocks;
            
            // Skin unlocks
            Object.keys(PLAYER_SKINS).forEach(key => {
                const skin = PLAYER_SKINS[key];
                if (!u.skins.includes(key) && skin.check && skin.check(data)) {
                    u.skins.push(key);
                    newUnlocks.push(skin.name + ' Skin');
                }
            });
            
            // Score unlocks
            if (score >= 500 && !u.effects.includes('AREA_BURST')) { u.effects.push('AREA_BURST'); newUnlocks.push('Area Burst'); }
            if (score >= 1000 && !u.triggers.includes('ON_MULTI_KILL')) { u.triggers.push('ON_MULTI_KILL'); newUnlocks.push('Multi-Kill Trigger'); }
            if (score >= 2000 && !u.effects.includes('CHAIN_LIGHTNING')) { u.effects.push('CHAIN_LIGHTNING'); newUnlocks.push('Chain Lightning'); }
            if (score >= 3000 && !u.mutators.includes('ELITE_HUNTERS')) { u.mutators.push('ELITE_HUNTERS'); newUnlocks.push('Elite Hunters Mutator'); }
            if (score >= 5000 && !u.effects.includes('CONVERT')) { u.effects.push('CONVERT'); newUnlocks.push('Convert Effect'); }
            
            // Time unlocks
            if (time >= 30 && !u.triggers.includes('ON_MOVE')) { u.triggers.push('ON_MOVE'); newUnlocks.push('On Move Trigger'); }
            if (time >= 60 && !u.triggers.includes('ON_STOP')) { u.triggers.push('ON_STOP'); newUnlocks.push('On Stop Trigger'); }
            if (time >= 90 && !u.mutators.includes('DEATH_SLOW')) { u.mutators.push('DEATH_SLOW'); newUnlocks.push('Last Chance Mutator'); }
            if (time >= 120 && !u.effects.includes('TIME_SLOW')) { u.effects.push('TIME_SLOW'); newUnlocks.push('Time Slow Effect'); }
            if (time >= 180 && !u.triggers.includes('ON_STREAK')) { u.triggers.push('ON_STREAK'); newUnlocks.push('Streak Trigger'); }
            
            // Kill unlocks
            if (kills >= 20 && !u.bodies.includes('TANK')) { u.bodies.push('TANK'); newUnlocks.push('Tank Enemy'); }
            if (kills >= 50 && !u.movements.includes('CHARGE')) { u.movements.push('CHARGE'); newUnlocks.push('Charge Movement'); }
            if (kills >= 100 && !u.bodies.includes('SPLITTER')) { u.bodies.push('SPLITTER'); newUnlocks.push('Splitter Enemy'); }
            if (kills >= 150 && !u.attacks.includes('BURST')) { u.attacks.push('BURST'); newUnlocks.push('Burst Attack'); }
            if (kills >= 200 && !u.bodies.includes('SHIELDED')) { u.bodies.push('SHIELDED'); newUnlocks.push('Shielded Enemy'); }
            if (kills >= 300 && !u.modifiers.includes('TRAIL')) { u.modifiers.push('TRAIL'); newUnlocks.push('Trail Modifier'); }
            
            // Run count unlocks
            if (data.totalRuns >= 5 && !u.mutators.includes('ROTATING_SCREEN')) { u.mutators.push('ROTATING_SCREEN'); newUnlocks.push('Vertigo Mutator'); }
            if (data.totalRuns >= 10 && !u.movements.includes('ORBIT')) { u.movements.push('ORBIT'); newUnlocks.push('Orbit Movement'); }
            if (data.totalRuns >= 15 && !u.attacks.includes('LASER')) { u.attacks.push('LASER'); newUnlocks.push('Laser Attack'); }
            if (data.totalRuns >= 20 && !u.mutators.includes('GRAVITY_BULLETS')) { u.mutators.push('GRAVITY_BULLETS'); newUnlocks.push('Heavy Rounds Mutator'); }
            if (data.totalRuns >= 25 && !u.movements.includes('TELEPORT')) { u.movements.push('TELEPORT'); newUnlocks.push('Teleport Movement'); }
            if (data.totalRuns >= 30 && !u.attacks.includes('HOMING')) { u.attacks.push('HOMING'); newUnlocks.push('Homing Attack'); }
            if (data.totalRuns >= 40 && !u.bodies.includes('SWARM')) { u.bodies.push('SWARM'); newUnlocks.push('Swarm Enemy'); }
            if (data.totalRuns >= 50 && !u.movements.includes('ERRATIC')) { u.movements.push('ERRATIC'); newUnlocks.push('Erratic Movement'); }
            if (data.totalRuns >= 60 && !u.attacks.includes('MINES')) { u.attacks.push('MINES'); newUnlocks.push('Mines Attack'); }
            if (data.totalRuns >= 70 && !u.attacks.includes('MELEE_DASH')) { u.attacks.push('MELEE_DASH'); newUnlocks.push('Melee Dash Attack'); }
            if (data.totalRuns >= 80 && !u.modifiers.includes('BUFF')) { u.modifiers.push('BUFF'); newUnlocks.push('Buff Modifier'); }
            if (data.totalRuns >= 90 && !u.modifiers.includes('SPAWN_HAZARD')) { u.modifiers.push('SPAWN_HAZARD'); newUnlocks.push('Hazard Spawner'); }
            if (data.totalRuns >= 100 && !u.modifiers.includes('SCREEN_EFFECT')) { u.modifiers.push('SCREEN_EFFECT'); newUnlocks.push('Screen Effect'); }
            
            // More mutator unlocks
            if (data.totalKills >= 500 && !u.mutators.includes('SHRINKING_ARENA')) { u.mutators.push('SHRINKING_ARENA'); newUnlocks.push('Shrinking Arena'); }
            if (data.totalKills >= 1000 && !u.mutators.includes('BULLET_HELL')) { u.mutators.push('BULLET_HELL'); newUnlocks.push('Bullet Hell'); }
            if (data.totalKills >= 2000 && !u.mutators.includes('SPEED_DEMON')) { u.mutators.push('SPEED_DEMON'); newUnlocks.push('Speed Demon'); }
            if (data.totalKills >= 3000 && !u.mutators.includes('CHAOS_SPAWN')) { u.mutators.push('CHAOS_SPAWN'); newUnlocks.push('Chaos Spawn'); }
            if (data.totalKills >= 4000 && !u.mutators.includes('MAGNETIC')) { u.mutators.push('MAGNETIC'); newUnlocks.push('Magnetic'); }
            if (data.totalKills >= 5000 && !u.mutators.includes('ECHO')) { u.mutators.push('ECHO'); newUnlocks.push('Echo'); }
            
            // Trigger unlocks
            if (data.bestScore >= 1500 && !u.triggers.includes('ON_PERFECT_DODGE')) { u.triggers.push('ON_PERFECT_DODGE'); newUnlocks.push('Perfect Dodge Trigger'); }
            if (data.bestScore >= 4000 && !u.triggers.includes('ON_WALL')) { u.triggers.push('ON_WALL'); newUnlocks.push('Wall Trigger'); }
            
            // Effect unlocks
            if (data.bestTime >= 150 && !u.effects.includes('SCORE_MULT')) { u.effects.push('SCORE_MULT'); newUnlocks.push('Score Multiplier'); }
            if (data.bestTime >= 240 && !u.effects.includes('SHIELD_PULSE')) { u.effects.push('SHIELD_PULSE'); newUnlocks.push('Shield Pulse'); }
            
            // Modifier unlocks
            if (data.totalRuns >= 110 && !u.modifiers.includes('ARENA_CHANGE')) { u.modifiers.push('ARENA_CHANGE'); newUnlocks.push('Arena Changer'); }
            
            // Update recent unlocks
            if (newUnlocks.length > 0) {
                data.recentUnlocks = newUnlocks.concat(data.recentUnlocks).slice(0, 5);
            }
            
            return newUnlocks;
        },
        getNextUnlock(data) {
            const milestones = [
                { type: 'score', value: 500, current: data.bestScore, name: 'Area Burst (500 Score)' },
                { type: 'score', value: 1000, current: data.bestScore, name: 'Multi-Kill Trigger (1000 Score)' },
                { type: 'time', value: 30, current: data.bestTime, name: 'On Move Trigger (30s Survival)' },
                { type: 'time', value: 60, current: data.bestTime, name: 'On Stop Trigger (60s Survival)' },
                { type: 'kills', value: 100, current: data.totalKills, name: 'Splitter Enemy (100 Total Kills)' },
                { type: 'runs', value: 10, current: data.totalRuns, name: 'Orbit Movement (10 Runs)' }
            ];
            
            for (let m of milestones) {
                if (m.current < m.value) {
                    return { name: m.name, progress: m.current / m.value };
                }
            }
            return null;
        }
    };
    
    // ========== MAIN GAME CLASS ==========
    class Game {
        constructor() {
            this.canvas = document.getElementById('gameCanvas');
            this.ctx = this.canvas.getContext('2d');
            this.audio = new AudioEngine();
            this.meta = META.load();
            
            this.resize();
            window.addEventListener('resize', () => this.resize());
            
            this.setupInput();
            this.setupUI();
            this.showScreen('startScreen');
            this.updateStartScreen();
        }
        
        resize() {
            const ratio = CONFIG.CANVAS_WIDTH / CONFIG.CANVAS_HEIGHT;
            let w = window.innerWidth;
            let h = window.innerHeight;
            
            if (w / h > ratio) {
                w = h * ratio;
            } else {
                h = w / ratio;
            }
            
            this.canvas.width = CONFIG.CANVAS_WIDTH;
            this.canvas.height = CONFIG.CANVAS_HEIGHT;
            this.canvas.style.width = w + 'px';
            this.canvas.style.height = h + 'px';
            this.scale = w / CONFIG.CANVAS_WIDTH;
        }
        
        setupInput() {
            this.touch = { active: false, x: 0, y: 0, startX: 0, startY: 0 };
            
            const getPos = (e) => {
                const rect = this.canvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return {
                    x: (clientX - rect.left) / this.scale,
                    y: (clientY - rect.top) / this.scale
                };
            };
            
            const start = (e) => {
                e.preventDefault();
                this.audio.resume();
                const pos = getPos(e);
                this.touch.active = true;
                this.touch.startX = pos.x;
                this.touch.startY = pos.y;
                this.touch.x = pos.x;
                this.touch.y = pos.y;
            };
            
            const move = (e) => {
                e.preventDefault();
                if (!this.touch.active) return;
                const pos = getPos(e);
                this.touch.x = pos.x;
                this.touch.y = pos.y;
            };
            
            const end = (e) => {
                e.preventDefault();
                this.touch.active = false;
            };
            
            this.canvas.addEventListener('touchstart', start, { passive: false });
            this.canvas.addEventListener('touchmove', move, { passive: false });
            this.canvas.addEventListener('touchend', end, { passive: false });
            this.canvas.addEventListener('mousedown', start);
            this.canvas.addEventListener('mousemove', move);
            this.canvas.addEventListener('mouseup', end);
            this.canvas.addEventListener('mouseleave', end);
        }
        
        setupUI() {
            // Start screen buttons
            document.getElementById('startBtn').onclick = () => {
                this.audio.init();
                this.audio.playSound('select');
                this.startGame();
            };
            
            document.getElementById('progressionBtn').onclick = () => {
                this.audio.playSound('click');
                this.showProgressionScreen();
            };
            
            document.getElementById('characterBtn').onclick = () => {
                this.audio.playSound('click');
                this.showCharacterScreen();
            };
            
            document.getElementById('settingsBtn').onclick = () => {
                this.audio.playSound('click');
                this.showSettingsScreen();
            };
            
            document.getElementById('tutorialBtn').onclick = () => {
                this.audio.playSound('click');
                this.showScreen('tutorialScreen');
            };
            
            // Back buttons
            ['progressionBack', 'characterBack', 'settingsBack', 'tutorialBack'].forEach(id => {
                document.getElementById(id).onclick = () => {
                    this.audio.playSound('click');
                    this.showScreen('startScreen');
                    this.updateStartScreen();
                };
            });
            
            // Settings
            document.getElementById('musicVolume').oninput = (e) => {
                this.meta.settings.musicVolume = parseInt(e.target.value);
                this.audio.setMusicVolume(this.meta.settings.musicVolume / 100 * 0.5);
                META.save(this.meta);
            };
            
            document.getElementById('sfxVolume').oninput = (e) => {
                this.meta.settings.sfxVolume = parseInt(e.target.value);
                this.audio.setSfxVolume(this.meta.settings.sfxVolume / 100 * 0.5);
                META.save(this.meta);
            };
            
            ['toggleShake', 'toggleEffects', 'toggleTrail'].forEach(id => {
                document.getElementById(id).onclick = (e) => {
                    e.target.classList.toggle('active');
                    const key = id.replace('toggle', '').toLowerCase();
                    const settingKey = key === 'shake' ? 'screenShake' : key === 'effects' ? 'visualEffects' : 'showTrail';
                    this.meta.settings[settingKey] = e.target.classList.contains('active');
                    META.save(this.meta);
                    this.audio.playSound('click');
                };
            });
            
            // Reset progress
            document.getElementById('resetProgressBtn').onclick = () => {
                document.getElementById('confirmOverlay').classList.add('active');
            };
            
            document.getElementById('confirmCancel').onclick = () => {
                document.getElementById('confirmOverlay').classList.remove('active');
            };
            
            document.getElementById('confirmReset').onclick = () => {
                document.getElementById('confirmOverlay').classList.remove('active');
                this.meta = META.getDefault();
                META.save(this.meta);
                this.updateStartScreen();
                this.showScreen('startScreen');
            };
            
            // Unlock tabs
            document.querySelectorAll('.unlock-tab').forEach(tab => {
                tab.onclick = () => {
                    document.querySelectorAll('.unlock-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    this.renderUnlockGrid(tab.dataset.category);
                    this.audio.playSound('click');
                };
            });
            
            // Character confirm
            document.getElementById('confirmCharacter').onclick = () => {
                this.audio.playSound('select');
                this.showScreen('startScreen');
            };
            
            // Death screen
            document.getElementById('restartBtn').onclick = () => {
                this.audio.playSound('select');
                this.startGame();
            };
            
            document.getElementById('menuBtn').onclick = () => {
                this.audio.playSound('click');
                this.showScreen('startScreen');
                this.updateStartScreen();
            };
            
            // Load settings
            document.getElementById('musicVolume').value = this.meta.settings.musicVolume;
            document.getElementById('sfxVolume').value = this.meta.settings.sfxVolume;
            document.getElementById('toggleShake').classList.toggle('active', this.meta.settings.screenShake);
            document.getElementById('toggleEffects').classList.toggle('active', this.meta.settings.visualEffects);
            document.getElementById('toggleTrail').classList.toggle('active', this.meta.settings.showTrail);
        }
        
        showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        }
        
        updateStartScreen() {
            document.getElementById('bestScoreDisplay').textContent = this.meta.bestScore.toLocaleString();
        }
        
        showProgressionScreen() {
            this.showScreen('progressionScreen');
            
            // Update stats
            document.getElementById('statRuns').textContent = this.meta.totalRuns;
            document.getElementById('statBestScore').textContent = this.meta.bestScore.toLocaleString();
            document.getElementById('statBestTime').textContent = this.formatTime(this.meta.bestTime);
            document.getElementById('statKills').textContent = this.meta.totalKills.toLocaleString();
            
            // Update completion
            const current = META.getUnlockCount(this.meta);
            const total = META.getTotalUnlocks();
            const percent = Math.round(current / total * 100);
            document.getElementById('completionPercent').textContent = percent + '%';
            document.getElementById('completionFill').style.width = percent + '%';
            
            // Render unlock grid
            this.renderUnlockGrid('skins');
        }
        
        renderUnlockGrid(category) {
            const grid = document.getElementById('unlockGrid');
            grid.innerHTML = '';
            
            let items = [];
            const u = this.meta.unlocks;
            
            switch(category) {
                case 'skins':
                    Object.keys(PLAYER_SKINS).forEach(key => {
                        const skin = PLAYER_SKINS[key];
                        const unlocked = u.skins.includes(key);
                        items.push({
                            icon: this.getSkinPreviewSVG(key),
                            name: skin.name,
                            desc: unlocked ? 'Unlocked' : skin.requirement,
                            unlocked,
                            color: skin.color
                        });
                    });
                    break;
                case 'triggers':
                    Object.keys(UPGRADE_TRIGGERS).forEach(key => {
                        const t = UPGRADE_TRIGGERS[key];
                        const unlocked = u.triggers.includes(key);
                        items.push({
                            icon: TRIGGER_ICONS[key] || '‚ö°',
                            name: t.name,
                            desc: t.desc,
                            unlocked
                        });
                    });
                    break;
                case 'effects':
                    Object.keys(UPGRADE_EFFECTS).forEach(key => {
                        const e = UPGRADE_EFFECTS[key];
                        const unlocked = u.effects.includes(key);
                        items.push({
                            icon: UPGRADE_ICONS[key] || '‚ú®',
                            name: e.name,
                            desc: e.desc,
                            unlocked
                        });
                    });
                    break;
                case 'mutators':
                    Object.keys(MUTATORS).forEach(key => {
                        const m = MUTATORS[key];
                        const unlocked = u.mutators.includes(key);
                        items.push({
                            icon: m.icon,
                            name: m.name,
                            desc: m.desc,
                            unlocked,
                            color: m.color
                        });
                    });
                    break;
                case 'enemies':
                    Object.keys(ENEMY_DNA.BODY).forEach(key => {
                        const b = ENEMY_DNA.BODY[key];
                        const unlocked = u.bodies.includes(key);
                        items.push({
                            icon: b.icon,
                            name: b.name,
                            desc: `HP: ${b.hp}, Speed: ${b.speed}x`,
                            unlocked,
                            color: b.color
                        });
                    });
                    break;
            }
            
            items.forEach(item => {
                const card = document.createElement('div');
                card.className = 'unlock-card ' + (item.unlocked ? 'unlocked' : 'locked');
                card.innerHTML = `
                    <div class="unlock-icon" style="${item.color ? 'color:' + item.color : ''}">${item.icon}</div>
                    <div class="unlock-name">${item.name}</div>
                    <div class="unlock-desc">${item.desc}</div>
                `;
                grid.appendChild(card);
            });
        }
        
        getSkinPreviewSVG(key) {
            const skin = PLAYER_SKINS[key];
            return `<svg width="40" height="40" viewBox="0 0 40 40">
                <defs>
                    <filter id="glow-${key}" x="-50%" y="-50%" width="200%" height="200%">
                        <feGaussianBlur stdDeviation="2" result="blur"/>
                        <feComposite in="SourceGraphic" in2="blur" operator="over"/>
                    </filter>
                </defs>
                ${this.getSkinPath(skin.shape, skin.color)}
            </svg>`;
        }
        
        getSkinPath(shape, color) {
            const c = 20;
            switch(shape) {
                case 'diamond':
                    return `<polygon points="20,5 35,20 20,35 5,20" fill="${color}" filter="url(#glow-DIAMOND)"/>`;
                case 'circle':
                    return `<circle cx="20" cy="20" r="12" fill="${color}"/>`;
                case 'triangle':
                    return `<polygon points="20,5 35,32 5,32" fill="${color}"/>`;
                case 'hexagon':
                    return `<polygon points="20,5 33,12 33,28 20,35 7,28 7,12" fill="${color}"/>`;
                case 'star':
                    return `<polygon points="20,3 24,14 36,14 26,22 30,34 20,26 10,34 14,22 4,14 16,14" fill="${color}"/>`;
                case 'pentagon':
                    return `<polygon points="20,5 35,16 30,33 10,33 5,16" fill="${color}"/>`;
                case 'cross':
                    return `<polygon points="15,5 25,5 25,15 35,15 35,25 25,25 25,35 15,35 15,25 5,25 5,15 15,15" fill="${color}"/>`;
                case 'ghost':
                    return `<path d="M20,5 C28,5 35,12 35,20 L35,35 L30,30 L25,35 L20,30 L15,35 L10,30 L5,35 L5,20 C5,12 12,5 20,5" fill="${color}"/>`;
                case 'blade':
                    return `<polygon points="20,2 25,18 38,20 25,22 20,38 15,22 2,20 15,18" fill="${color}"/>`;
                case 'chaos':
                    return `<polygon points="20,2 28,10 38,12 30,20 32,30 20,25 8,30 10,20 2,12 12,10" fill="${color}"/>`;
                default:
                    return `<circle cx="20" cy="20" r="12" fill="${color}"/>`;
            }
        }
        
        showCharacterScreen() {
            this.showScreen('characterScreen');
            const grid = document.getElementById('characterGrid');
            grid.innerHTML = '';
            
            Object.keys(PLAYER_SKINS).forEach(key => {
                const skin = PLAYER_SKINS[key];
                const unlocked = this.meta.unlocks.skins.includes(key);
                const selected = this.meta.selectedSkin === key;
                
                const card = document.createElement('div');
                card.className = 'character-card' + (selected ? ' selected' : '') + (!unlocked ? ' locked' : '');
                card.innerHTML = `
                    <div class="character-preview">${this.getSkinPreviewSVG(key)}</div>
                    <div class="character-name" style="color: ${skin.color}">${skin.name}</div>
                    <div class="character-req">${unlocked ? (selected ? 'EQUIPPED' : 'Click to select') : skin.requirement}</div>
                `;
                
                if (unlocked) {
                    card.onclick = () => {
                        document.querySelectorAll('.character-card').forEach(c => c.classList.remove('selected'));
                        card.classList.add('selected');
                        this.meta.selectedSkin = key;
                        META.save(this.meta);
                        this.audio.playSound('select');
                        this.showCharacterScreen();
                    };
                }
                
                grid.appendChild(card);
            });
        }
        
        showSettingsScreen() {
            this.showScreen('settingsScreen');
        }
        
        startGame() {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            
            const skin = PLAYER_SKINS[this.meta.selectedSkin] || PLAYER_SKINS.DIAMOND;
            
            // Reset game state
            this.player = {
                x: CONFIG.CANVAS_WIDTH / 2,
                y: CONFIG.CANVAS_HEIGHT * 0.7,
                vx: 0, vy: 0,
                size: CONFIG.PLAYER_SIZE,
                moving: false,
                wasMoving: false,
                nearMiss: false,
                perfectDodge: false,
                justKilled: false,
                multiKill: 0,
                multiKillTimer: 0,
                nearWall: false,
                streak: 0,
                streakTick: false,
                trail: [],
                skin: skin,
                skinKey: this.meta.selectedSkin
            };
            
            this.enemies = [];
            this.enemyBullets = [];
            this.playerBullets = [];
            this.particles = [];
            this.xpOrbs = [];
            this.hazards = [];
            this.visualEffects = [];
            
            this.score = 0;
            this.scoreMult = 1;
            this.xp = 0;
            this.level = 1;
            this.time = 0;
            this.kills = 0;
            this.timeScale = 1;
            this.gameOver = false;
            this.paused = false;
            this.upgradeMenuOpen = false;
            
            this.arena = {
                shrinkAmount: 0,
                rotation: 0
            };
            
            this.rules = {};
            this.screenEffects = { shake: 0, flash: 0, distort: 0, chromatic: 0 };
            
            this.upgrades = {};
            this.upgradeCooldowns = {};
            
            this.spawnTimer = 0;
            this.spawnRate = CONFIG.SPAWN_RATE_INITIAL;
            this.waveNumber = 0;
            
            // Select mutators
            this.activeMutators = this.selectMutators();
            this.activeMutators.forEach(m => MUTATORS[m].apply(this));
            this.updateMutatorUI();
            
            this.autoAttackTimer = 0;
            
            this.audio.setMusicVolume(this.meta.settings.musicVolume / 100 * 0.5);
            this.audio.setSfxVolume(this.meta.settings.sfxVolume / 100 * 0.5);
            this.audio.startMusic();
            this.lastTime = performance.now();
            this.gameLoop();
        }
        
        selectMutators() {
            const available = this.meta.unlocks.mutators;
            const count = 2 + Math.floor(Math.random() * 2);
            const selected = [];
            const pool = [...available];
            
            for (let i = 0; i < Math.min(count, pool.length); i++) {
                const idx = Math.floor(Math.random() * pool.length);
                selected.push(pool.splice(idx, 1)[0]);
            }
            
            return selected;
        }
        
        updateMutatorUI() {
            const el = document.getElementById('mutators');
            el.innerHTML = this.activeMutators.map(m => 
                `<span class="mutator-tag" style="color:${MUTATORS[m].color}">${MUTATORS[m].icon} ${MUTATORS[m].name}</span>`
            ).join('');
        }
        
        updateUpgradeListUI() {
            const el = document.getElementById('upgradeList');
            const upgrades = Object.entries(this.upgrades);
            if (upgrades.length === 0) {
                el.innerHTML = '';
                return;
            }
            el.innerHTML = upgrades.slice(0, 5).map(([key, stacks]) => {
                const [trigger, effect] = key.split('_');
                return `<div>${TRIGGER_ICONS[trigger] || '‚Ä¢'} ‚Üí ${UPGRADE_ICONS[effect] || '‚Ä¢'} x${stacks}</div>`;
            }).join('');
        }
        
        gameLoop() {
            if (this.gameOver) return;
            
            const now = performance.now();
            let dt = (now - this.lastTime) / 1000;
            this.lastTime = now;
            
            dt = Math.min(dt, 0.1);
            
            if (!this.paused && !this.upgradeMenuOpen) {
                dt *= this.timeScale;
                this.update(dt);
            }
            
            this.render();
            requestAnimationFrame(() => this.gameLoop());
        }
        
        update(dt) {
            this.time += dt;
            this.player.streak += dt;
            this.player.streakTick = Math.floor(this.player.streak) % 5 === 0 && Math.floor(this.player.streak - dt) % 5 !== 0;
            
            const intensity = Math.min(1, this.time / 120 + this.enemies.length / 20);
            this.audio.setIntensity(intensity);
            
            this.player.nearMiss = false;
            this.player.perfectDodge = false;
            this.player.justKilled = false;
            this.player.wasMoving = this.player.moving;
            
            if (this.player.multiKillTimer > 0) {
                this.player.multiKillTimer -= dt;
                if (this.player.multiKillTimer <= 0) {
                    this.player.multiKill = 0;
                }
            }
            
            this.updatePlayer(dt);
            this.updateAutoAttack(dt);
            this.updateEnemies(dt);
            this.updateBullets(dt);
            this.updateHazards(dt);
            this.updateXPOrbs(dt);
            this.updateParticles(dt);
            this.updateVisualEffects(dt);
            this.checkCollisions();
            this.updateTriggers(dt);
            this.updateSpawning(dt);
            this.updateArena(dt);
            this.updateUI();
            
            if (this.meta.settings.screenShake) {
                this.screenEffects.shake *= 0.9;
            } else {
                this.screenEffects.shake = 0;
            }
            this.screenEffects.flash *= 0.85;
            this.screenEffects.distort *= 0.95;
            this.screenEffects.chromatic *= 0.9;
            
            if (this.rules.deathSlow) {
                let minDist = Infinity;
                this.enemyBullets.forEach(b => {
                    const d = Math.hypot(b.x - this.player.x, b.y - this.player.y);
                    minDist = Math.min(minDist, d);
                });
                if (minDist < 50) {
                    this.timeScale = 0.3 + (minDist / 50) * 0.7;
                } else {
                    this.timeScale = Math.min(1, this.timeScale + dt * 2);
                }
            }
        }
        
        updatePlayer(dt) {
            const p = this.player;
            
            if (this.touch.active) {
                const dx = this.touch.x - this.touch.startX;
                const dy = this.touch.y - this.touch.startY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist > 5) {
                    const speed = Math.min(dist / 30, 1) * CONFIG.PLAYER_SPEED;
                    p.vx += (dx / dist) * speed * dt * 60;
                    p.vy += (dy / dist) * speed * dt * 60;
                    p.moving = true;
                } else {
                    p.moving = false;
                }
            } else {
                p.moving = false;
            }
            
            p.vx *= CONFIG.PLAYER_FRICTION;
            p.vy *= CONFIG.PLAYER_FRICTION;
            
            p.x += p.vx;
            p.y += p.vy;
            
            const margin = this.arena.shrinkAmount;
            p.x = Math.max(p.size + margin, Math.min(CONFIG.CANVAS_WIDTH - p.size - margin, p.x));
            p.y = Math.max(p.size + margin, Math.min(CONFIG.CANVAS_HEIGHT - p.size - margin, p.y));
            
            p.nearWall = p.x < p.size + margin + 30 || p.x > CONFIG.CANVAS_WIDTH - p.size - margin - 30 ||
                         p.y < p.size + margin + 30 || p.y > CONFIG.CANVAS_HEIGHT - p.size - margin - 30;
            
            if (this.meta.settings.showTrail) {
                p.trail.unshift({ x: p.x, y: p.y });
                if (p.trail.length > 12) p.trail.pop();
            } else {
                p.trail = [];
            }
        }
        
        updateAutoAttack(dt) {
            this.autoAttackTimer += dt;
            const fireRate = 0.15;
            
            if (this.autoAttackTimer >= fireRate) {
                this.autoAttackTimer = 0;
                
                let nearest = null;
                let minDist = Infinity;
                this.enemies.forEach(e => {
                    if (e.dead || e.friendly) return;
                    const d = Math.hypot(e.x - this.player.x, e.y - this.player.y);
                    if (d < minDist) {
                        minDist = d;
                        nearest = e;
                    }
                });
                
                if (nearest) {
                    const angle = Math.atan2(nearest.y - this.player.y, nearest.x - this.player.x);
                    this.playerBullets.push({
                        x: this.player.x,
                        y: this.player.y,
                        vx: Math.cos(angle) * CONFIG.BULLET_SPEED,
                        vy: Math.sin(angle) * CONFIG.BULLET_SPEED,
                        size: 4,
                        damage: 1
                    });
                    this.audio.playSound('shoot');
                }
            }
        }
        
        updateEnemies(dt) {
            const speedMult = this.rules.speedDemon ? 1.5 : 1;
            
            this.enemies.forEach(e => {
                if (e.dead) return;
                
                e.moveTimer = (e.moveTimer || 0) + dt;
                
                if (e.dashing) {
                    e.x += Math.cos(e.dashAngle) * 15 * speedMult;
                    e.y += Math.sin(e.dashAngle) * 15 * speedMult;
                    e.dashTimer -= dt;
                    if (e.dashTimer <= 0) e.dashing = false;
                } else {
                    const moveDef = ENEMY_DNA.MOVEMENT[e.dna.movement];
                    if (moveDef && moveDef.fn && !e.friendly) {
                        moveDef.fn(e, this.player, dt);
                    } else if (e.friendly) {
                        let target = this.enemies.find(other => !other.dead && !other.friendly && other !== e);
                        if (target) {
                            const dx = target.x - e.x, dy = target.y - e.y;
                            const d = Math.sqrt(dx*dx + dy*dy) || 1;
                            e.vx = (dx/d) * e.speed * CONFIG.ENEMY_BASE_SPEED;
                            e.vy = (dy/d) * e.speed * CONFIG.ENEMY_BASE_SPEED;
                        }
                    }
                    
                    const actualSpeed = speedMult * (e.buffed ? 1.5 : 1);
                    e.x += (e.vx || 0) * actualSpeed;
                    e.y += (e.vy || 0) * actualSpeed;
                }
                
                const margin = this.arena.shrinkAmount;
                e.x = Math.max(e.size + margin, Math.min(CONFIG.CANVAS_WIDTH - e.size - margin, e.x));
                e.y = Math.max(e.size + margin, Math.min(CONFIG.CANVAS_HEIGHT - e.size - margin, e.y));
                
                const attackDef = ENEMY_DNA.ATTACK[e.dna.attack];
                if (attackDef && !e.friendly) {
                    e.attackTimer = (e.attackTimer || attackDef.cooldown) - dt;
                    const cooldownMult = this.rules.bulletHell ? 0.5 : 1;
                    if (e.attackTimer <= 0) {
                        const bullets = attackDef.fire(e, this.player, this);
                        bullets.forEach(b => this.enemyBullets.push(b));
                        e.attackTimer = attackDef.cooldown * cooldownMult;
                    }
                }
                
                const modDef = ENEMY_DNA.MODIFIER[e.dna.modifier];
                if (modDef && modDef.onUpdate) modDef.onUpdate(e, dt, this);
                
                if (this.rules.enemyTrails && !e.friendly) {
                    e.globalTrailTimer = (e.globalTrailTimer || 0) + dt;
                    if (e.globalTrailTimer > 0.3) {
                        this.hazards.push({
                            x: e.x, y: e.y,
                            size: 6,
                            color: '#0f04',
                            type: 'trail',
                            timer: 1.5
                        });
                        e.globalTrailTimer = 0;
                    }
                }
                
                if (e.laserActive) {
                    const laserLength = 400;
                    const px = this.player.x - e.x;
                    const py = this.player.y - e.y;
                    const lx = Math.cos(e.laserAngle);
                    const ly = Math.sin(e.laserAngle);
                    const dot = px * lx + py * ly;
                    if (dot > 0 && dot < laserLength) {
                        const perpDist = Math.abs(px * ly - py * lx);
                        if (perpDist < this.player.size + 5) {
                            this.playerDeath();
                        }
                    }
                }
                
                e.buffed = false;
            });
            
            this.enemies = this.enemies.filter(e => !e.dead);
        }
        
        updateBullets(dt) {
            const speedMult = this.rules.speedDemon ? 1.5 : 1;
            
            this.playerBullets.forEach(b => {
                b.x += b.vx * speedMult;
                b.y += b.vy * speedMult;
            });
            this.playerBullets = this.playerBullets.filter(b => 
                b.x > -10 && b.x < CONFIG.CANVAS_WIDTH + 10 &&
                b.y > -10 && b.y < CONFIG.CANVAS_HEIGHT + 10
            );
            
            this.enemyBullets.forEach(b => {
                if (b.homing) {
                    const dx = this.player.x - b.x;
                    const dy = this.player.y - b.y;
                    const d = Math.sqrt(dx*dx + dy*dy) || 1;
                    b.vx += (dx/d) * b.speed * 0.1;
                    b.vy += (dy/d) * b.speed * 0.1;
                    const currentSpeed = Math.sqrt(b.vx*b.vx + b.vy*b.vy);
                    if (currentSpeed > b.speed) {
                        b.vx = (b.vx / currentSpeed) * b.speed;
                        b.vy = (b.vy / currentSpeed) * b.speed;
                    }
                    b.life -= dt;
                }
                
                if (this.rules.gravityBullets) {
                    b.vy += 2 * dt;
                }
                
                b.x += b.vx * speedMult;
                b.y += b.vy * speedMult;
                
                if (this.rules.bouncyBullets && !b.bounced) {
                    const margin = this.arena.shrinkAmount;
                    if (b.x < margin || b.x > CONFIG.CANVAS_WIDTH - margin) {
                        b.vx *= -1;
                        b.bounced = true;
                    }
                    if (b.y < margin || b.y > CONFIG.CANVAS_HEIGHT - margin) {
                        b.vy *= -1;
                        b.bounced = true;
                    }
                }
            });
            
            this.enemyBullets = this.enemyBullets.filter(b => {
                if (b.homing && b.life <= 0) return false;
                const margin = this.arena.shrinkAmount - 20;
                return b.x > margin && b.x < CONFIG.CANVAS_WIDTH - margin &&
                       b.y > margin && b.y < CONFIG.CANVAS_HEIGHT - margin;
            });
        }
        
        updateHazards(dt) {
            this.hazards.forEach(h => {
                h.timer -= dt;
                
                if (h.type === 'mine' && h.timer <= 0 && !h.exploded) {
                    h.exploded = true;
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI * 2 / 8) * i;
                        this.enemyBullets.push({
                            x: h.x, y: h.y,
                            vx: Math.cos(angle) * 4,
                            vy: Math.sin(angle) * 4,
                            size: 5, color: '#f80'
                        });
                    }
                    this.screenEffects.shake = 5;
                }
            });
            
            this.hazards = this.hazards.filter(h => {
                if (h.type === 'mine') return h.timer > -0.5;
                return h.timer > 0;
            });
        }
        
        updateXPOrbs(dt) {
            const magnetRange = this.rules.magnetic ? 150 : 50;
            
            this.xpOrbs.forEach(orb => {
                const dx = this.player.x - orb.x;
                const dy = this.player.y - orb.y;
                const d = Math.sqrt(dx*dx + dy*dy);
                
                if (d < magnetRange) {
                    const speed = 5 + (1 - d/magnetRange) * 10;
                    orb.x += (dx/d) * speed;
                    orb.y += (dy/d) * speed;
                }
                
                if (d < this.player.size + orb.size) {
                    orb.collected = true;
                    this.xp += orb.value;
                    this.checkLevelUp();
                }
            });
            
            this.xpOrbs = this.xpOrbs.filter(o => !o.collected);
        }
        
        updateParticles(dt) {
            this.particles.forEach(p => p.update(dt));
            this.particles = this.particles.filter(p => p.life > 0);
        }
        
        updateVisualEffects(dt) {
            this.visualEffects.forEach(e => e.timer -= dt);
            this.visualEffects = this.visualEffects.filter(e => e.timer > 0);
        }
        
        checkCollisions() {
            const p = this.player;
            
            this.playerBullets.forEach(b => {
                this.enemies.forEach(e => {
                    if (e.dead || b.hit) return;
                    
                    if (e.dna.body.shield) {
                        const bulletAngle = Math.atan2(b.y - e.y, b.x - e.x);
                        const enemyFacing = Math.atan2(p.y - e.y, p.x - e.x);
                        const angleDiff = Math.abs(bulletAngle - enemyFacing);
                        if (angleDiff < Math.PI / 2) {
                            b.hit = true;
                            this.spawnHitEffect(b.x, b.y, '#88f');
                            return;
                        }
                    }
                    
                    const d = Math.hypot(b.x - e.x, b.y - e.y);
                    if (d < b.size + e.size) {
                        b.hit = true;
                        e.hp -= b.damage;
                        this.spawnHitEffect(b.x, b.y, e.dna.body.color);
                        
                        if (this.rules.echo) {
                            for (let i = 0; i < 2; i++) {
                                const angle = Math.random() * Math.PI * 2;
                                this.playerBullets.push({
                                    x: b.x, y: b.y,
                                    vx: Math.cos(angle) * CONFIG.BULLET_SPEED * 0.7,
                                    vy: Math.sin(angle) * CONFIG.BULLET_SPEED * 0.7,
                                    size: 3, damage: 1
                                });
                            }
                        }
                        
                        if (e.hp <= 0) {
                            this.killEnemy(e);
                        }
                    }
                });
            });
            this.playerBullets = this.playerBullets.filter(b => !b.hit);
            
            this.enemies.forEach(friendly => {
                if (!friendly.friendly || friendly.dead) return;
                this.enemies.forEach(e => {
                    if (e.friendly || e.dead || e === friendly) return;
                    const d = Math.hypot(friendly.x - e.x, friendly.y - e.y);
                    if (d < friendly.size + e.size) {
                        e.hp -= 1;
                        if (e.hp <= 0) this.killEnemy(e);
                    }
                });
            });
            
            this.enemyBullets.forEach(b => {
                const d = Math.hypot(b.x - p.x, b.y - p.y);
                
                if (d < CONFIG.NEAR_MISS_DISTANCE && d > p.size) {
                    p.nearMiss = true;
                    this.screenEffects.chromatic = 0.3;
                    this.audio.playSound('nearMiss');
                    this.score += Math.round(10 * this.scoreMult);
                }
                
                if (d < p.size + 5 && d > p.size) {
                    p.perfectDodge = true;
                    this.screenEffects.flash = 0.3;
                    this.score += Math.round(50 * this.scoreMult);
                }
                
                if (d < p.size + b.size) {
                    this.playerDeath();
                }
            });
            
            this.enemies.forEach(e => {
                if (e.dead || e.friendly) return;
                const d = Math.hypot(e.x - p.x, e.y - p.y);
                if (d < e.size + p.size) {
                    this.playerDeath();
                }
            });
            
            this.hazards.forEach(h => {
                if (h.type === 'mine' && h.timer > 0) return;
                const d = Math.hypot(h.x - p.x, h.y - p.y);
                if (d < h.size + p.size) {
                    this.playerDeath();
                }
            });
        }
        
        killEnemy(e) {
            e.dead = true;
            this.kills++;
            this.player.justKilled = true;
            this.player.multiKill++;
            this.player.multiKillTimer = 1;
            this.player.streak = 0;
            
            this.score += Math.round(e.dna.body.xp * this.scoreMult);
            this.audio.playSound('kill');
            
            this.xpOrbs.push({
                x: e.x, y: e.y,
                size: 6,
                value: e.dna.body.xp,
                color: '#0ff'
            });
            
            const particleTypes = ['circle', 'square', 'star'];
            for (let i = 0; i < 15; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 5;
                this.particles.push(new Particle(
                    e.x, e.y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    e.dna.body.color,
                    3 + Math.random() * 4,
                    0.5 + Math.random() * 0.5,
                    particleTypes[Math.floor(Math.random() * particleTypes.length)]
                ));
            }
            
            const modDef = ENEMY_DNA.MODIFIER[e.dna.modifier];
            if (modDef && modDef.onDeath) modDef.onDeath(e, this);
            
            if (e.dna.body.splits) {
                for (let i = 0; i < 2; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    this.spawnEnemy(e.x + Math.cos(angle) * 20, e.y + Math.sin(angle) * 20, 'SMALL');
                }
            }
            
            if (this.rules.eliteHunters && this.player.multiKill >= 5) {
                this.spawnElite();
                this.player.multiKill = 0;
            }
        }
        
        updateTriggers(dt) {
            Object.keys(this.upgradeCooldowns).forEach(key => {
                if (this.upgradeCooldowns[key] > 0) {
                    this.upgradeCooldowns[key] -= dt;
                }
            });
            
            Object.keys(this.upgrades).forEach(upgradeKey => {
                const [trigger, effect] = upgradeKey.split('_');
                const triggerDef = UPGRADE_TRIGGERS[trigger];
                const effectDef = UPGRADE_EFFECTS[effect];
                
                if (!triggerDef || !effectDef) return;
                
                const cooldownKey = upgradeKey;
                if ((this.upgradeCooldowns[cooldownKey] || 0) <= 0 && triggerDef.check(this)) {
                    effectDef.apply(this, this.upgrades[upgradeKey]);
                    this.upgradeCooldowns[cooldownKey] = triggerDef.cooldown;
                }
            });
        }
        
        checkLevelUp() {
            const xpNeeded = CONFIG.XP_TO_LEVEL * Math.pow(CONFIG.XP_SCALE, this.level - 1);
            if (this.xp >= xpNeeded) {
                this.xp -= xpNeeded;
                this.level++;
                this.audio.playSound('levelUp');
                this.showUpgradeMenu();
            }
        }
        
        showUpgradeMenu() {
            this.upgradeMenuOpen = true;
            this.timeScale = 0.1;
            
            const menu = document.getElementById('upgradeMenu');
            const options = document.getElementById('upgradeOptions');
            options.innerHTML = '';
            
            const available = [];
            this.meta.unlocks.triggers.forEach(t => {
                this.meta.unlocks.effects.forEach(e => {
                    available.push({ trigger: t, effect: e });
                });
            });
            
            for (let i = available.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [available[i], available[j]] = [available[j], available[i]];
            }
            
            const choices = available.slice(0, 3);
            
            choices.forEach(choice => {
                const div = document.createElement('div');
                div.className = 'upgrade-option';
                const triggerDef = UPGRADE_TRIGGERS[choice.trigger];
                const effectDef = UPGRADE_EFFECTS[choice.effect];
                const key = `${choice.trigger}_${choice.effect}`;
                const stacks = this.upgrades[key] || 0;
                
                div.innerHTML = `
                    <div class="upgrade-icon">${TRIGGER_ICONS[choice.trigger] || '‚ö°'} ${UPGRADE_ICONS[choice.effect] || '‚ú®'}</div>
                    <div class="upgrade-info">
                        <h3>${triggerDef.name} ‚Üí ${effectDef.name}</h3>
                        <p>${effectDef.desc}</p>
                        <div class="upgrade-stack">Stack: ${stacks + 1}</div>
                    </div>
                `;
                
                div.onclick = () => {
                    this.upgrades[key] = (this.upgrades[key] || 0) + 1;
                    this.closeUpgradeMenu();
                    this.audio.playSound('select');
                    this.updateUpgradeListUI();
                };
                
                options.appendChild(div);
            });
            
            menu.style.display = 'flex';
        }
        
        closeUpgradeMenu() {
            document.getElementById('upgradeMenu').style.display = 'none';
            this.upgradeMenuOpen = false;
            this.timeScale = 1;
        }
        
        updateSpawning(dt) {
            this.spawnTimer += dt * 1000;
            
            this.spawnRate = Math.max(
                CONFIG.SPAWN_RATE_MIN,
                CONFIG.SPAWN_RATE_INITIAL - this.time * 10
            );
            
            if (this.rules.chaosSpawn) {
                if (this.spawnTimer >= this.spawnRate * 3) {
                    this.spawnTimer = 0;
                    const waveSize = 3 + Math.floor(this.time / 30);
                    for (let i = 0; i < waveSize; i++) {
                        setTimeout(() => this.spawnRandomEnemy(), i * 100);
                    }
                }
            } else {
                if (this.spawnTimer >= this.spawnRate) {
                    this.spawnTimer = 0;
                    this.spawnRandomEnemy();
                }
            }
        }
        
        spawnRandomEnemy() {
            let x, y;
            const margin = this.arena.shrinkAmount + 20;
            const side = Math.floor(Math.random() * 4);
            
            switch(side) {
                case 0: x = margin; y = margin + Math.random() * (CONFIG.CANVAS_HEIGHT - margin * 2); break;
                case 1: x = CONFIG.CANVAS_WIDTH - margin; y = margin + Math.random() * (CONFIG.CANVAS_HEIGHT - margin * 2); break;
                case 2: x = margin + Math.random() * (CONFIG.CANVAS_WIDTH - margin * 2); y = margin; break;
                case 3: x = margin + Math.random() * (CONFIG.CANVAS_WIDTH - margin * 2); y = CONFIG.CANVAS_HEIGHT - margin; break;
            }
            
            this.spawnEnemy(x, y);
        }
        
        spawnEnemy(x, y, forceBody = null) {
            const u = this.meta.unlocks;
            
            const bodyType = forceBody || u.bodies[Math.floor(Math.random() * u.bodies.length)];
            const movement = u.movements[Math.floor(Math.random() * u.movements.length)];
            
            const complexity = Math.min(3, 1 + Math.floor(this.time / 45));
            const hasAttack = complexity >= 2 || Math.random() < 0.3;
            const hasModifier = complexity >= 3 || Math.random() < 0.2;
            
            const attack = hasAttack ? u.attacks[Math.floor(Math.random() * u.attacks.length)] : 'NONE';
            const modifier = hasModifier ? u.modifiers[Math.floor(Math.random() * u.modifiers.length)] : 'NONE';
            
            const body = ENEMY_DNA.BODY[bodyType];
            
            const enemy = {
                x, y,
                vx: 0, vy: 0,
                size: body.size,
                hp: body.hp,
                speed: body.speed,
                dna: {
                    body: { ...body, type: bodyType },
                    movement,
                    attack,
                    modifier
                },
                dead: false,
                moveTimer: Math.random() * 2
            };
            
            const modDef = ENEMY_DNA.MODIFIER[modifier];
            if (modDef && modDef.onSpawn) modDef.onSpawn(enemy);
            
            this.enemies.push(enemy);
        }
        
        spawnElite() {
            const margin = this.arena.shrinkAmount + 30;
            const angle = Math.random() * Math.PI * 2;
            const dist = 150;
            let x = this.player.x + Math.cos(angle) * dist;
            let y = this.player.y + Math.sin(angle) * dist;
            x = Math.max(margin, Math.min(CONFIG.CANVAS_WIDTH - margin, x));
            y = Math.max(margin, Math.min(CONFIG.CANVAS_HEIGHT - margin, y));
            
            const enemy = {
                x, y,
                vx: 0, vy: 0,
                size: 25,
                hp: 8,
                speed: 1.2,
                elite: true,
                dna: {
                    body: { ...ENEMY_DNA.BODY.TANK, color: '#f00', xp: 100, type: 'ELITE' },
                    movement: 'CHARGE',
                    attack: 'BURST',
                    modifier: 'EXPLODE'
                },
                dead: false,
                moveTimer: 0
            };
            
            this.enemies.push(enemy);
            this.audio.playSound('elite');
            this.screenEffects.shake = 10;
        }
        
        updateArena(dt) {
            if (this.rules.shrinkingArena) {
                this.arena.shrinkAmount += dt * 2;
                this.arena.shrinkAmount = Math.min(this.arena.shrinkAmount, 100);
            }
            
            if (this.rules.rotatingScreen) {
                this.arena.rotation += dt * 0.1;
            }
        }
        
        spawnHitEffect(x, y, color) {
            for (let i = 0; i < 8; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 4;
                this.particles.push(new Particle(
                    x, y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    color,
                    2 + Math.random() * 3,
                    0.3 + Math.random() * 0.2,
                    Math.random() > 0.5 ? 'square' : 'circle'
                ));
            }
        }
        
        playerDeath() {
            if (this.gameOver) return;
            this.gameOver = true;
            
            this.audio.playSound('death');
            this.audio.stopMusic();
            
            for (let i = 0; i < 40; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 3 + Math.random() * 10;
                this.particles.push(new Particle(
                    this.player.x, this.player.y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    ['#0ff', '#f0f', '#ff0', '#f00', '#fff'][Math.floor(Math.random() * 5)],
                    4 + Math.random() * 8,
                    0.8 + Math.random() * 0.6,
                    ['circle', 'square', 'star'][Math.floor(Math.random() * 3)]
                ));
            }
            
            this.screenEffects.shake = 25;
            this.screenEffects.flash = 1;
            
            this.meta.totalRuns++;
            this.meta.totalKills += this.kills;
            if (this.score > this.meta.bestScore) this.meta.bestScore = this.score;
            if (this.time > this.meta.bestTime) this.meta.bestTime = this.time;
            if (this.level > this.meta.bestLevel) this.meta.bestLevel = this.level;
            
            const newUnlocks = META.checkUnlocks(this.meta, this.score, this.time, this.kills, this.level);
            META.save(this.meta);
            
            setTimeout(() => {
                document.getElementById('finalScore').textContent = this.score.toLocaleString();
                document.getElementById('finalTime').textContent = this.formatTime(this.time);
                document.getElementById('finalLevel').textContent = this.level;
                
                const unlockContainer = document.getElementById('newUnlocksContainer');
                const unlocksList = document.getElementById('newUnlocksList');
                if (newUnlocks.length > 0) {
                    unlockContainer.style.display = 'block';
                    unlocksList.innerHTML = newUnlocks.join(' ‚Ä¢ ');
                } else {
                    unlockContainer.style.display = 'none';
                }
                
                const progressPreview = document.getElementById('progressPreview');
                const nextUnlock = META.getNextUnlock(this.meta);
                if (nextUnlock && newUnlocks.length === 0) {
                    progressPreview.style.display = 'block';
                    document.getElementById('nextUnlockName').textContent = nextUnlock.name;
                    document.getElementById('nextUnlockProgress').style.width = (nextUnlock.progress * 100) + '%';
                } else {
                    progressPreview.style.display = 'none';
                }
                
                this.showScreen('deathScreen');
            }, 600);
        }
        
        updateUI() {
            document.getElementById('score').textContent = this.score.toLocaleString();
            document.getElementById('level').textContent = 'LV ' + this.level;
            document.getElementById('time').textContent = this.formatTime(this.time);
        }
        
        formatTime(t) {
            const mins = Math.floor(t / 60);
            const secs = Math.floor(t % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        render() {
            const ctx = this.ctx;
            
            ctx.save();
            if (this.arena.rotation) {
                ctx.translate(CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT / 2);
                ctx.rotate(this.arena.rotation);
                ctx.translate(-CONFIG.CANVAS_WIDTH / 2, -CONFIG.CANVAS_HEIGHT / 2);
            }
            
            if (this.screenEffects.shake > 0.5 && this.meta.settings.screenShake) {
                ctx.translate(
                    (Math.random() - 0.5) * this.screenEffects.shake,
                    (Math.random() - 0.5) * this.screenEffects.shake
                );
            }
            
            // Background
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
            
            const margin = this.arena.shrinkAmount;
            
            // Arena border with glow
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.strokeRect(margin, margin, CONFIG.CANVAS_WIDTH - margin * 2, CONFIG.CANVAS_HEIGHT - margin * 2);
            
            if (margin > 0) {
                const gradient = ctx.createLinearGradient(0, 0, margin * 2, 0);
                gradient.addColorStop(0, 'rgba(255, 0, 64, 0.3)');
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = 'rgba(255, 0, 64, 0.1)';
                ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, margin);
                ctx.fillRect(0, CONFIG.CANVAS_HEIGHT - margin, CONFIG.CANVAS_WIDTH, margin);
                ctx.fillRect(0, margin, margin, CONFIG.CANVAS_HEIGHT - margin * 2);
                ctx.fillRect(CONFIG.CANVAS_WIDTH - margin, margin, margin, CONFIG.CANVAS_HEIGHT - margin * 2);
            }
            
            // Grid
            ctx.strokeStyle = '#1a1a2e';
            ctx.lineWidth = 1;
            const gridSize = 40;
            for (let x = margin; x < CONFIG.CANVAS_WIDTH - margin; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, margin);
                ctx.lineTo(x, CONFIG.CANVAS_HEIGHT - margin);
                ctx.stroke();
            }
            for (let y = margin; y < CONFIG.CANVAS_HEIGHT - margin; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(margin, y);
                ctx.lineTo(CONFIG.CANVAS_WIDTH - margin, y);
                ctx.stroke();
            }
            
            // Hazards
            this.hazards.forEach(h => {
                ctx.fillStyle = h.color;
                ctx.beginPath();
                ctx.arc(h.x, h.y, h.size, 0, Math.PI * 2);
                ctx.fill();
                
                if (h.type === 'mine' && h.timer > 0) {
                    const pulse = 1 + Math.sin(h.timer * 10) * 0.3;
                    ctx.strokeStyle = '#f80';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(h.x, h.y, h.size * pulse, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });
            
            // XP Orbs
            this.xpOrbs.forEach(orb => {
                ctx.shadowColor = orb.color;
                ctx.shadowBlur = 10;
                ctx.fillStyle = orb.color;
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, orb.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, orb.size * 0.4, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            });
            
            // Enemies
            this.enemies.forEach(e => {
                if (e.dead) return;
                this.renderEnemy(ctx, e);
            });
            
            // Enemy bullets
            this.enemyBullets.forEach(b => {
                ctx.fillStyle = b.color || '#f00';
                ctx.shadowColor = b.color || '#f00';
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
                ctx.fill();
                
                if (b.homing) {
                    ctx.strokeStyle = '#f0f';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.size + 3, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });
            ctx.shadowBlur = 0;
            
            // Player bullets
            ctx.fillStyle = this.player.skin.color;
            ctx.shadowColor = this.player.skin.color;
            ctx.shadowBlur = 6;
            this.playerBullets.forEach(b => {
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.shadowBlur = 0;
            
            // Player trail
            if (this.player && this.player.trail && this.meta.settings.showTrail) {
                this.player.trail.forEach((pos, i) => {
                    const alpha = 1 - i / this.player.trail.length;
                    ctx.fillStyle = this.player.skin.trailColor.replace('0.3', (alpha * 0.3).toString());
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, this.player.size * (1 - i / this.player.trail.length * 0.5), 0, Math.PI * 2);
                    ctx.fill();
                });
            }
            
            // Player
            if (this.player && !this.gameOver) {
                this.renderPlayer(ctx);
            }
            
            // Particles
            this.particles.forEach(p => p.draw(ctx));
            
            // Visual effects
            if (this.meta.settings.visualEffects) {
                this.visualEffects.forEach(e => {
                    const alpha = e.timer / 0.3;
                    
                    if (e.type === 'shockwave' || e.type === 'burst' || e.type === 'shield') {
                        ctx.strokeStyle = e.color || '#0ff';
                        ctx.lineWidth = 3;
                        ctx.globalAlpha = alpha;
                        ctx.beginPath();
                        ctx.arc(e.x, e.y, e.radius * (1 - alpha * 0.5), 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    } else if (e.type === 'lightning') {
                        ctx.strokeStyle = '#0ff';
                        ctx.lineWidth = 3;
                        ctx.globalAlpha = alpha;
                        ctx.beginPath();
                        ctx.moveTo(e.x1, e.y1);
                        const steps = 5;
                        for (let i = 1; i <= steps; i++) {
                            const t = i / steps;
                            const x = e.x1 + (e.x2 - e.x1) * t + (Math.random() - 0.5) * 20;
                            const y = e.y1 + (e.y2 - e.y1) * t + (Math.random() - 0.5) * 20;
                            ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    } else if (e.type === 'convert') {
                        ctx.fillStyle = '#0ff';
                        ctx.globalAlpha = alpha * 0.5;
                        ctx.beginPath();
                        ctx.arc(e.x, e.y, 30 * (1 - alpha), 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    }
                });
            }
            
            // Screen flash
            if (this.screenEffects.flash > 0.1) {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.screenEffects.flash * 0.5})`;
                ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
            }
            
            // Chromatic aberration
            if (this.screenEffects.chromatic > 0.1 && this.meta.settings.visualEffects) {
                ctx.fillStyle = `rgba(255, 0, 0, ${this.screenEffects.chromatic * 0.08})`;
                ctx.fillRect(-3, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
                ctx.fillStyle = `rgba(0, 0, 255, ${this.screenEffects.chromatic * 0.08})`;
                ctx.fillRect(3, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
            }
            
            // XP bar
            const xpNeeded = CONFIG.XP_TO_LEVEL * Math.pow(CONFIG.XP_SCALE, this.level - 1);
            const xpPercent = this.xp / xpNeeded;
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(10, CONFIG.CANVAS_HEIGHT - 25, CONFIG.CANVAS_WIDTH - 20, 15);
            ctx.fillStyle = '#333';
            ctx.fillRect(12, CONFIG.CANVAS_HEIGHT - 23, CONFIG.CANVAS_WIDTH - 24, 11);
            
            const gradient = ctx.createLinearGradient(12, 0, CONFIG.CANVAS_WIDTH - 12, 0);
            gradient.addColorStop(0, '#0ff');
            gradient.addColorStop(1, '#f0f');
            ctx.fillStyle = gradient;
            ctx.fillRect(12, CONFIG.CANVAS_HEIGHT - 23, (CONFIG.CANVAS_WIDTH - 24) * xpPercent, 11);
            
            // Score multiplier
            if (this.scoreMult > 1) {
                ctx.fillStyle = '#ff0';
                ctx.font = 'bold 14px Orbitron, monospace';
                ctx.fillText(`x${this.scoreMult.toFixed(1)}`, CONFIG.CANVAS_WIDTH - 50, 55);
            }
            
            ctx.restore();
        }
        
        renderPlayer(ctx) {
            const p = this.player;
            const skin = p.skin;
            
            ctx.shadowColor = skin.glowColor;
            ctx.shadowBlur = 20;
            
            ctx.fillStyle = skin.color;
            ctx.beginPath();
            
            switch(skin.shape) {
                case 'diamond':
                    ctx.moveTo(p.x, p.y - p.size);
                    ctx.lineTo(p.x + p.size, p.y);
                    ctx.lineTo(p.x, p.y + p.size);
                    ctx.lineTo(p.x - p.size, p.y);
                    break;
                case 'circle':
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    break;
                case 'triangle':
                    const angle = Math.atan2(p.vy || 0.01, p.vx || 0.01);
                    ctx.moveTo(p.x + Math.cos(angle) * p.size, p.y + Math.sin(angle) * p.size);
                    ctx.lineTo(p.x + Math.cos(angle + 2.4) * p.size, p.y + Math.sin(angle + 2.4) * p.size);
                    ctx.lineTo(p.x + Math.cos(angle - 2.4) * p.size, p.y + Math.sin(angle - 2.4) * p.size);
                    break;
                case 'hexagon':
                    for (let i = 0; i < 6; i++) {
                        const a = (Math.PI / 3) * i - Math.PI / 2;
                        const px = p.x + Math.cos(a) * p.size;
                        const py = p.y + Math.sin(a) * p.size;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    break;
                case 'star':
                    for (let i = 0; i < 10; i++) {
                        const a = (Math.PI / 5) * i - Math.PI / 2;
                        const r = i % 2 === 0 ? p.size : p.size * 0.5;
                        const px = p.x + Math.cos(a) * r;
                        const py = p.y + Math.sin(a) * r;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    break;
                case 'pentagon':
                    for (let i = 0; i < 5; i++) {
                        const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
                        const px = p.x + Math.cos(a) * p.size;
                        const py = p.y + Math.sin(a) * p.size;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    break;
                case 'cross':
                    const s = p.size * 0.4;
                    ctx.moveTo(p.x - s, p.y - p.size);
                    ctx.lineTo(p.x + s, p.y - p.size);
                    ctx.lineTo(p.x + s, p.y - s);
                    ctx.lineTo(p.x + p.size, p.y - s);
                    ctx.lineTo(p.x + p.size, p.y + s);
                    ctx.lineTo(p.x + s, p.y + s);
                    ctx.lineTo(p.x + s, p.y + p.size);
                    ctx.lineTo(p.x - s, p.y + p.size);
                    ctx.lineTo(p.x - s, p.y + s);
                    ctx.lineTo(p.x - p.size, p.y + s);
                    ctx.lineTo(p.x - p.size, p.y - s);
                    ctx.lineTo(p.x - s, p.y - s);
                    break;
                case 'ghost':
                    ctx.arc(p.x, p.y - p.size * 0.3, p.size * 0.8, Math.PI, 0);
                    ctx.lineTo(p.x + p.size * 0.8, p.y + p.size);
                    ctx.lineTo(p.x + p.size * 0.4, p.y + p.size * 0.6);
                    ctx.lineTo(p.x, p.y + p.size);
                    ctx.lineTo(p.x - p.size * 0.4, p.y + p.size * 0.6);
                    ctx.lineTo(p.x - p.size * 0.8, p.y + p.size);
                    break;
                case 'blade':
                    ctx.moveTo(p.x, p.y - p.size * 1.2);
                    ctx.lineTo(p.x + p.size * 0.4, p.y - p.size * 0.2);
                    ctx.lineTo(p.x + p.size * 1.2, p.y);
                    ctx.lineTo(p.x + p.size * 0.4, p.y + p.size * 0.2);
                    ctx.lineTo(p.x, p.y + p.size * 1.2);
                    ctx.lineTo(p.x - p.size * 0.4, p.y + p.size * 0.2);
                    ctx.lineTo(p.x - p.size * 1.2, p.y);
                    ctx.lineTo(p.x - p.size * 0.4, p.y - p.size * 0.2);
                    break;
                case 'chaos':
                    const time = Date.now() / 200;
                    for (let i = 0; i < 8; i++) {
                        const a = (Math.PI / 4) * i + time;
                        const r = p.size * (0.7 + Math.sin(time * 2 + i) * 0.3);
                        const px = p.x + Math.cos(a) * r;
                        const py = p.y + Math.sin(a) * r;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    break;
                default:
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            }
            ctx.closePath();
            ctx.fill();
            
            // Core
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * 0.25, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowBlur = 0;
            
            // Hitbox indicator
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        renderEnemy(ctx, e) {
            ctx.fillStyle = e.dna.body.color;
            
            const bodyType = e.dna.body.type;
            ctx.beginPath();
            
            if (bodyType === 'SMALL' || bodyType === 'SWARM') {
                const angle = Math.atan2(this.player.y - e.y, this.player.x - e.x);
                ctx.moveTo(e.x + Math.cos(angle) * e.size, e.y + Math.sin(angle) * e.size);
                ctx.lineTo(e.x + Math.cos(angle + 2.4) * e.size, e.y + Math.sin(angle + 2.4) * e.size);
                ctx.lineTo(e.x + Math.cos(angle - 2.4) * e.size, e.y + Math.sin(angle - 2.4) * e.size);
                ctx.closePath();
            } else if (bodyType === 'TANK' || bodyType === 'ELITE') {
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i;
                    const px = e.x + Math.cos(angle) * e.size;
                    const py = e.y + Math.sin(angle) * e.size;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
            } else if (bodyType === 'SPLITTER') {
                ctx.moveTo(e.x, e.y - e.size);
                ctx.lineTo(e.x + e.size, e.y);
                ctx.lineTo(e.x, e.y + e.size);
                ctx.lineTo(e.x - e.size, e.y);
                ctx.closePath();
            } else if (bodyType === 'SHIELDED') {
                for (let i = 0; i < 5; i++) {
                    const angle = (Math.PI * 2 / 5) * i - Math.PI / 2;
                    const px = e.x + Math.cos(angle) * e.size;
                    const py = e.y + Math.sin(angle) * e.size;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
            } else {
                ctx.arc(e.x, e.y, e.size, 0, Math.PI * 2);
            }
            
            ctx.fill();
            
            // Shield visual
            if (e.dna.body.shield) {
                const shieldAngle = Math.atan2(this.player.y - e.y, this.player.x - e.x);
                ctx.strokeStyle = '#88f';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.size + 5, shieldAngle - 0.8, shieldAngle + 0.8);
                ctx.stroke();
            }
            
            // Buffed indicator
            if (e.buffed) {
                ctx.strokeStyle = '#f0f';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.size + 8, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Elite glow
            if (e.elite) {
                ctx.shadowColor = '#f00';
                ctx.shadowBlur = 20;
                ctx.strokeStyle = '#f00';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.size + 3, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
            
            // Friendly indicator
            if (e.friendly) {
                ctx.strokeStyle = '#0ff';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.size + 5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Charge warning
            if (e.chargeState === 'tracking' && e.chargeTimer > 1) {
                ctx.strokeStyle = '#ff0';
                ctx.lineWidth = 2;
                const progress = (e.chargeTimer - 1) / 0.5;
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.size + 10, -Math.PI/2, -Math.PI/2 + Math.PI * 2 * progress);
                ctx.stroke();
            }
            
            // Laser
            if (e.laserWarning || e.laserActive) {
                const color = e.laserActive ? '#f00' : '#f008';
                const width = e.laserActive ? 10 : 3;
                ctx.strokeStyle = color;
                ctx.lineWidth = width;
                if (e.laserActive) {
                    ctx.shadowColor = '#f00';
                    ctx.shadowBlur = 15;
                }
                ctx.beginPath();
                ctx.moveTo(e.x, e.y);
                ctx.lineTo(
                    e.x + Math.cos(e.laserAngle) * 400,
                    e.y + Math.sin(e.laserAngle) * 400
                );
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
            
            // Teleport flash
            if (e.justTeleported) {
                ctx.fillStyle = '#fff';
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.size * 1.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                e.justTeleported = false;
            }
        }
    }
    
    // Initialize game
    let game;
    window.addEventListener('load', () => {
        game = new Game();
        window.game = game;
    });
})();
</script>
</body>
</html>
