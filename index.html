<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>1HP: CHAOS MODE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;500;600;700&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --primary: #00ffff;
            --secondary: #ff00ff;
            --accent: #ffff00;
            --danger: #ff0040;
            --success: #00ff88;
            --legendary: #ff8800;
            --mythic: #ff00aa;
            --epic: #aa00ff;
            --rare: #0088ff;
            --bg-dark: #0a0a0f;
            --bg-card: rgba(20, 20, 35, 0.95);
            --text: #ffffff;
            --text-dim: #888899;
        }
        
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background: var(--bg-dark);
            font-family: 'Rajdhani', sans-serif;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            color: var(--text);
        }
        
        #gameCanvas {
            display: block;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
        }
        
        #ui {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .ui-element {
            position: absolute;
            text-shadow: 0 0 10px currentColor;
        }
        
        #score { top: 15px; left: 15px; font-family: 'Orbitron', monospace; font-size: 28px; font-weight: 700; color: var(--primary); }
        #level { top: 15px; right: 15px; font-family: 'Orbitron', monospace; font-size: 18px; font-weight: 600; color: var(--secondary); background: rgba(255,0,255,0.1); padding: 5px 12px; border-radius: 20px; border: 1px solid var(--secondary); }
        #time { top: 50px; left: 15px; font-size: 16px; color: var(--accent); font-weight: 500; }
        #comboDisplay { top: 75px; left: 15px; font-family: 'Orbitron', monospace; font-size: 20px; color: var(--legendary); font-weight: 700; display: none; }
        #mutators { bottom: 15px; left: 15px; font-size: 13px; color: var(--success); max-width: 60%; display: flex; flex-wrap: wrap; gap: 8px; }
        .mutator-tag { background: rgba(0,255,136,0.15); border: 1px solid currentColor; padding: 3px 10px; border-radius: 12px; font-weight: 500; }
        #upgradeList { top: 100px; left: 15px; font-size: 11px; color: var(--primary); opacity: 0.7; max-width: 150px; }
        #accountLevel { top: 50px; right: 15px; font-family: 'Orbitron', monospace; font-size: 12px; color: var(--accent); }
        
        .screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: var(--bg-dark);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            pointer-events: auto;
            overflow-y: auto;
            padding: 20px;
        }
        
        .screen.active { display: flex; }
        
        .animated-bg {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            overflow: hidden;
            pointer-events: none;
        }
        
        .animated-bg::before {
            content: '';
            position: absolute;
            top: -50%; left: -50%;
            width: 200%; height: 200%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(0,255,255,0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255,0,255,0.03) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(255,255,0,0.02) 0%, transparent 50%);
            animation: bgRotate 60s linear infinite;
        }
        
        @keyframes bgRotate { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        
        .grid-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-image: 
                linear-gradient(rgba(0,255,255,0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0,255,255,0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: gridMove 20s linear infinite;
        }
        
        @keyframes gridMove { from { transform: translateY(0); } to { transform: translateY(50px); } }
        
        .title-container { text-align: center; margin-bottom: 20px; }
        
        .game-title {
            font-family: 'Orbitron', monospace;
            font-size: 72px;
            font-weight: 900;
            color: var(--secondary);
            text-shadow: 0 0 20px var(--secondary), 0 0 40px var(--secondary), 0 0 80px rgba(255,0,255,0.5);
            animation: titlePulse 2s ease-in-out infinite;
            letter-spacing: 8px;
        }
        
        @keyframes titlePulse {
            0%, 100% { text-shadow: 0 0 20px var(--secondary), 0 0 40px var(--secondary), 0 0 80px rgba(255,0,255,0.5); transform: scale(1); }
            50% { text-shadow: 0 0 30px var(--secondary), 0 0 60px var(--secondary), 0 0 100px rgba(255,0,255,0.7); transform: scale(1.02); }
        }
        
        .subtitle { font-family: 'Orbitron', monospace; font-size: 24px; font-weight: 400; color: var(--primary); text-shadow: 0 0 15px var(--primary); letter-spacing: 12px; margin-top: 5px; animation: subtitleGlow 3s ease-in-out infinite alternate; }
        @keyframes subtitleGlow { from { opacity: 0.7; } to { opacity: 1; } }
        .tagline { color: var(--text-dim); font-size: 16px; margin-top: 15px; font-weight: 400; }
        
        .btn {
            font-family: 'Orbitron', monospace;
            background: transparent;
            border: 2px solid var(--primary);
            color: var(--primary);
            padding: 15px 40px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            border-radius: 8px;
            margin: 8px;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0,255,255,0.2), transparent);
            transition: left 0.5s ease;
        }
        
        .btn:hover::before, .btn:active::before { left: 100%; }
        .btn:hover, .btn:active { background: rgba(0,255,255,0.15); box-shadow: 0 0 20px rgba(0,255,255,0.3), inset 0 0 20px rgba(0,255,255,0.1); transform: translateY(-2px); }
        .btn-primary { background: linear-gradient(135deg, var(--secondary), var(--primary)); border: none; color: #000; font-size: 20px; padding: 18px 60px; }
        .btn-primary:hover { box-shadow: 0 0 30px rgba(255,0,255,0.5), 0 0 60px rgba(0,255,255,0.3); transform: translateY(-3px) scale(1.02); }
        .btn-small { padding: 10px 25px; font-size: 13px; }
        .btn-back { position: absolute; top: 20px; left: 20px; padding: 10px 20px; font-size: 14px; }
        .btn-danger { border-color: var(--danger); color: var(--danger); }
        .btn-danger:hover { background: rgba(255,0,64,0.2); box-shadow: 0 0 20px rgba(255,0,64,0.3); }
        
        .menu-buttons { display: flex; flex-direction: column; gap: 10px; margin-top: 30px; }
        .menu-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-top: 20px; }
        .menu-grid .btn { padding: 12px 20px; font-size: 12px; }
        
        .best-score { margin-top: 30px; text-align: center; }
        .best-score-label { color: var(--text-dim); font-size: 12px; text-transform: uppercase; letter-spacing: 2px; }
        .best-score-value { font-family: 'Orbitron', monospace; font-size: 32px; color: var(--accent); text-shadow: 0 0 20px var(--accent); }
        
        .account-info { margin-top: 15px; text-align: center; padding: 10px 20px; background: var(--bg-card); border-radius: 10px; border: 1px solid rgba(255,255,255,0.1); }
        .account-level { font-family: 'Orbitron', monospace; font-size: 14px; color: var(--accent); }
        .account-xp-bar { height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; margin-top: 5px; overflow: hidden; }
        .account-xp-fill { height: 100%; background: linear-gradient(90deg, var(--accent), var(--legendary)); border-radius: 3px; transition: width 0.3s; }
        
        #progressionScreen, #characterScreen, #achievementsScreen, #challengesScreen, #codexScreen, #modesScreen { justify-content: flex-start; padding-top: 60px; }
        
        .progression-header { text-align: center; margin-bottom: 20px; }
        .progression-header h2 { font-family: 'Orbitron', monospace; font-size: 28px; color: var(--primary); text-shadow: 0 0 20px var(--primary); }
        
        .stats-dashboard { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; width: 100%; max-width: 600px; margin-bottom: 20px; }
        .stat-card { background: var(--bg-card); border: 1px solid rgba(0,255,255,0.2); border-radius: 10px; padding: 12px; text-align: center; transition: all 0.3s ease; }
        .stat-card:hover { border-color: var(--primary); box-shadow: 0 0 15px rgba(0,255,255,0.2); }
        .stat-value { font-family: 'Orbitron', monospace; font-size: 20px; color: var(--primary); font-weight: 700; }
        .stat-label { font-size: 10px; color: var(--text-dim); text-transform: uppercase; letter-spacing: 1px; margin-top: 3px; }
        
        .completion-bar { width: 100%; max-width: 600px; margin-bottom: 20px; }
        .completion-bar-header { display: flex; justify-content: space-between; margin-bottom: 8px; }
        .completion-bar-label { color: var(--text-dim); font-size: 14px; }
        .completion-bar-percent { font-family: 'Orbitron', monospace; color: var(--success); font-weight: 600; }
        .completion-bar-track { height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden; }
        .completion-bar-fill { height: 100%; background: linear-gradient(90deg, var(--success), var(--primary)); border-radius: 4px; transition: width 0.5s ease; }
        
        .unlock-tabs { display: flex; gap: 8px; margin-bottom: 15px; flex-wrap: wrap; justify-content: center; }
        .unlock-tab { background: transparent; border: 1px solid var(--text-dim); color: var(--text-dim); padding: 6px 14px; font-size: 11px; cursor: pointer; border-radius: 15px; transition: all 0.3s ease; font-family: 'Rajdhani', sans-serif; font-weight: 600; }
        .unlock-tab.active, .unlock-tab:hover { border-color: var(--primary); color: var(--primary); background: rgba(0,255,255,0.1); }
        
        .unlock-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px; width: 100%; max-width: 650px; max-height: 280px; overflow-y: auto; padding: 10px; }
        .unlock-card { background: var(--bg-card); border: 1px solid rgba(255,255,255,0.1); border-radius: 10px; padding: 10px; text-align: center; transition: all 0.3s ease; position: relative; overflow: hidden; }
        .unlock-card.unlocked { border-color: rgba(0,255,255,0.3); }
        .unlock-card.unlocked:hover { border-color: var(--primary); transform: translateY(-3px); box-shadow: 0 5px 20px rgba(0,255,255,0.2); }
        .unlock-card.locked { opacity: 0.5; }
        .unlock-card.locked::after { content: 'üîí'; position: absolute; top: 5px; right: 5px; font-size: 12px; }
        .unlock-card.rarity-common { border-color: rgba(150,150,150,0.3); }
        .unlock-card.rarity-uncommon { border-color: rgba(0,255,136,0.3); }
        .unlock-card.rarity-rare { border-color: rgba(0,136,255,0.5); }
        .unlock-card.rarity-epic { border-color: rgba(170,0,255,0.5); }
        .unlock-card.rarity-legendary { border-color: rgba(255,136,0,0.5); }
        .unlock-card.rarity-mythic { border-color: rgba(255,0,170,0.7); box-shadow: 0 0 15px rgba(255,0,170,0.3); }
        .unlock-icon { width: 45px; height: 45px; margin: 0 auto 6px; display: flex; align-items: center; justify-content: center; font-size: 24px; border-radius: 8px; background: rgba(255,255,255,0.05); }
        .unlock-name { font-weight: 600; font-size: 12px; margin-bottom: 3px; color: var(--text); }
        .unlock-desc { font-size: 9px; color: var(--text-dim); line-height: 1.2; }
        .unlock-rarity { font-size: 8px; text-transform: uppercase; letter-spacing: 1px; margin-top: 4px; font-weight: 700; }
        .rarity-common .unlock-rarity { color: #999; }
        .rarity-uncommon .unlock-rarity { color: var(--success); }
        .rarity-rare .unlock-rarity { color: var(--rare); }
        .rarity-epic .unlock-rarity { color: var(--epic); }
        .rarity-legendary .unlock-rarity { color: var(--legendary); }
        .rarity-mythic .unlock-rarity { color: var(--mythic); }
        
        .character-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 12px; width: 100%; max-width: 550px; max-height: 400px; overflow-y: auto; margin-top: 15px; }
        .character-card { background: var(--bg-card); border: 2px solid rgba(255,255,255,0.1); border-radius: 12px; padding: 12px; text-align: center; cursor: pointer; transition: all 0.3s ease; position: relative; }
        .character-card.selected { border-color: var(--primary); box-shadow: 0 0 25px rgba(0,255,255,0.3); }
        .character-card.locked { opacity: 0.4; cursor: not-allowed; }
        .character-card:not(.locked):hover { transform: translateY(-3px); border-color: var(--secondary); }
        .character-preview { width: 50px; height: 50px; margin: 0 auto 8px; }
        .character-name { font-weight: 600; font-size: 11px; margin-bottom: 3px; }
        .character-req { font-size: 9px; color: var(--text-dim); }
        
        .settings-group { width: 100%; max-width: 400px; margin: 10px 0; }
        .settings-group label { display: block; color: var(--text-dim); font-size: 12px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }
        .settings-slider { width: 100%; height: 8px; border-radius: 4px; background: rgba(255,255,255,0.1); -webkit-appearance: none; appearance: none; outline: none; }
        .settings-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; border-radius: 50%; background: var(--primary); cursor: pointer; box-shadow: 0 0 10px var(--primary); }
        .settings-toggle { display: flex; align-items: center; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .toggle-switch { width: 50px; height: 26px; background: rgba(255,255,255,0.1); border-radius: 13px; position: relative; cursor: pointer; transition: all 0.3s ease; }
        .toggle-switch.active { background: var(--primary); }
        .toggle-switch::after { content: ''; position: absolute; top: 3px; left: 3px; width: 20px; height: 20px; background: #fff; border-radius: 50%; transition: all 0.3s ease; }
        .toggle-switch.active::after { left: 27px; }
        
        .tutorial-section { width: 100%; max-width: 500px; margin: 12px 0; }
        .tutorial-section h3 { color: var(--primary); font-size: 16px; margin-bottom: 8px; display: flex; align-items: center; gap: 10px; }
        .tutorial-section p { color: var(--text-dim); font-size: 13px; line-height: 1.5; }
        .tutorial-highlight { background: var(--bg-card); border-left: 3px solid var(--accent); padding: 12px; border-radius: 0 8px 8px 0; margin: 8px 0; }
        .tutorial-highlight strong { color: var(--accent); }
        
        #upgradeMenu { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(10,10,15,0.95); display: none; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; z-index: 100; padding: 20px; }
        #upgradeMenu h2 { font-family: 'Orbitron', monospace; color: var(--primary); text-shadow: 0 0 20px var(--primary); margin-bottom: 20px; font-size: 24px; animation: titlePulse 1.5s ease-in-out infinite; }
        .upgrade-options { display: flex; flex-direction: column; gap: 12px; width: 100%; max-width: 380px; }
        .upgrade-option { background: var(--bg-card); border: 2px solid rgba(0,255,255,0.3); border-radius: 10px; padding: 15px; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; gap: 12px; }
        .upgrade-option:hover, .upgrade-option:active { border-color: var(--primary); background: rgba(0,255,255,0.1); transform: scale(1.02); box-shadow: 0 0 25px rgba(0,255,255,0.3); }
        .upgrade-icon { width: 45px; height: 45px; background: rgba(255,0,255,0.2); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 20px; flex-shrink: 0; }
        .upgrade-info { flex: 1; }
        .upgrade-info h3 { color: var(--secondary); font-size: 13px; margin-bottom: 3px; font-weight: 600; }
        .upgrade-info p { color: var(--text-dim); font-size: 11px; margin-bottom: 3px; }
        .upgrade-stack { color: var(--primary); font-family: 'Orbitron', monospace; font-size: 11px; }
        
        #deathScreen { background: rgba(10,10,15,0.98); }
        #deathScreen h2 { font-family: 'Orbitron', monospace; color: var(--danger); font-size: 42px; text-shadow: 0 0 30px var(--danger); margin-bottom: 20px; animation: deathPulse 0.5s ease-out; }
        @keyframes deathPulse { 0% { transform: scale(2); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
        .death-stats { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin-bottom: 20px; }
        .death-stat { text-align: center; }
        .death-stat-value { font-family: 'Orbitron', monospace; font-size: 24px; color: var(--primary); }
        .death-stat-label { font-size: 10px; color: var(--text-dim); text-transform: uppercase; }
        .new-unlocks { background: rgba(0,255,136,0.1); border: 1px solid var(--success); border-radius: 10px; padding: 12px 20px; margin-bottom: 15px; text-align: center; }
        .new-unlocks h4 { color: var(--success); font-size: 12px; margin-bottom: 6px; }
        .new-unlocks-list { color: var(--success); font-size: 11px; }
        .xp-gained { background: rgba(255,255,0,0.1); border: 1px solid var(--accent); border-radius: 10px; padding: 10px 20px; margin-bottom: 15px; text-align: center; }
        .xp-gained span { color: var(--accent); font-family: 'Orbitron', monospace; font-weight: 700; }
        
        .achievement-popup { position: fixed; top: 80px; right: 20px; background: var(--bg-card); border: 2px solid var(--accent); border-radius: 10px; padding: 12px 20px; z-index: 1000; animation: achievementSlide 0.5s ease-out; display: none; }
        .achievement-popup.active { display: block; }
        @keyframes achievementSlide { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        .achievement-popup h4 { color: var(--accent); font-size: 12px; margin-bottom: 5px; }
        .achievement-popup p { color: var(--text); font-size: 14px; font-weight: 600; }
        
        .achievements-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px; width: 100%; max-width: 700px; max-height: 350px; overflow-y: auto; padding: 10px; }
        .achievement-card { background: var(--bg-card); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; padding: 10px; display: flex; align-items: center; gap: 10px; transition: all 0.3s; }
        .achievement-card.completed { border-color: var(--accent); background: rgba(255,255,0,0.05); }
        .achievement-card.locked { opacity: 0.5; }
        .achievement-icon { font-size: 24px; width: 40px; text-align: center; }
        .achievement-info { flex: 1; }
        .achievement-info h5 { font-size: 12px; margin-bottom: 2px; }
        .achievement-info p { font-size: 9px; color: var(--text-dim); }
        .achievement-progress { height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; margin-top: 4px; overflow: hidden; }
        .achievement-progress-fill { height: 100%; background: var(--accent); }
        
        .challenge-card { background: var(--bg-card); border: 1px solid rgba(255,136,0,0.3); border-radius: 10px; padding: 15px; margin: 10px 0; width: 100%; max-width: 500px; }
        .challenge-card.daily { border-color: var(--primary); }
        .challenge-card.weekly { border-color: var(--legendary); }
        .challenge-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .challenge-header h4 { color: var(--legendary); font-size: 14px; }
        .challenge-timer { color: var(--text-dim); font-size: 11px; font-family: 'Orbitron', monospace; }
        .challenge-desc { color: var(--text); font-size: 13px; margin-bottom: 10px; }
        .challenge-reward { color: var(--accent); font-size: 11px; }
        .mission-list { width: 100%; max-width: 500px; }
        .mission-item { background: var(--bg-card); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; padding: 10px 15px; margin: 8px 0; display: flex; align-items: center; gap: 15px; }
        .mission-item.completed { border-color: var(--success); background: rgba(0,255,136,0.05); }
        .mission-icon { font-size: 20px; }
        .mission-info { flex: 1; }
        .mission-info h5 { font-size: 12px; margin-bottom: 3px; }
        .mission-info p { font-size: 10px; color: var(--text-dim); }
        .mission-reward { color: var(--accent); font-size: 11px; font-family: 'Orbitron', monospace; }
        
        .mode-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 12px; width: 100%; max-width: 500px; margin-top: 15px; }
        .mode-card { background: var(--bg-card); border: 2px solid rgba(255,255,255,0.1); border-radius: 12px; padding: 15px; text-align: center; cursor: pointer; transition: all 0.3s; }
        .mode-card:hover { border-color: var(--primary); transform: translateY(-3px); }
        .mode-card.locked { opacity: 0.4; cursor: not-allowed; }
        .mode-card.selected { border-color: var(--secondary); box-shadow: 0 0 20px rgba(255,0,255,0.3); }
        .mode-icon { font-size: 32px; margin-bottom: 8px; }
        .mode-name { font-weight: 600; font-size: 13px; margin-bottom: 4px; }
        .mode-desc { font-size: 10px; color: var(--text-dim); }
        
        .confirm-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; z-index: 500; }
        .confirm-overlay.active { display: flex; }
        .confirm-dialog { background: var(--bg-card); border: 2px solid var(--danger); border-radius: 15px; padding: 25px; text-align: center; max-width: 320px; }
        .confirm-dialog h3 { color: var(--danger); margin-bottom: 12px; }
        .confirm-dialog p { color: var(--text-dim); margin-bottom: 20px; font-size: 13px; }
        .confirm-buttons { display: flex; gap: 12px; justify-content: center; }
        
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); border-radius: 3px; }
        ::-webkit-scrollbar-thumb { background: var(--primary); border-radius: 3px; }
        
        @media (max-width: 500px) {
            .game-title { font-size: 42px; letter-spacing: 4px; }
            .subtitle { font-size: 16px; letter-spacing: 6px; }
            .stats-dashboard { grid-template-columns: repeat(2, 1fr); }
            .death-stats { grid-template-columns: repeat(2, 1fr); }
            .death-stat-value { font-size: 20px; }
            .menu-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div id="score" class="ui-element">0</div>
        <div id="level" class="ui-element">LV 1</div>
        <div id="time" class="ui-element">0:00</div>
        <div id="comboDisplay" class="ui-element">x1</div>
        <div id="accountLevel" class="ui-element"></div>
        <div id="mutators" class="ui-element"></div>
        <div id="upgradeList" class="ui-element"></div>
    </div>
    
    <div id="upgradeMenu">
        <h2>‚ö° LEVEL UP ‚ö°</h2>
        <div id="upgradeOptions" class="upgrade-options"></div>
    </div>
    
    <div id="achievementPopup" class="achievement-popup">
        <h4>üèÜ ACHIEVEMENT UNLOCKED</h4>
        <p id="achievementName"></p>
    </div>
    
    <div id="startScreen" class="screen active">
        <div class="animated-bg"><div class="grid-overlay"></div></div>
        <div class="title-container">
            <h1 class="game-title">1HP</h1>
            <div class="subtitle">CHAOS MODE</div>
            <p class="tagline">One hit kills. React or die.</p>
        </div>
        <div class="menu-buttons">
            <button class="btn btn-primary" id="startBtn">START GAME</button>
        </div>
        <div class="menu-grid">
            <button class="btn" id="progressionBtn">üìä PROGRESSION</button>
            <button class="btn" id="achievementsBtn">üèÜ ACHIEVEMENTS</button>
            <button class="btn" id="challengesBtn">üìã CHALLENGES</button>
            <button class="btn" id="codexBtn">üìö CODEX</button>
            <button class="btn" id="modesBtn">üéÆ MODES</button>
            <button class="btn" id="characterBtn">üé≠ CHARACTER</button>
            <button class="btn" id="settingsBtn">‚öôÔ∏è SETTINGS</button>
            <button class="btn" id="tutorialBtn">üìñ HOW TO PLAY</button>
        </div>
        <div class="best-score">
            <div class="best-score-label">Best Score</div>
            <div class="best-score-value" id="bestScoreDisplay">0</div>
        </div>
        <div class="account-info">
            <div class="account-level">ACCOUNT LEVEL <span id="accountLevelDisplay">1</span></div>
            <div class="account-xp-bar"><div class="account-xp-fill" id="accountXpFill"></div></div>
        </div>
    </div>
    
    <div id="progressionScreen" class="screen">
        <div class="animated-bg"><div class="grid-overlay"></div></div>
        <button class="btn btn-back" id="progressionBack">‚Üê BACK</button>
        <div class="progression-header"><h2>üìä PROGRESSION</h2></div>
        <div class="stats-dashboard" id="statsDashboard">
            <div class="stat-card"><div class="stat-value" id="statRuns">0</div><div class="stat-label">Runs</div></div>
            <div class="stat-card"><div class="stat-value" id="statBestScore">0</div><div class="stat-label">Best Score</div></div>
            <div class="stat-card"><div class="stat-value" id="statBestTime">0:00</div><div class="stat-label">Best Time</div></div>
            <div class="stat-card"><div class="stat-value" id="statKills">0</div><div class="stat-label">Kills</div></div>
            <div class="stat-card"><div class="stat-value" id="statPlaytime">0h</div><div class="stat-label">Playtime</div></div>
            <div class="stat-card"><div class="stat-value" id="statNearMisses">0</div><div class="stat-label">Near Miss</div></div>
            <div class="stat-card"><div class="stat-value" id="statMaxCombo">0</div><div class="stat-label">Max Combo</div></div>
            <div class="stat-card"><div class="stat-value" id="statPrestige">0</div><div class="stat-label">Prestige</div></div>
        </div>
        <div class="completion-bar">
            <div class="completion-bar-header">
                <span class="completion-bar-label">Unlock Progress</span>
                <span class="completion-bar-percent" id="completionPercent">0%</span>
            </div>
            <div class="completion-bar-track"><div class="completion-bar-fill" id="completionFill"></div></div>
        </div>
        <div class="unlock-tabs" id="unlockTabs">
            <button class="unlock-tab active" data-category="skins">Skins</button>
            <button class="unlock-tab" data-category="triggers">Triggers</button>
            <button class="unlock-tab" data-category="effects">Effects</button>
            <button class="unlock-tab" data-category="mutators">Mutators</button>
            <button class="unlock-tab" data-category="enemies">Enemies</button>
        </div>
        <div class="unlock-grid" id="unlockGrid"></div>
    </div>
    
    <div id="achievementsScreen" class="screen">
        <div class="animated-bg"><div class="grid-overlay"></div></div>
        <button class="btn btn-back" id="achievementsBack">‚Üê BACK</button>
        <div class="progression-header"><h2>üèÜ ACHIEVEMENTS</h2></div>
        <div class="unlock-tabs" id="achievementTabs">
            <button class="unlock-tab active" data-category="all">All</button>
            <button class="unlock-tab" data-category="score">Score</button>
            <button class="unlock-tab" data-category="survival">Survival</button>
            <button class="unlock-tab" data-category="kills">Kills</button>
            <button class="unlock-tab" data-category="skill">Skill</button>
            <button class="unlock-tab" data-category="collection">Collection</button>
            <button class="unlock-tab" data-category="special">Special</button>
        </div>
        <div class="achievements-grid" id="achievementsGrid"></div>
    </div>
    
    <div id="challengesScreen" class="screen">
        <div class="animated-bg"><div class="grid-overlay"></div></div>
        <button class="btn btn-back" id="challengesBack">‚Üê BACK</button>
        <div class="progression-header"><h2>üìã CHALLENGES & MISSIONS</h2></div>
        <div id="dailyChallenge" class="challenge-card daily"></div>
        <div id="weeklyChallenge" class="challenge-card weekly"></div>
        <h3 style="color: var(--primary); margin: 15px 0 10px; font-size: 16px;">Active Missions</h3>
        <div class="mission-list" id="missionList"></div>
    </div>
    
    <div id="codexScreen" class="screen">
        <div class="animated-bg"><div class="grid-overlay"></div></div>
        <button class="btn btn-back" id="codexBack">‚Üê BACK</button>
        <div class="progression-header"><h2>üìö CODEX</h2></div>
        <div class="unlock-tabs" id="codexTabs">
            <button class="unlock-tab active" data-category="enemies">Enemies</button>
            <button class="unlock-tab" data-category="upgrades">Upgrades</button>
            <button class="unlock-tab" data-category="mutators">Mutators</button>
        </div>
        <div class="unlock-grid" id="codexGrid"></div>
    </div>
    
    <div id="modesScreen" class="screen">
        <div class="animated-bg"><div class="grid-overlay"></div></div>
        <button class="btn btn-back" id="modesBack">‚Üê BACK</button>
        <div class="progression-header"><h2>üéÆ GAME MODES</h2></div>
        <div class="mode-grid" id="modeGrid"></div>
        <button class="btn btn-primary" id="confirmMode" style="margin-top: 20px;">CONFIRM</button>
    </div>
    
    <div id="characterScreen" class="screen">
        <div class="animated-bg"><div class="grid-overlay"></div></div>
        <button class="btn btn-back" id="characterBack">‚Üê BACK</button>
        <div class="progression-header"><h2>üé≠ SELECT CHARACTER</h2></div>
        <div class="unlock-tabs" id="skinTabs">
            <button class="unlock-tab active" data-rarity="all">All</button>
            <button class="unlock-tab" data-rarity="common">Common</button>
            <button class="unlock-tab" data-rarity="uncommon">Uncommon</button>
            <button class="unlock-tab" data-rarity="rare">Rare</button>
            <button class="unlock-tab" data-rarity="epic">Epic</button>
            <button class="unlock-tab" data-rarity="legendary">Legendary</button>
            <button class="unlock-tab" data-rarity="mythic">Mythic</button>
        </div>
        <div class="character-grid" id="characterGrid"></div>
        <button class="btn btn-primary" id="confirmCharacter" style="margin-top: 20px;">CONFIRM</button>
    </div>
    
    <div id="settingsScreen" class="screen">
        <div class="animated-bg"><div class="grid-overlay"></div></div>
        <button class="btn btn-back" id="settingsBack">‚Üê BACK</button>
        <div class="progression-header"><h2>‚öôÔ∏è SETTINGS</h2></div>
        <div class="settings-group">
            <label>Music Volume</label>
            <input type="range" class="settings-slider" id="musicVolume" min="0" max="100" value="30">
        </div>
        <div class="settings-group">
            <label>SFX Volume</label>
            <input type="range" class="settings-slider" id="sfxVolume" min="0" max="100" value="60">
        </div>
        <div class="settings-group">
            <div class="settings-toggle"><span>Screen Shake</span><div class="toggle-switch active" id="toggleShake"></div></div>
            <div class="settings-toggle"><span>Visual Effects</span><div class="toggle-switch active" id="toggleEffects"></div></div>
            <div class="settings-toggle"><span>Show Trail</span><div class="toggle-switch active" id="toggleTrail"></div></div>
            <div class="settings-toggle"><span>Quick Restart</span><div class="toggle-switch" id="toggleQuickRestart"></div></div>
        </div>
        <button class="btn btn-danger btn-small" id="resetProgressBtn">RESET PROGRESS</button>
    </div>
    
    <div id="tutorialScreen" class="screen">
        <div class="animated-bg"><div class="grid-overlay"></div></div>
        <button class="btn btn-back" id="tutorialBack">‚Üê BACK</button>
        <div class="progression-header"><h2>üìñ HOW TO PLAY</h2></div>
        <div class="tutorial-section"><h3>üéÆ Controls</h3><p>Touch/click and drag to move. Movement is relative to your touch position.</p></div>
        <div class="tutorial-section"><h3>üíÄ Core Mechanic</h3><div class="tutorial-highlight"><strong>You have 1 HP.</strong> One hit = death. Master dodging!</div></div>
        <div class="tutorial-section"><h3>‚ö° Auto-Attack</h3><p>Your character fires automatically. Focus on dodging!</p></div>
        <div class="tutorial-section"><h3>üî• Combos</h3><p>Kill enemies quickly to build combos. Higher combos = more XP and score!</p></div>
        <div class="tutorial-section"><h3>üéØ Upgrades</h3><p>Level up to choose Trigger ‚Üí Effect combos that activate automatically.</p></div>
        <div class="tutorial-section"><h3>üé≤ Mutators</h3><p>Each run has random rule modifiers. Adapt your strategy!</p></div>
    </div>
    
    <div id="deathScreen" class="screen">
        <div class="animated-bg"><div class="grid-overlay"></div></div>
        <h2>DEAD</h2>
        <div class="death-stats">
            <div class="death-stat"><div class="death-stat-value" id="finalScore">0</div><div class="death-stat-label">Score</div></div>
            <div class="death-stat"><div class="death-stat-value" id="finalTime">0:00</div><div class="death-stat-label">Time</div></div>
            <div class="death-stat"><div class="death-stat-value" id="finalLevel">1</div><div class="death-stat-label">Level</div></div>
            <div class="death-stat"><div class="death-stat-value" id="finalCombo">0</div><div class="death-stat-label">Max Combo</div></div>
        </div>
        <div id="xpGained" class="xp-gained" style="display: none;">Account XP: +<span id="xpGainedValue">0</span></div>
        <div id="newUnlocksContainer" class="new-unlocks" style="display: none;">
            <h4>üéâ NEW UNLOCKS!</h4>
            <div id="newUnlocksList" class="new-unlocks-list"></div>
        </div>
        <button class="btn btn-primary" id="restartBtn">PLAY AGAIN</button>
        <button class="btn btn-small" id="menuBtn">MAIN MENU</button>
    </div>
    
    <div id="confirmOverlay" class="confirm-overlay">
        <div class="confirm-dialog">
            <h3>‚ö†Ô∏è Reset Progress?</h3>
            <p>This will delete ALL unlocks and stats. Cannot be undone!</p>
            <div class="confirm-buttons">
                <button class="btn btn-small" id="confirmCancel">Cancel</button>
                <button class="btn btn-danger btn-small" id="confirmReset">Reset</button>
            </div>
        </div>
    </div>

<script>
(function() {
    'use strict';

    // Upgrade keys used to be stored as `${trigger}_${effect}`, but both trigger/effect IDs contain
    // underscores (e.g. ON_NEAR_MISS, TIME_SLOW). Splitting on '_' breaks parsing and prevents
    // chosen effects from ever triggering. Use a safe separator and keep backward compatibility.
    const UPGRADE_KEY_SEP = '__';
    function parseUpgradeKey(key) {
        if (typeof key !== 'string') return { trigger: null, effect: null };
        // New format
        if (key.includes(UPGRADE_KEY_SEP)) {
            const idx = key.indexOf(UPGRADE_KEY_SEP);
            return { trigger: key.slice(0, idx), effect: key.slice(idx + UPGRADE_KEY_SEP.length) };
        }
        // Legacy format: find the longest trigger prefix that matches.
        // Triggers are a small fixed set; this makes old saves continue working.
        const triggers = Object.keys(UPGRADE_TRIGGERS).sort((a, b) => b.length - a.length);
        for (const t of triggers) {
            const prefix = t + '_';
            if (key.startsWith(prefix)) return { trigger: t, effect: key.slice(prefix.length) };
        }
        // Fallback
        const parts = key.split('_');
        return { trigger: parts[0] || null, effect: parts.slice(1).join('_') || null };
    }
    
    const CONFIG = {
        CANVAS_WIDTH: 400,
        CANVAS_HEIGHT: 700,
        PLAYER_SIZE: 15,
        PLAYER_SPEED: 8,
        PLAYER_FRICTION: 0.85,
        BULLET_SPEED: 12,
        ENEMY_BASE_SPEED: 2,
        XP_TO_LEVEL: 100,
        XP_SCALE: 1.3,
        SPAWN_RATE_INITIAL: 2000,
        SPAWN_RATE_MIN: 400,
        NEAR_MISS_DISTANCE: 25,
        COMBO_DECAY_TIME: 2,
        ACCOUNT_XP_PER_LEVEL: 1000
    };
    
    // ========== 50+ PLAYER SKINS ==========
    const PLAYER_SKINS = {
        // COMMON (10)
        DIAMOND: { name: 'Diamond', shape: 'diamond', color: '#00ffff', glowColor: '#00ffff', trailColor: 'rgba(0,255,255,0.3)', rarity: 'common', unlocked: true, requirement: 'Default' },
        CIRCLE: { name: 'Orb', shape: 'circle', color: '#ff00ff', glowColor: '#ff00ff', trailColor: 'rgba(255,0,255,0.3)', rarity: 'common', requirement: 'Score 500', check: m => m.bestScore >= 500 },
        TRIANGLE: { name: 'Arrow', shape: 'triangle', color: '#ffff00', glowColor: '#ffff00', trailColor: 'rgba(255,255,0,0.3)', rarity: 'common', requirement: 'Survive 60s', check: m => m.bestTime >= 60 },
        SQUARE: { name: 'Block', shape: 'square', color: '#00ff00', glowColor: '#00ff00', trailColor: 'rgba(0,255,0,0.3)', rarity: 'common', requirement: '10 runs', check: m => m.totalRuns >= 10 },
        PILL: { name: 'Capsule', shape: 'pill', color: '#ff8800', glowColor: '#ff8800', trailColor: 'rgba(255,136,0,0.3)', rarity: 'common', requirement: '50 kills total', check: m => m.totalKills >= 50 },
        PLUS: { name: 'Medic', shape: 'plus', color: '#ff4444', glowColor: '#ff4444', trailColor: 'rgba(255,68,68,0.3)', rarity: 'common', requirement: 'Score 300', check: m => m.bestScore >= 300 },
        RHOMBUS: { name: 'Rhombus', shape: 'rhombus', color: '#44ff88', glowColor: '#44ff88', trailColor: 'rgba(68,255,136,0.3)', rarity: 'common', requirement: '5 runs', check: m => m.totalRuns >= 5 },
        OVAL: { name: 'Ellipse', shape: 'oval', color: '#8844ff', glowColor: '#8844ff', trailColor: 'rgba(136,68,255,0.3)', rarity: 'common', requirement: 'Survive 30s', check: m => m.bestTime >= 30 },
        WEDGE: { name: 'Wedge', shape: 'wedge', color: '#ff44aa', glowColor: '#ff44aa', trailColor: 'rgba(255,68,170,0.3)', rarity: 'common', requirement: '20 kills total', check: m => m.totalKills >= 20 },
        DOT: { name: 'Minimal', shape: 'dot', color: '#ffffff', glowColor: '#ffffff', trailColor: 'rgba(255,255,255,0.3)', rarity: 'common', requirement: '3 runs', check: m => m.totalRuns >= 3 },
        
        // UNCOMMON (12)
        HEXAGON: { name: 'Hex', shape: 'hexagon', color: '#00ff88', glowColor: '#00ff88', trailColor: 'rgba(0,255,136,0.3)', rarity: 'uncommon', requirement: '100 kills total', check: m => m.totalKills >= 100 },
        STAR: { name: 'Nova', shape: 'star', color: '#ff8800', glowColor: '#ff8800', trailColor: 'rgba(255,136,0,0.3)', rarity: 'uncommon', requirement: '20 runs', check: m => m.totalRuns >= 20 },
        PENTAGON: { name: 'Shield', shape: 'pentagon', color: '#8888ff', glowColor: '#8888ff', trailColor: 'rgba(136,136,255,0.3)', rarity: 'uncommon', requirement: 'Level 10', check: m => m.bestLevel >= 10 },
        CROSS: { name: 'Cross', shape: 'cross', color: '#ff0088', glowColor: '#ff0088', trailColor: 'rgba(255,0,136,0.3)', rarity: 'uncommon', requirement: 'Score 2000', check: m => m.bestScore >= 2000 },
        OCTAGON: { name: 'Octo', shape: 'octagon', color: '#88ff88', glowColor: '#88ff88', trailColor: 'rgba(136,255,136,0.3)', rarity: 'uncommon', requirement: '200 kills total', check: m => m.totalKills >= 200 },
        BURST: { name: 'Burst', shape: 'burst', color: '#ffaa00', glowColor: '#ffaa00', trailColor: 'rgba(255,170,0,0.3)', rarity: 'uncommon', requirement: 'Score 1500', check: m => m.bestScore >= 1500 },
        CRESCENT: { name: 'Moon', shape: 'crescent', color: '#aaaaff', glowColor: '#aaaaff', trailColor: 'rgba(170,170,255,0.3)', rarity: 'uncommon', requirement: 'Survive 90s', check: m => m.bestTime >= 90 },
        BOLT: { name: 'Bolt', shape: 'bolt', color: '#ffff88', glowColor: '#ffff88', trailColor: 'rgba(255,255,136,0.3)', rarity: 'uncommon', requirement: '30 runs', check: m => m.totalRuns >= 30 },
        GEAR: { name: 'Gear', shape: 'gear', color: '#888888', glowColor: '#aaaaaa', trailColor: 'rgba(136,136,136,0.3)', rarity: 'uncommon', requirement: '300 kills total', check: m => m.totalKills >= 300 },
        TEARDROP: { name: 'Tear', shape: 'teardrop', color: '#00aaff', glowColor: '#00aaff', trailColor: 'rgba(0,170,255,0.3)', rarity: 'uncommon', requirement: '40 runs', check: m => m.totalRuns >= 40 },
        CLOVER: { name: 'Clover', shape: 'clover', color: '#00dd00', glowColor: '#00dd00', trailColor: 'rgba(0,221,0,0.3)', rarity: 'uncommon', requirement: '10 near misses in run', check: m => m.bestNearMisses >= 10 },
        HEART: { name: 'Heart', shape: 'heart', color: '#ff6688', glowColor: '#ff6688', trailColor: 'rgba(255,102,136,0.3)', rarity: 'uncommon', requirement: '25 runs', check: m => m.totalRuns >= 25 },
        
        // RARE (10)
        GHOST: { name: 'Ghost', shape: 'ghost', color: '#aaffff', glowColor: '#aaffff', trailColor: 'rgba(170,255,255,0.4)', rarity: 'rare', requirement: 'Survive 120s', check: m => m.bestTime >= 120 },
        BLADE: { name: 'Blade', shape: 'blade', color: '#ff4444', glowColor: '#ff4444', trailColor: 'rgba(255,68,68,0.3)', rarity: 'rare', requirement: '500 kills total', check: m => m.totalKills >= 500 },
        SPIRAL: { name: 'Spiral', shape: 'spiral', color: '#ff88ff', glowColor: '#ff88ff', trailColor: 'rgba(255,136,255,0.3)', rarity: 'rare', requirement: 'Score 3000', check: m => m.bestScore >= 3000 },
        ATOM: { name: 'Atom', shape: 'atom', color: '#00ffaa', glowColor: '#00ffaa', trailColor: 'rgba(0,255,170,0.3)', rarity: 'rare', requirement: 'Level 15', check: m => m.bestLevel >= 15 },
        CROWN: { name: 'Crown', shape: 'crown', color: '#ffcc00', glowColor: '#ffcc00', trailColor: 'rgba(255,204,0,0.4)', rarity: 'rare', requirement: '50 runs', check: m => m.totalRuns >= 50 },
        FLAME: { name: 'Flame', shape: 'flame', color: '#ff5500', glowColor: '#ff5500', trailColor: 'rgba(255,85,0,0.4)', rarity: 'rare', requirement: '10x combo', check: m => m.bestCombo >= 10 },
        FROST: { name: 'Frost', shape: 'frost', color: '#88ddff', glowColor: '#88ddff', trailColor: 'rgba(136,221,255,0.4)', rarity: 'rare', requirement: 'Survive 150s', check: m => m.bestTime >= 150 },
        SHADOW: { name: 'Shadow', shape: 'shadow', color: '#444466', glowColor: '#666688', trailColor: 'rgba(68,68,102,0.5)', rarity: 'rare', requirement: '1000 kills total', check: m => m.totalKills >= 1000 },
        PRISM: { name: 'Prism', shape: 'prism', color: '#ff00ff', glowColor: '#ff00ff', trailColor: 'rgba(255,0,255,0.4)', rarity: 'rare', requirement: '75 runs', check: m => m.totalRuns >= 75 },
        WING: { name: 'Wing', shape: 'wing', color: '#ffffff', glowColor: '#ffffff', trailColor: 'rgba(255,255,255,0.4)', rarity: 'rare', requirement: 'Score 4000', check: m => m.bestScore >= 4000 },
        
        // EPIC (10)
        DRAGON: { name: 'Dragon', shape: 'dragon', color: '#ff2200', glowColor: '#ff4400', trailColor: 'rgba(255,34,0,0.5)', rarity: 'epic', requirement: 'Score 5000', check: m => m.bestScore >= 5000 },
        PHOENIX: { name: 'Phoenix', shape: 'phoenix', color: '#ff8800', glowColor: '#ffaa00', trailColor: 'rgba(255,136,0,0.5)', rarity: 'epic', requirement: 'Survive 180s', check: m => m.bestTime >= 180 },
        VOID: { name: 'Void', shape: 'void', color: '#220044', glowColor: '#440088', trailColor: 'rgba(34,0,68,0.6)', rarity: 'epic', requirement: '2000 kills total', check: m => m.totalKills >= 2000 },
        NEON: { name: 'Neon', shape: 'neon', color: '#00ff00', glowColor: '#00ff00', trailColor: 'rgba(0,255,0,0.5)', rarity: 'epic', animated: true, requirement: '100 runs', check: m => m.totalRuns >= 100 },
        CRYSTAL: { name: 'Crystal', shape: 'crystal', color: '#aaeeff', glowColor: '#ccffff', trailColor: 'rgba(170,238,255,0.5)', rarity: 'epic', requirement: 'Level 20', check: m => m.bestLevel >= 20 },
        INFERNO: { name: 'Inferno', shape: 'inferno', color: '#ff3300', glowColor: '#ff5500', trailColor: 'rgba(255,51,0,0.5)', rarity: 'epic', animated: true, requirement: '20x combo', check: m => m.bestCombo >= 20 },
        GLACIER: { name: 'Glacier', shape: 'glacier', color: '#00ccff', glowColor: '#00eeff', trailColor: 'rgba(0,204,255,0.5)', rarity: 'epic', requirement: 'Survive 240s', check: m => m.bestTime >= 240 },
        LIGHTNING: { name: 'Lightning', shape: 'lightning', color: '#ffff00', glowColor: '#ffff88', trailColor: 'rgba(255,255,0,0.5)', rarity: 'epic', animated: true, requirement: 'Score 7500', check: m => m.bestScore >= 7500 },
        NEBULA: { name: 'Nebula', shape: 'nebula', color: '#8800ff', glowColor: '#aa44ff', trailColor: 'rgba(136,0,255,0.5)', rarity: 'epic', animated: true, requirement: '3000 kills total', check: m => m.totalKills >= 3000 },
        TOXIC: { name: 'Toxic', shape: 'toxic', color: '#88ff00', glowColor: '#aaff44', trailColor: 'rgba(136,255,0,0.5)', rarity: 'epic', requirement: '150 runs', check: m => m.totalRuns >= 150 },
        
        // LEGENDARY (6)
        CHAOS: { name: 'Chaos', shape: 'chaos', color: '#ffffff', glowColor: '#ffffff', trailColor: 'rgba(255,255,255,0.5)', rarity: 'legendary', animated: true, requirement: 'Score 10000', check: m => m.bestScore >= 10000 },
        CELESTIAL: { name: 'Celestial', shape: 'celestial', color: '#ffdd00', glowColor: '#ffee44', trailColor: 'rgba(255,221,0,0.6)', rarity: 'legendary', animated: true, requirement: 'Survive 300s', check: m => m.bestTime >= 300 },
        DARK_MATTER: { name: 'Dark Matter', shape: 'darkmatter', color: '#110022', glowColor: '#330066', trailColor: 'rgba(17,0,34,0.7)', rarity: 'legendary', animated: true, requirement: '5000 kills total', check: m => m.totalKills >= 5000 },
        SUPERNOVA: { name: 'Supernova', shape: 'supernova', color: '#ff4488', glowColor: '#ff66aa', trailColor: 'rgba(255,68,136,0.6)', rarity: 'legendary', animated: true, requirement: '200 runs', check: m => m.totalRuns >= 200 },
        QUANTUM: { name: 'Quantum', shape: 'quantum', color: '#00ffff', glowColor: '#44ffff', trailColor: 'rgba(0,255,255,0.6)', rarity: 'legendary', animated: true, requirement: 'Level 25', check: m => m.bestLevel >= 25 },
        ECLIPSE: { name: 'Eclipse', shape: 'eclipse', color: '#ff8800', glowColor: '#ffaa44', trailColor: 'rgba(255,136,0,0.6)', rarity: 'legendary', animated: true, requirement: '30x combo', check: m => m.bestCombo >= 30 },
        
        // MYTHIC (4)
        OMEGA: { name: 'Omega', shape: 'omega', color: '#ff00ff', glowColor: '#ff44ff', trailColor: 'rgba(255,0,255,0.7)', rarity: 'mythic', animated: true, particles: true, requirement: 'Score 25000', check: m => m.bestScore >= 25000 },
        INFINITY: { name: 'Infinity', shape: 'infinity', color: '#00ff88', glowColor: '#44ffaa', trailColor: 'rgba(0,255,136,0.7)', rarity: 'mythic', animated: true, particles: true, requirement: '10000 kills', check: m => m.totalKills >= 10000 },
        ETERNAL: { name: 'Eternal', shape: 'eternal', color: '#ffcc00', glowColor: '#ffdd44', trailColor: 'rgba(255,204,0,0.7)', rarity: 'mythic', animated: true, particles: true, requirement: 'Survive 600s', check: m => m.bestTime >= 600 },
        TRANSCENDENT: { name: 'Transcendent', shape: 'transcendent', color: '#ffffff', glowColor: '#ffffff', trailColor: 'rgba(255,255,255,0.8)', rarity: 'mythic', animated: true, particles: true, requirement: 'Prestige 1', check: m => m.prestige >= 1 }
    };
    
    // ========== 18 UPGRADE TRIGGERS ==========
    const UPGRADE_TRIGGERS = {
        ON_MOVE: { name: 'On Move', desc: 'While moving', check: g => g.player.moving, cooldown: 0.5, icon: 'üèÉ' },
        ON_STOP: { name: 'On Stop', desc: 'When stopping', check: g => !g.player.moving && g.player.wasMoving, cooldown: 0.3, icon: 'üõë' },
        ON_NEAR_MISS: { name: 'Near Miss', desc: 'Dodge bullets closely', check: g => g.player.nearMiss, cooldown: 0.1, icon: 'üò∞' },
        ON_PERFECT_DODGE: { name: 'Perfect Dodge', desc: 'Extremely close dodge', check: g => g.player.perfectDodge, cooldown: 0.1, icon: 'üòé' },
        ON_KILL: { name: 'On Kill', desc: 'When defeating enemy', check: g => g.player.justKilled, cooldown: 0.1, icon: 'üíÄ' },
        ON_MULTI_KILL: { name: 'Multi-Kill', desc: '3+ kills rapidly', check: g => g.player.multiKill >= 3, cooldown: 0.1, icon: 'üî•' },
        ON_WALL: { name: 'Wall Touch', desc: 'Near arena edge', check: g => g.player.nearWall, cooldown: 0.5, icon: 'üß±' },
        ON_STREAK: { name: 'Survival', desc: 'Every 5s no damage', check: g => g.player.streak >= 5 && g.player.streakTick, cooldown: 5, icon: '‚è∞' },
        ON_DASH: { name: 'On Dash', desc: 'When moving fast', check: g => Math.hypot(g.player.vx, g.player.vy) > 5, cooldown: 0.3, icon: 'üí®' },
        ON_STANDSTILL: { name: 'Standstill', desc: 'When completely still', check: g => !g.touch.active && Math.hypot(g.player.vx, g.player.vy) < 0.5, cooldown: 1, icon: 'üßò' },
        ON_CORNER: { name: 'Corner', desc: 'In arena corners', check: g => g.player.inCorner, cooldown: 0.5, icon: 'üìê' },
        ON_CENTER: { name: 'Center', desc: 'In arena center', check: g => g.player.inCenter, cooldown: 0.5, icon: 'üéØ' },
        ON_COMBO: { name: 'On Combo', desc: 'At 5+ combo', check: g => g.combo >= 5, cooldown: 0.5, icon: 'üîó' },
        ON_HIGH_COMBO: { name: 'High Combo', desc: 'At 10+ combo', check: g => g.combo >= 10, cooldown: 0.3, icon: '‚õìÔ∏è' },
        ON_CHAOS_LEVEL: { name: 'Chaos Level', desc: 'High chaos intensity', check: g => g.chaosLevel >= 0.7, cooldown: 1, icon: 'üåÄ' },
        ON_MUTATOR: { name: 'Mutator Active', desc: 'Any mutator effect', check: g => Object.keys(g.rules).length > 0, cooldown: 2, icon: 'üé≤' },
        ON_ELITE_KILL: { name: 'Elite Kill', desc: 'When killing elite', check: g => g.player.justKilledElite, cooldown: 0.1, icon: 'üëë' },
        ON_LEVEL_UP: { name: 'Level Up', desc: 'When leveling up', check: g => g.player.justLeveledUp, cooldown: 0.1, icon: '‚¨ÜÔ∏è' }
    };
    
    // ========== 18 UPGRADE EFFECTS ==========
    const UPGRADE_EFFECTS = {
        PROJECTILE: { name: 'Fire Projectile', desc: 'Shoots bullets', icon: 'üî´', apply: (g, s) => { const a = Math.atan2(g.player.vy||0.1, g.player.vx||0.1); for(let i=0;i<s;i++){const sp=(i-(s-1)/2)*0.2;g.playerBullets.push({x:g.player.x,y:g.player.y,vx:Math.cos(a+sp)*CONFIG.BULLET_SPEED,vy:Math.sin(a+sp)*CONFIG.BULLET_SPEED,size:4,damage:1+Math.floor(s/3)});}}},
        SHOCKWAVE: { name: 'Shockwave', desc: 'Pushes enemies away', icon: 'üí®', apply: (g, s) => { const r=60+s*20;g.enemies.forEach(e=>{const d=Math.hypot(e.x-g.player.x,e.y-g.player.y);if(d<r&&d>0){e.vx+=(e.x-g.player.x)/d*10*s;e.vy+=(e.y-g.player.y)/d*10*s;}});g.visualEffects.push({type:'shockwave',x:g.player.x,y:g.player.y,radius:r,timer:0.3});}},
        TIME_SLOW: { name: 'Time Slow', desc: 'Briefly slows time', icon: '‚è±Ô∏è', apply: (g, s) => { g.timeScale=Math.max(0.1,0.5-s*0.05);setTimeout(()=>{g.timeScale=1;},200+s*50);}},
        AREA_BURST: { name: 'Area Burst', desc: 'Damages nearby', icon: 'üí•', apply: (g, s) => { const r=50+s*15;g.enemies.forEach(e=>{const d=Math.hypot(e.x-g.player.x,e.y-g.player.y);if(d<r){e.hp-=1+Math.floor(s/2);g.spawnHitEffect(e.x,e.y,e.dna.body.color);}});g.visualEffects.push({type:'burst',x:g.player.x,y:g.player.y,radius:r,timer:0.2,color:'#f0f'});}},
        CHAIN_LIGHTNING: { name: 'Chain Lightning', desc: 'Zaps enemies', icon: '‚ö°', apply: (g, s) => { let t=[...g.enemies].filter(e=>!e.dead).sort((a,b)=>Math.hypot(a.x-g.player.x,a.y-g.player.y)-Math.hypot(b.x-g.player.x,b.y-g.player.y)).slice(0,2+s);let p=g.player;t.forEach(e=>{e.hp-=1;g.visualEffects.push({type:'lightning',x1:p.x,y1:p.y,x2:e.x,y2:e.y,timer:0.2});p=e;});}},
        CONVERT: { name: 'Convert Enemy', desc: 'Turns enemy friendly', icon: 'üîÑ', apply: (g, s) => { const t=g.enemies.find(e=>!e.dead&&e.hp<=s&&!e.friendly);if(t){t.friendly=true;t.dna.body.color='#0ff';}}},
        SCORE_MULT: { name: 'Score Boost', desc: 'Multiplies score', icon: '‚ú®', apply: (g, s) => { g.scoreMult=Math.max(g.scoreMult,1+s*0.5);setTimeout(()=>{g.scoreMult=1;},2000);}},
        SHIELD_PULSE: { name: 'Shield Pulse', desc: 'Destroys bullets', icon: 'üõ°Ô∏è', apply: (g, s) => { const r=40+s*20;g.enemyBullets=g.enemyBullets.filter(b=>{if(Math.hypot(b.x-g.player.x,b.y-g.player.y)<r){g.spawnHitEffect(b.x,b.y,'#0ff');return false;}return true;});g.visualEffects.push({type:'shield',x:g.player.x,y:g.player.y,radius:r,timer:0.2});}},
        BLACK_HOLE: { name: 'Black Hole', desc: 'Pulls enemies in', icon: 'üï≥Ô∏è', apply: (g, s) => { const r=80+s*20;g.enemies.forEach(e=>{const d=Math.hypot(e.x-g.player.x,e.y-g.player.y);if(d<r&&d>10){e.vx-=(e.x-g.player.x)/d*5*s;e.vy-=(e.y-g.player.y)/d*5*s;}});g.visualEffects.push({type:'blackhole',x:g.player.x,y:g.player.y,radius:r,timer:0.5});}},
        FREEZE_RAY: { name: 'Freeze Ray', desc: 'Slows enemies', icon: '‚ùÑÔ∏è', apply: (g, s) => { g.enemies.forEach(e=>{const d=Math.hypot(e.x-g.player.x,e.y-g.player.y);if(d<100){e.frozen=(e.frozen||0)+0.5+s*0.2;}});}},
        DUPLICATE: { name: 'Duplicate', desc: 'Clone attack', icon: 'üë•', apply: (g, s) => { for(let i=0;i<s;i++){const a=Math.PI*2*i/s;g.playerBullets.push({x:g.player.x+Math.cos(a)*30,y:g.player.y+Math.sin(a)*30,vx:Math.cos(a)*CONFIG.BULLET_SPEED,vy:Math.sin(a)*CONFIG.BULLET_SPEED,size:4,damage:1});}}},
        TELEPORT_DASH: { name: 'Teleport Dash', desc: 'Blink forward', icon: 'üåÄ', apply: (g, s) => { const a=Math.atan2(g.player.vy||0.1,g.player.vx||0.1);g.player.x+=Math.cos(a)*30*s;g.player.y+=Math.sin(a)*30*s;g.visualEffects.push({type:'teleport',x:g.player.x,y:g.player.y,timer:0.3});}},
        INVINCIBILITY: { name: 'Invincibility', desc: 'Brief immunity', icon: '‚ú¥Ô∏è', apply: (g, s) => { g.player.invincible=(g.player.invincible||0)+0.1+s*0.05;}},
        MAGNET_PULL: { name: 'Magnet Pull', desc: 'Attracts XP', icon: 'üß≤', apply: (g, s) => { g.xpOrbs.forEach(o=>{const d=Math.hypot(o.x-g.player.x,o.y-g.player.y);if(d>0){o.x+=(g.player.x-o.x)/d*10*s;o.y+=(g.player.y-o.y)/d*10*s;}});}},
        ORBITAL_SHIELD: { name: 'Orbital Shield', desc: 'Rotating bullets', icon: 'üîò', apply: (g, s) => { g.orbitals=(g.orbitals||0)+s;g.orbitalTimer=3;}},
        LASER_GRID: { name: 'Laser Grid', desc: 'Cross lasers', icon: '‚ûï', apply: (g, s) => { g.visualEffects.push({type:'lasergrid',x:g.player.x,y:g.player.y,timer:0.3});g.enemies.forEach(e=>{if(Math.abs(e.x-g.player.x)<10||Math.abs(e.y-g.player.y)<10){e.hp-=s;}});}},
        REPEL: { name: 'Repel', desc: 'Push bullets away', icon: 'üîÉ', apply: (g, s) => { g.enemyBullets.forEach(b=>{const d=Math.hypot(b.x-g.player.x,b.y-g.player.y);if(d<60&&d>0){b.vx+=(b.x-g.player.x)/d*2*s;b.vy+=(b.y-g.player.y)/d*2*s;}});}},
        PIERCING_VOLLEY: { name: 'Piercing Volley', desc: 'Shots pierce enemies', icon: 'üìå', apply: (g, s) => { const a = Math.atan2(g.player.vy||0.1, g.player.vx||0.1); const count = 2 + Math.min(6, s); for(let i=0;i<count;i++){ const sp=(i-(count-1)/2)*0.18; g.playerBullets.push({x:g.player.x,y:g.player.y,vx:Math.cos(a+sp)*CONFIG.BULLET_SPEED,vy:Math.sin(a+sp)*CONFIG.BULLET_SPEED,size:4,damage:1, pierce: 1 + Math.floor(s/2)}); } g.visualEffects.push({type:'shockwave',x:g.player.x,y:g.player.y,radius:55+s*10,timer:0.25,color:'#fff'}); }},
        FROST_NOVA: { name: 'Frost Nova', desc: 'Freeze + burst damage', icon: 'üßä', apply: (g, s) => { const r=60+s*12; g.enemies.forEach(e=>{ const d=Math.hypot(e.x-g.player.x,e.y-g.player.y); if(d<r){ e.hp-=1; e.frozen=(e.frozen||0)+0.7+s*0.15; g.spawnHitEffect(e.x,e.y,'#aef'); } }); g.visualEffects.push({type:'burst',x:g.player.x,y:g.player.y,radius:r,timer:0.25,color:'#aef'}); }},
        XP_BOMB: { name: 'XP Bomb', desc: 'XP pickups explode briefly', icon: 'üí†', apply: (g, s) => { g.xpBombTimer = Math.max(g.xpBombTimer||0, 2 + s*0.4); g.visualEffects.push({type:'shield',x:g.player.x,y:g.player.y,radius:35+s*8,timer:0.2,color:'#0ff'}); }},
        CLONE_ATTACK: { name: 'Clone Attack', desc: 'Shadow clone hits', icon: 'üë§', apply: (g, s) => { const near=g.enemies.filter(e=>!e.dead).sort((a,b)=>Math.hypot(a.x-g.player.x,a.y-g.player.y)-Math.hypot(b.x-g.player.x,b.y-g.player.y))[0];if(near){near.hp-=s;g.visualEffects.push({type:'clone',x:near.x,y:near.y,timer:0.2});}}}
    };
    
    // ========== 42 MUTATORS ==========
    const MUTATORS = {
        BOUNCY_BULLETS: { name: 'Bouncy Bullets', desc: 'Bullets bounce once', color: '#f80', icon: 'üèÄ', apply: g => g.rules.bouncyBullets=true },
        ROTATING_SCREEN: { name: 'Vertigo', desc: 'Screen rotates', color: '#f0f', icon: 'üåÄ', apply: g => g.rules.rotatingScreen=true },
        ENEMY_TRAILS: { name: 'Slime Trail', desc: 'Enemies leave trails', color: '#0f0', icon: 'üü¢', apply: g => g.rules.enemyTrails=true },
        DEATH_SLOW: { name: 'Last Chance', desc: 'Time slows near bullets', color: '#0ff', icon: '‚è±Ô∏è', apply: g => g.rules.deathSlow=true },
        GRAVITY_BULLETS: { name: 'Heavy Rounds', desc: 'Bullets have gravity', color: '#88f', icon: '‚¨áÔ∏è', apply: g => g.rules.gravityBullets=true },
        ELITE_HUNTERS: { name: 'Elite Hunters', desc: 'Kill streaks spawn elites', color: '#f00', icon: 'üëπ', apply: g => g.rules.eliteHunters=true },
        SHRINKING_ARENA: { name: 'Closing In', desc: 'Arena shrinks', color: '#ff0', icon: 'üì¶', apply: g => g.rules.shrinkingArena=true },
        BULLET_HELL: { name: 'Bullet Hell', desc: 'More enemy shots', color: '#f08', icon: 'üî•', apply: g => g.rules.bulletHell=true },
        SPEED_DEMON: { name: 'Speed Demon', desc: 'Everything faster', color: '#8f0', icon: 'üí®', apply: g => g.rules.speedDemon=true },
        CHAOS_SPAWN: { name: 'Chaos Spawn', desc: 'Wave-based spawns', color: '#f0f', icon: 'üåä', apply: g => g.rules.chaosSpawn=true },
        MAGNETIC: { name: 'Magnetic', desc: 'XP auto-collects', color: '#ff0', icon: 'üß≤', apply: g => g.rules.magnetic=true },
        THUNDERSTORM: { name: 'Thunderstorm', desc: 'Random lightning strikes', color: '#0ff', icon: '‚ö°', apply: g => g.rules.thunderstorm=true },
        BLAZING_TRAIL: { name: 'Blazing Trail', desc: 'Player leaves fire trail', color: '#f80', icon: 'üî•', apply: g => g.rules.blazingTrail=true },
        FRAGILE_FOES: { name: 'Fragile Foes', desc: 'Enemies faster, less HP', color: '#ff44aa', icon: 'üß®', apply: g => g.rules.fragileFoes=true },
        ECHO: { name: 'Echo', desc: 'Bullets split on hit', color: '#0ff', icon: 'üîä', apply: g => g.rules.echo=true },
        MIRROR_MODE: { name: 'Mirror', desc: 'Controls reversed X', color: '#f0f', icon: 'ü™û', apply: g => g.rules.mirror=true },
        INVISIBLE_ENEMIES: { name: 'Invisible', desc: 'Enemies fade in/out', color: '#888', icon: 'üëª', apply: g => g.rules.invisibleEnemies=true },
        BULLET_TIME_ZONES: { name: 'Time Zones', desc: 'Slow zones appear', color: '#0af', icon: 'üïê', apply: g => g.rules.timeZones=true },
        PORTALS: { name: 'Portals', desc: 'Teleport around', color: '#a0f', icon: 'üåÄ', apply: g => g.rules.portals=true },
        GRAVITY_WELLS: { name: 'Gravity Wells', desc: 'Pull zones appear', color: '#808', icon: 'üï≥Ô∏è', apply: g => g.rules.gravityWells=true },
        WIND_CURRENTS: { name: 'Wind', desc: 'Push forces', color: '#8ff', icon: 'üå¨Ô∏è', apply: g => g.rules.wind=true },
        FOG_OF_WAR: { name: 'Fog', desc: 'Limited vision', color: '#444', icon: 'üå´Ô∏è', apply: g => g.rules.fog=true },
        SIZE_SHIFT: { name: 'Size Shift', desc: 'Player size changes', color: '#f80', icon: 'üìè', apply: g => g.rules.sizeShift=true },
        COLOR_CHAOS: { name: 'Color Chaos', desc: 'Colors shift', color: '#fff', icon: 'üé®', apply: g => g.rules.colorChaos=true },
        RHYTHM_MODE: { name: 'Rhythm', desc: 'Pulse to beat', color: '#f0f', icon: 'üéµ', apply: g => g.rules.rhythm=true },
        DOUBLE_SPEED: { name: 'Hyperspeed', desc: '2x speed', color: '#ff0', icon: '‚ö°', apply: g => g.rules.doubleSpeed=true },
        HALF_SPEED: { name: 'Slow-Mo', desc: '0.5x speed', color: '#88f', icon: 'üêå', apply: g => g.rules.halfSpeed=true },
        NO_WALLS: { name: 'No Walls', desc: 'Wrap around edges', color: '#0f0', icon: 'üîÑ', apply: g => g.rules.noWalls=true },
        MAZE_MODE: { name: 'Maze', desc: 'Obstacles appear', color: '#888', icon: 'üß±', apply: g => g.rules.maze=true },
        SPIRAL_SPAWN: { name: 'Spiral Spawn', desc: 'Spiral enemy pattern', color: '#f0f', icon: 'üåÄ', apply: g => g.rules.spiralSpawn=true },
        BOSS_WAVES: { name: 'Boss Waves', desc: 'Mini-bosses spawn', color: '#f00', icon: 'üëø', apply: g => g.rules.bossWaves=true },
        RICOCHET: { name: 'Ricochet', desc: 'Your bullets bounce', color: '#0ff', icon: '‚Ü©Ô∏è', apply: g => g.rules.ricochet=true },
        XP_DRAIN: { name: 'XP Drain', desc: 'XP decays over time', color: '#808', icon: 'üìâ', apply: g => g.rules.xpDrain=true },
        SCORE_DECAY: { name: 'Score Decay', desc: 'Score decreases', color: '#f44', icon: 'üìä', apply: g => g.rules.scoreDecay=true },
        COMBO_REQUIRED: { name: 'Combo Only', desc: 'Only combo kills count', color: '#ff0', icon: 'üîó', apply: g => g.rules.comboRequired=true },
        SWARM_MODE: { name: 'Swarm', desc: 'Many small enemies', color: '#f0f', icon: 'üêù', apply: g => g.rules.swarm=true },
        GIANT_ENEMIES: { name: 'Giants', desc: 'Bigger enemies', color: '#f80', icon: 'ü¶£', apply: g => g.rules.giantEnemies=true },
        TINY_ENEMIES: { name: 'Tiny', desc: 'Smaller enemies', color: '#0f8', icon: 'üêú', apply: g => g.rules.tinyEnemies=true },
        KALEIDOSCOPE: { name: 'Kaleidoscope', desc: 'Visual chaos', color: '#fff', icon: 'üîÆ', apply: g => g.rules.kaleidoscope=true },
        VAMPIRE: { name: 'Vampire', desc: 'Kills heal (visual)', color: '#800', icon: 'üßõ', apply: g => g.rules.vampire=true },
        GLASS_CANNON: { name: 'Glass Cannon', desc: '2x damage dealt', color: '#ff0', icon: 'üí™', apply: g => g.rules.glassCannon=true },
        PACIFIST_BONUS: { name: 'Pacifist', desc: 'Bonus for not killing', color: '#0f0', icon: '‚òÆÔ∏è', apply: g => g.rules.pacifist=true },
        MINEFIELD: { name: 'Minefield', desc: 'Mines everywhere', color: '#f80', icon: 'üí£', apply: g => g.rules.minefield=true },
        AFTERIMAGES: { name: 'Afterimages', desc: 'Ghost trail lingers', color: '#88f', icon: 'üë•', apply: g => g.rules.afterimages=true },
        OVERDRIVE: { name: 'Overdrive', desc: 'Fire rate boost', color: '#f0f', icon: 'üöÄ', apply: g => g.rules.overdrive=true }
    };
    
    // ========== EXPANDED ENEMY DNA ==========
    const ENEMY_DNA = {
        BODY: {
            SMALL: { size: 10, hp: 1, speed: 1.5, color: '#0f0', xp: 10, name: 'Scout', icon: 'üü¢' },
            MEDIUM: { size: 18, hp: 2, speed: 1, color: '#ff0', xp: 20, name: 'Drone', icon: 'üü°' },
            TANK: { size: 30, hp: 5, speed: 0.5, color: '#f80', xp: 50, name: 'Tank', icon: 'üü†' },
            SPLITTER: { size: 22, hp: 2, speed: 0.8, color: '#0ff', xp: 30, splits: true, name: 'Splitter', icon: 'üîµ' },
            SHIELDED: { size: 20, hp: 3, speed: 0.7, color: '#88f', xp: 40, shield: true, name: 'Guardian', icon: 'üü£' },
            SWARM: { size: 8, hp: 1, speed: 1.8, color: '#f0f', xp: 5, name: 'Swarm', icon: 'ü©∑' },
            TINY: { size: 6, hp: 1, speed: 2, color: '#8f8', xp: 3, name: 'Micro', icon: 'üîò' },
            GIANT: { size: 40, hp: 10, speed: 0.3, color: '#a00', xp: 100, name: 'Titan', icon: 'üî¥' },
            MORPHING: { size: 15, hp: 2, speed: 1.2, color: '#f0f', xp: 25, morph: true, name: 'Shifter', icon: 'üí†' },
            INVISIBLE: { size: 14, hp: 1, speed: 1.3, color: '#4448', xp: 35, invisible: true, name: 'Phantom', icon: 'üëª' },
            PHASING: { size: 16, hp: 2, speed: 1, color: '#80f', xp: 30, phasing: true, name: 'Phaser', icon: '‚ú®' },
            ARMORED: { size: 24, hp: 8, speed: 0.4, color: '#666', xp: 60, armor: 2, name: 'Armored', icon: 'üõ°Ô∏è' },
            REGEN: { size: 20, hp: 4, speed: 0.6, color: '#0a0', xp: 45, regen: true, name: 'Regen', icon: 'üíö' }
        },
        MOVEMENT: {
            STRAIGHT: { fn: (e,p) => { const d=Math.hypot(p.x-e.x,p.y-e.y)||1;e.vx=(p.x-e.x)/d*e.speed*CONFIG.ENEMY_BASE_SPEED;e.vy=(p.y-e.y)/d*e.speed*CONFIG.ENEMY_BASE_SPEED;}, name: 'Chase', icon: '‚û°Ô∏è' },
            ZIGZAG: { fn: (e,p) => { const d=Math.hypot(p.x-e.x,p.y-e.y)||1;const a=Math.atan2(p.y-e.y,p.x-e.x)+Math.sin(e.moveTimer*5)*0.8;e.vx=Math.cos(a)*e.speed*CONFIG.ENEMY_BASE_SPEED;e.vy=Math.sin(a)*e.speed*CONFIG.ENEMY_BASE_SPEED;}, name: 'Zigzag', icon: '„Ä∞Ô∏è' },
            ORBIT: { fn: (e,p) => { const d=Math.hypot(p.x-e.x,p.y-e.y)||1;const a=Math.atan2(p.y-e.y,p.x-e.x)+(d>120?0:Math.PI/2);e.vx=Math.cos(a)*e.speed*CONFIG.ENEMY_BASE_SPEED;e.vy=Math.sin(a)*e.speed*CONFIG.ENEMY_BASE_SPEED;}, name: 'Orbit', icon: 'üîÑ' },
            CHARGE: { fn: (e,p,dt) => { if(!e.chargeState)e.chargeState='tracking';if(e.chargeState==='tracking'){e.chargeTimer=(e.chargeTimer||0)+dt;const d=Math.hypot(p.x-e.x,p.y-e.y)||1;e.vx=(p.x-e.x)/d*e.speed*CONFIG.ENEMY_BASE_SPEED*0.3;e.vy=(p.y-e.y)/d*e.speed*CONFIG.ENEMY_BASE_SPEED*0.3;e.chargeAngle=Math.atan2(p.y-e.y,p.x-e.x);if(e.chargeTimer>1.5){e.chargeState='charging';e.chargeTimer=0;}}else{e.vx=Math.cos(e.chargeAngle)*e.speed*CONFIG.ENEMY_BASE_SPEED*4;e.vy=Math.sin(e.chargeAngle)*e.speed*CONFIG.ENEMY_BASE_SPEED*4;e.chargeTimer+=dt;if(e.chargeTimer>0.5){e.chargeState='tracking';e.chargeTimer=0;}}}, name: 'Charge', icon: 'üèÉ' },
            TELEPORT: { fn: (e,p,dt) => { e.teleportTimer=(e.teleportTimer||0)+dt;if(e.teleportTimer>2){const a=Math.random()*Math.PI*2;e.x=p.x+Math.cos(a)*(50+Math.random()*100);e.y=p.y+Math.sin(a)*(50+Math.random()*100);e.teleportTimer=0;e.justTeleported=true;}const d=Math.hypot(p.x-e.x,p.y-e.y)||1;e.vx=(p.x-e.x)/d*e.speed*CONFIG.ENEMY_BASE_SPEED*0.5;e.vy=(p.y-e.y)/d*e.speed*CONFIG.ENEMY_BASE_SPEED*0.5;}, name: 'Teleport', icon: '‚ú®' },
            ERRATIC: { fn: (e,p,dt) => { e.erraticTimer=(e.erraticTimer||0)+dt;if(e.erraticTimer>0.3){e.erraticAngle=Math.random()*Math.PI*2;e.erraticTimer=0;}const a=Math.atan2(p.y-e.y,p.x-e.x)+(e.erraticAngle||0)*0.5;e.vx=Math.cos(a)*e.speed*CONFIG.ENEMY_BASE_SPEED*1.2;e.vy=Math.sin(a)*e.speed*CONFIG.ENEMY_BASE_SPEED*1.2;}, name: 'Erratic', icon: 'üé≤' },
            SPIRAL: { fn: (e,p,dt) => { e.spiralAngle=(e.spiralAngle||0)+dt*2;const d=Math.hypot(p.x-e.x,p.y-e.y)||1;const a=Math.atan2(p.y-e.y,p.x-e.x)+Math.sin(e.spiralAngle)*1;e.vx=Math.cos(a)*e.speed*CONFIG.ENEMY_BASE_SPEED;e.vy=Math.sin(a)*e.speed*CONFIG.ENEMY_BASE_SPEED;}, name: 'Spiral', icon: 'üåÄ' },
            BOUNCE: { fn: (e,p,dt) => { if(!e.bounceVx){const a=Math.atan2(p.y-e.y,p.x-e.x);e.bounceVx=Math.cos(a)*e.speed*CONFIG.ENEMY_BASE_SPEED;e.bounceVy=Math.sin(a)*e.speed*CONFIG.ENEMY_BASE_SPEED;}e.vx=e.bounceVx;e.vy=e.bounceVy;if(e.x<20||e.x>CONFIG.CANVAS_WIDTH-20)e.bounceVx*=-1;if(e.y<20||e.y>CONFIG.CANVAS_HEIGHT-20)e.bounceVy*=-1;}, name: 'Bounce', icon: '‚öæ' },
            FOLLOW_WALLS: { fn: (e,p,dt) => { e.wallDir=e.wallDir||1;const margin=30;if(e.x<margin){e.vx=e.speed*CONFIG.ENEMY_BASE_SPEED;e.vy=e.wallDir*e.speed*CONFIG.ENEMY_BASE_SPEED*0.5;}else if(e.x>CONFIG.CANVAS_WIDTH-margin){e.vx=-e.speed*CONFIG.ENEMY_BASE_SPEED;e.vy=-e.wallDir*e.speed*CONFIG.ENEMY_BASE_SPEED*0.5;}else if(e.y<margin){e.vy=e.speed*CONFIG.ENEMY_BASE_SPEED;e.vx=-e.wallDir*e.speed*CONFIG.ENEMY_BASE_SPEED*0.5;}else if(e.y>CONFIG.CANVAS_HEIGHT-margin){e.vy=-e.speed*CONFIG.ENEMY_BASE_SPEED;e.vx=e.wallDir*e.speed*CONFIG.ENEMY_BASE_SPEED*0.5;}else{const d=Math.hypot(p.x-e.x,p.y-e.y)||1;e.vx=(p.x-e.x)/d*e.speed*CONFIG.ENEMY_BASE_SPEED;e.vy=(p.y-e.y)/d*e.speed*CONFIG.ENEMY_BASE_SPEED;}}, name: 'Wall Crawler', icon: 'üß±' },
            DIAGONAL: { fn: (e,p) => { const dx=p.x>e.x?1:-1;const dy=p.y>e.y?1:-1;e.vx=dx*e.speed*CONFIG.ENEMY_BASE_SPEED*0.7;e.vy=dy*e.speed*CONFIG.ENEMY_BASE_SPEED*0.7;}, name: 'Diagonal', icon: '‚ÜóÔ∏è' },
            BLINK: { fn: (e,p,dt) => { e.blinkTimer=(e.blinkTimer||0)+dt;if(e.blinkTimer>1){e.x+=(p.x-e.x)*0.3;e.y+=(p.y-e.y)*0.3;e.blinkTimer=0;e.justTeleported=true;}e.vx=0;e.vy=0;}, name: 'Blink', icon: 'üëÅÔ∏è' },
            DASH: { fn: (e,p,dt) => { e.dashTimer=(e.dashTimer||0)+dt;if(e.dashTimer<0.2){e.vx=e.dashVx||0;e.vy=e.dashVy||0;}else if(e.dashTimer>1.5){const a=Math.atan2(p.y-e.y,p.x-e.x);e.dashVx=Math.cos(a)*e.speed*CONFIG.ENEMY_BASE_SPEED*5;e.dashVy=Math.sin(a)*e.speed*CONFIG.ENEMY_BASE_SPEED*5;e.dashTimer=0;}else{e.vx=0;e.vy=0;}}, name: 'Dash', icon: 'üí®' }
        },
        ATTACK: {
            NONE: { cooldown: 9999, fire: () => [], name: 'None', icon: '‚ûñ' },
            BULLET_SPRAY: { cooldown: 1.5, name: 'Spray', icon: 'üî´', fire: (e,p,g) => { const b=[];const c=5;const sp=Math.PI/3;const ba=Math.atan2(p.y-e.y,p.x-e.x);for(let i=0;i<c;i++){const a=ba-sp/2+(sp*i/(c-1));b.push({x:e.x,y:e.y,vx:Math.cos(a)*5,vy:Math.sin(a)*5,size:5,color:'#f00'});}return b;}},
            BURST: { cooldown: 2, name: 'Burst', icon: 'üí®', fire: (e,p,g) => { const a=Math.atan2(p.y-e.y,p.x-e.x);for(let i=0;i<3;i++){setTimeout(()=>{if(e.dead)return;g.enemyBullets.push({x:e.x,y:e.y,vx:Math.cos(a)*6,vy:Math.sin(a)*6,size:6,color:'#ff0'});},i*100);}return [];}},
            LASER: { cooldown: 3, name: 'Laser', icon: 'üî¥', fire: (e,p,g) => { e.laserWarning=true;e.laserAngle=Math.atan2(p.y-e.y,p.x-e.x);setTimeout(()=>{if(e.dead)return;e.laserWarning=false;e.laserActive=true;setTimeout(()=>{e.laserActive=false;},300);},500);return [];}},
            MINES: { cooldown: 2.5, name: 'Mines', icon: 'üí£', fire: (e,p,g) => { g.hazards.push({x:e.x,y:e.y,size:12,color:'#f80',type:'mine',timer:3});return [];}},
            HOMING: { cooldown: 2.5, name: 'Homing', icon: 'üéØ', fire: (e,p,g) => [{ x:e.x,y:e.y,vx:0,vy:0,size:8,color:'#f0f',homing:true,speed:3,life:5 }]},
            MELEE_DASH: { cooldown: 2, name: 'Dash', icon: '‚öîÔ∏è', fire: (e,p,g) => { e.dashAngle=Math.atan2(p.y-e.y,p.x-e.x);e.dashing=true;e.dashTimer=0.3;return [];}},
            SHOTGUN: { cooldown: 2, name: 'Shotgun', icon: 'üí•', fire: (e,p,g) => { const b=[];const a=Math.atan2(p.y-e.y,p.x-e.x);for(let i=0;i<8;i++){const sp=(Math.random()-0.5)*0.8;b.push({x:e.x,y:e.y,vx:Math.cos(a+sp)*(4+Math.random()*2),vy:Math.sin(a+sp)*(4+Math.random()*2),size:4,color:'#f80'});}return b;}},
            SNIPER: { cooldown: 3, name: 'Sniper', icon: 'üî≠', fire: (e,p,g) => { const a=Math.atan2(p.y-e.y,p.x-e.x);return [{x:e.x,y:e.y,vx:Math.cos(a)*12,vy:Math.sin(a)*12,size:4,color:'#f00'}];}},
            FLAMETHROWER: { cooldown: 0.1, name: 'Flame', icon: 'üî•', fire: (e,p,g) => { const a=Math.atan2(p.y-e.y,p.x-e.x)+(Math.random()-0.5)*0.5;return [{x:e.x,y:e.y,vx:Math.cos(a)*3,vy:Math.sin(a)*3,size:6,color:'#f80',life:1}];}},
            MISSILE: { cooldown: 3, name: 'Missile', icon: 'üöÄ', fire: (e,p,g) => [{ x:e.x,y:e.y,vx:0,vy:-2,size:10,color:'#f44',homing:true,speed:4,life:4 }]},
            BOOMERANG: { cooldown: 2.5, name: 'Boomerang', icon: 'ü™É', fire: (e,p,g) => { const a=Math.atan2(p.y-e.y,p.x-e.x);return [{x:e.x,y:e.y,vx:Math.cos(a)*8,vy:Math.sin(a)*8,size:8,color:'#0ff',boomerang:true,origin:{x:e.x,y:e.y},life:3}];}},
            TURRET_SPAWN: { cooldown: 5, name: 'Turret', icon: 'üóº', fire: (e,p,g) => { g.enemies.push({x:e.x,y:e.y,vx:0,vy:0,size:12,hp:2,speed:0,dna:{body:{...ENEMY_DNA.BODY.SMALL,type:'TURRET'},movement:'NONE',attack:'BULLET_SPRAY',modifier:'NONE'},dead:false,moveTimer:0,isTurret:true});return [];}}
        },
        MODIFIER: {
            NONE: { onSpawn:()=>{}, onUpdate:()=>{}, onDeath:()=>{}, name: 'None', icon: '‚ûñ' },
            EXPLODE: { name: 'Explode', icon: 'üí•', onSpawn:()=>{}, onUpdate:()=>{}, onDeath:(e,g)=>{for(let i=0;i<8;i++){const a=(Math.PI*2/8)*i;g.enemyBullets.push({x:e.x,y:e.y,vx:Math.cos(a)*4,vy:Math.sin(a)*4,size:5,color:'#f80'});}}},
            TRAIL: { name: 'Trail', icon: 'üü¢', onSpawn:()=>{}, onUpdate:(e,dt,g)=>{e.trailTimer=(e.trailTimer||0)+dt;if(e.trailTimer>0.2){g.hazards.push({x:e.x,y:e.y,size:8,color:'#0f08',type:'trail',timer:2});e.trailTimer=0;}}, onDeath:()=>{}},
            BUFF: { name: 'Aura', icon: '‚ú®', onSpawn:()=>{}, onUpdate:(e,dt,g)=>{g.enemies.forEach(o=>{if(o!==e&&!o.dead){const d=Math.hypot(o.x-e.x,o.y-e.y);if(d<80)o.buffed=true;}});}, onDeath:()=>{}},
            SPAWN_HAZARD: { name: 'Spawner', icon: 'üåÄ', onSpawn:()=>{}, onUpdate:(e,dt,g)=>{e.hazardTimer=(e.hazardTimer||0)+dt;if(e.hazardTimer>3){g.hazards.push({x:e.x+(Math.random()-0.5)*60,y:e.y+(Math.random()-0.5)*60,size:20,color:'#f008',type:'zone',timer:4});e.hazardTimer=0;}}, onDeath:()=>{}},
            SCREEN_EFFECT: { name: 'Distort', icon: 'üëÅÔ∏è', onSpawn:()=>{}, onUpdate:(e,dt,g)=>{const d=Math.hypot(g.player.x-e.x,g.player.y-e.y);if(d<100)g.screenEffects.distort=Math.max(g.screenEffects.distort||0,1-d/100);}, onDeath:()=>{}},
            ARENA_CHANGE: { name: 'Shrinker', icon: 'üì¶', onSpawn:()=>{}, onUpdate:()=>{}, onDeath:(e,g)=>{g.arena.shrinkAmount+=10;}},
            STEALTH: { name: 'Stealth', icon: 'ü•∑', onSpawn:(e)=>{e.stealth=true;}, onUpdate:(e,dt,g)=>{e.stealthTimer=(e.stealthTimer||0)+dt;e.visible=e.stealthTimer%2<1;}, onDeath:()=>{}},
            RAGE: { name: 'Rage', icon: 'üò°', onSpawn:()=>{}, onUpdate:(e,dt,g)=>{if(e.hp<=1&&!e.raged){e.raged=true;e.speed*=2;e.dna.body.color='#f00';}}, onDeath:()=>{}},
            SHIELD_REGEN: { name: 'Regen Shield', icon: 'üõ°Ô∏è', onSpawn:(e)=>{e.maxHp=e.hp;}, onUpdate:(e,dt,g)=>{e.regenTimer=(e.regenTimer||0)+dt;if(e.regenTimer>3&&e.hp<e.maxHp){e.hp++;e.regenTimer=0;}}, onDeath:()=>{}},
            SUMMON: { name: 'Summoner', icon: 'üì£', onSpawn:()=>{}, onUpdate:(e,dt,g)=>{e.summonTimer=(e.summonTimer||0)+dt;if(e.summonTimer>5&&g.enemies.length<20){g.spawnEnemy(e.x+(Math.random()-0.5)*50,e.y+(Math.random()-0.5)*50,'SMALL');e.summonTimer=0;}}, onDeath:()=>{}},
            CURSE: { name: 'Curse', icon: 'üíÄ', onSpawn:()=>{}, onUpdate:(e,dt,g)=>{const d=Math.hypot(g.player.x-e.x,g.player.y-e.y);if(d<60)g.player.cursed=true;}, onDeath:()=>{}},
            SLOW_AURA: { name: 'Slow Aura', icon: 'üêå', onSpawn:()=>{}, onUpdate:(e,dt,g)=>{const d=Math.hypot(g.player.x-e.x,g.player.y-e.y);if(d<80)g.player.slowed=0.5;}, onDeath:()=>{}}
        }
    };
    
    // ========== 100+ ACHIEVEMENTS ==========
    const ACHIEVEMENTS = {
        // Score
        SCORE_1K: { name: 'Getting Started', desc: 'Score 1,000 points', icon: '‚≠ê', category: 'score', check: m => m.bestScore >= 1000, xp: 100 },
        SCORE_3K: { name: 'Rising Star', desc: 'Score 3,000 points', icon: '‚≠ê', category: 'score', check: m => m.bestScore >= 3000, xp: 200 },
        SCORE_5K: { name: 'Skilled Player', desc: 'Score 5,000 points', icon: '‚≠ê', category: 'score', check: m => m.bestScore >= 5000, xp: 300 },
        SCORE_10K: { name: 'Expert', desc: 'Score 10,000 points', icon: 'üåü', category: 'score', check: m => m.bestScore >= 10000, xp: 500 },
        SCORE_25K: { name: 'Master', desc: 'Score 25,000 points', icon: 'üåü', category: 'score', check: m => m.bestScore >= 25000, xp: 1000 },
        SCORE_50K: { name: 'Grandmaster', desc: 'Score 50,000 points', icon: 'üí´', category: 'score', check: m => m.bestScore >= 50000, xp: 2000 },
        SCORE_100K: { name: 'Legendary', desc: 'Score 100,000 points', icon: 'üí´', category: 'score', check: m => m.bestScore >= 100000, xp: 5000 },
        SCORE_250K: { name: 'Mythic Score', desc: 'Score 250,000 points', icon: 'üèÜ', category: 'score', check: m => m.bestScore >= 250000, xp: 10000 },
        SCORE_500K: { name: 'Impossible', desc: 'Score 500,000 points', icon: 'üèÜ', category: 'score', check: m => m.bestScore >= 500000, xp: 25000 },
        SCORE_1M: { name: 'Transcendent', desc: 'Score 1,000,000 points', icon: 'üëë', category: 'score', check: m => m.bestScore >= 1000000, xp: 50000 },
        TOTAL_SCORE_100K: { name: 'Accumulator', desc: '100K total score', icon: 'üìä', category: 'score', check: m => m.totalScore >= 100000, xp: 500 },
        TOTAL_SCORE_1M: { name: 'Score Hoarder', desc: '1M total score', icon: 'üìä', category: 'score', check: m => m.totalScore >= 1000000, xp: 2000 },
        
        // Survival
        SURVIVE_30S: { name: 'Warm Up', desc: 'Survive 30 seconds', icon: '‚è±Ô∏è', category: 'survival', check: m => m.bestTime >= 30, xp: 50 },
        SURVIVE_60S: { name: 'One Minute', desc: 'Survive 60 seconds', icon: '‚è±Ô∏è', category: 'survival', check: m => m.bestTime >= 60, xp: 100 },
        SURVIVE_90S: { name: 'Endurance', desc: 'Survive 90 seconds', icon: '‚è±Ô∏è', category: 'survival', check: m => m.bestTime >= 90, xp: 150 },
        SURVIVE_2M: { name: 'Survivor', desc: 'Survive 2 minutes', icon: 'üïê', category: 'survival', check: m => m.bestTime >= 120, xp: 200 },
        SURVIVE_3M: { name: 'Persistent', desc: 'Survive 3 minutes', icon: 'üïê', category: 'survival', check: m => m.bestTime >= 180, xp: 300 },
        SURVIVE_5M: { name: 'Unstoppable', desc: 'Survive 5 minutes', icon: 'üïë', category: 'survival', check: m => m.bestTime >= 300, xp: 500 },
        SURVIVE_10M: { name: 'Marathon', desc: 'Survive 10 minutes', icon: 'üïë', category: 'survival', check: m => m.bestTime >= 600, xp: 1000 },
        SURVIVE_15M: { name: 'Immortal', desc: 'Survive 15 minutes', icon: 'üïí', category: 'survival', check: m => m.bestTime >= 900, xp: 2000 },
        SURVIVE_30M: { name: 'Timeless', desc: 'Survive 30 minutes', icon: 'üïí', category: 'survival', check: m => m.bestTime >= 1800, xp: 5000 },
        TOTAL_TIME_1H: { name: '1 Hour Played', desc: 'Total 1 hour playtime', icon: '‚åõ', category: 'survival', check: m => m.totalPlaytime >= 3600, xp: 200 },
        TOTAL_TIME_10H: { name: '10 Hours Played', desc: 'Total 10 hours playtime', icon: '‚åõ', category: 'survival', check: m => m.totalPlaytime >= 36000, xp: 1000 },
        TOTAL_TIME_100H: { name: '100 Hours Played', desc: 'Total 100 hours playtime', icon: '‚åõ', category: 'survival', check: m => m.totalPlaytime >= 360000, xp: 5000 },
        
        // Kills
        KILL_50: { name: 'First Blood', desc: 'Kill 50 enemies', icon: 'üíÄ', category: 'kills', check: m => m.totalKills >= 50, xp: 50 },
        KILL_100: { name: 'Hunter', desc: 'Kill 100 enemies', icon: 'üíÄ', category: 'kills', check: m => m.totalKills >= 100, xp: 100 },
        KILL_250: { name: 'Slayer', desc: 'Kill 250 enemies', icon: 'üíÄ', category: 'kills', check: m => m.totalKills >= 250, xp: 150 },
        KILL_500: { name: 'Destroyer', desc: 'Kill 500 enemies', icon: '‚ò†Ô∏è', category: 'kills', check: m => m.totalKills >= 500, xp: 200 },
        KILL_1K: { name: 'Annihilator', desc: 'Kill 1,000 enemies', icon: '‚ò†Ô∏è', category: 'kills', check: m => m.totalKills >= 1000, xp: 300 },
        KILL_2500: { name: 'Executioner', desc: 'Kill 2,500 enemies', icon: '‚ò†Ô∏è', category: 'kills', check: m => m.totalKills >= 2500, xp: 500 },
        KILL_5K: { name: 'Reaper', desc: 'Kill 5,000 enemies', icon: '‚ö∞Ô∏è', category: 'kills', check: m => m.totalKills >= 5000, xp: 1000 },
        KILL_10K: { name: 'Genocide', desc: 'Kill 10,000 enemies', icon: '‚ö∞Ô∏è', category: 'kills', check: m => m.totalKills >= 10000, xp: 2000 },
        KILL_25K: { name: 'Extinction', desc: 'Kill 25,000 enemies', icon: 'üíÄ', category: 'kills', check: m => m.totalKills >= 25000, xp: 5000 },
        KILL_50K: { name: 'Apocalypse', desc: 'Kill 50,000 enemies', icon: 'üî•', category: 'kills', check: m => m.totalKills >= 50000, xp: 10000 },
        ELITE_KILL_5: { name: 'Elite Hunter', desc: 'Kill 5 elites', icon: 'üëë', category: 'kills', check: m => m.eliteKills >= 5, xp: 200 },
        ELITE_KILL_25: { name: 'Elite Slayer', desc: 'Kill 25 elites', icon: 'üëë', category: 'kills', check: m => m.eliteKills >= 25, xp: 500 },
        ELITE_KILL_100: { name: 'Elite Destroyer', desc: 'Kill 100 elites', icon: 'üëë', category: 'kills', check: m => m.eliteKills >= 100, xp: 1000 },
        
        // Skill
        NEAR_MISS_25: { name: 'Close Call', desc: '25 near misses', icon: 'üòÖ', category: 'skill', check: m => m.totalNearMisses >= 25, xp: 100 },
        NEAR_MISS_100: { name: 'Daredevil', desc: '100 near misses', icon: 'üòÖ', category: 'skill', check: m => m.totalNearMisses >= 100, xp: 200 },
        NEAR_MISS_500: { name: 'Risk Taker', desc: '500 near misses', icon: 'üòé', category: 'skill', check: m => m.totalNearMisses >= 500, xp: 500 },
        NEAR_MISS_10_RUN: { name: 'Dodger', desc: '10 near misses in one run', icon: 'üèÉ', category: 'skill', check: m => m.bestNearMisses >= 10, xp: 150 },
        NEAR_MISS_25_RUN: { name: 'Matrix', desc: '25 near misses in one run', icon: 'üèÉ', category: 'skill', check: m => m.bestNearMisses >= 25, xp: 300 },
        NEAR_MISS_50_RUN: { name: 'Untouchable', desc: '50 near misses in one run', icon: 'üèÉ', category: 'skill', check: m => m.bestNearMisses >= 50, xp: 500 },
        COMBO_5: { name: 'Combo Starter', desc: 'Get 5x combo', icon: 'üîó', category: 'skill', check: m => m.bestCombo >= 5, xp: 100 },
        COMBO_10: { name: 'Combo King', desc: 'Get 10x combo', icon: '‚õìÔ∏è', category: 'skill', check: m => m.bestCombo >= 10, xp: 200 },
        COMBO_25: { name: 'Combo Master', desc: 'Get 25x combo', icon: '‚õìÔ∏è', category: 'skill', check: m => m.bestCombo >= 25, xp: 500 },
        COMBO_50: { name: 'Combo God', desc: 'Get 50x combo', icon: 'üî•', category: 'skill', check: m => m.bestCombo >= 50, xp: 1000 },
        NO_DAMAGE_30S: { name: 'Untouched', desc: 'No damage for 30s', icon: '‚ú®', category: 'skill', check: m => m.bestNoDamageStreak >= 30, xp: 300 },
        NO_DAMAGE_60S: { name: 'Invincible', desc: 'No damage for 60s', icon: '‚ú®', category: 'skill', check: m => m.bestNoDamageStreak >= 60, xp: 500 },
        LEVEL_10: { name: 'Level 10', desc: 'Reach level 10', icon: 'üìà', category: 'skill', check: m => m.bestLevel >= 10, xp: 200 },
        LEVEL_20: { name: 'Level 20', desc: 'Reach level 20', icon: 'üìà', category: 'skill', check: m => m.bestLevel >= 20, xp: 500 },
        LEVEL_30: { name: 'Level 30', desc: 'Reach level 30', icon: 'üìà', category: 'skill', check: m => m.bestLevel >= 30, xp: 1000 },
        KILL_100_RUN: { name: 'Massacre', desc: '100 kills in one run', icon: 'üíÄ', category: 'skill', check: m => m.bestKillsInRun >= 100, xp: 300 },
        KILL_250_RUN: { name: 'Rampage', desc: '250 kills in one run', icon: 'üî•', category: 'skill', check: m => m.bestKillsInRun >= 250, xp: 500 },
        
        // Collection
        SKINS_10: { name: 'Collector', desc: 'Unlock 10 skins', icon: 'üé≠', category: 'collection', check: m => m.unlocks.skins.length >= 10, xp: 200 },
        SKINS_25: { name: 'Fashionista', desc: 'Unlock 25 skins', icon: 'üé≠', category: 'collection', check: m => m.unlocks.skins.length >= 25, xp: 500 },
        SKINS_50: { name: 'Completionist', desc: 'Unlock 50 skins', icon: 'üé≠', category: 'collection', check: m => m.unlocks.skins.length >= 50, xp: 1000 },
        TRIGGERS_ALL: { name: 'Trigger Happy', desc: 'Unlock all triggers', icon: 'üéØ', category: 'collection', check: m => m.unlocks.triggers.length >= Object.keys(UPGRADE_TRIGGERS).length, xp: 500 },
        EFFECTS_ALL: { name: 'Effectual', desc: 'Unlock all effects', icon: '‚ú®', category: 'collection', check: m => m.unlocks.effects.length >= Object.keys(UPGRADE_EFFECTS).length, xp: 500 },
        MUTATORS_20: { name: 'Mutant', desc: 'Unlock 20 mutators', icon: 'üé≤', category: 'collection', check: m => m.unlocks.mutators.length >= 20, xp: 300 },
        MUTATORS_ALL: { name: 'Chaos Master', desc: 'Unlock all mutators', icon: 'üé≤', category: 'collection', check: m => m.unlocks.mutators.length >= Object.keys(MUTATORS).length, xp: 1000 },
        RARE_SKIN: { name: 'Rare Find', desc: 'Unlock a rare skin', icon: 'üíé', category: 'collection', check: m => m.unlocks.skins.some(s => PLAYER_SKINS[s]?.rarity === 'rare'), xp: 200 },
        EPIC_SKIN: { name: 'Epic Discovery', desc: 'Unlock an epic skin', icon: 'üíú', category: 'collection', check: m => m.unlocks.skins.some(s => PLAYER_SKINS[s]?.rarity === 'epic'), xp: 500 },
        LEGENDARY_SKIN: { name: 'Legendary!', desc: 'Unlock a legendary skin', icon: 'üß°', category: 'collection', check: m => m.unlocks.skins.some(s => PLAYER_SKINS[s]?.rarity === 'legendary'), xp: 1000 },
        MYTHIC_SKIN: { name: 'Mythic!', desc: 'Unlock a mythic skin', icon: 'üíñ', category: 'collection', check: m => m.unlocks.skins.some(s => PLAYER_SKINS[s]?.rarity === 'mythic'), xp: 2000 },
        
        // Special
        QUICK_DEATH: { name: 'Speedrun Death', desc: 'Die within 5 seconds', icon: 'üí®', category: 'special', check: m => m.fastestDeath <= 5 && m.fastestDeath > 0, xp: 50 },
        STILL_SURVIVE: { name: 'Zen Master', desc: 'Survive 60s barely moving', icon: 'üßò', category: 'special', check: m => m.stillSurvival >= 60, xp: 500 },
        RUNS_100: { name: 'Dedicated', desc: 'Complete 100 runs', icon: 'üîÑ', category: 'special', check: m => m.totalRuns >= 100, xp: 500 },
        RUNS_500: { name: 'Veteran', desc: 'Complete 500 runs', icon: 'üîÑ', category: 'special', check: m => m.totalRuns >= 500, xp: 1000 },
        RUNS_1000: { name: 'Addict', desc: 'Complete 1000 runs', icon: 'üîÑ', category: 'special', check: m => m.totalRuns >= 1000, xp: 2000 },
        PRESTIGE_1: { name: 'Prestige', desc: 'Prestige once', icon: 'üåü', category: 'special', check: m => m.prestige >= 1, xp: 5000 },
        PRESTIGE_5: { name: 'Prestige V', desc: 'Prestige 5 times', icon: '‚≠ê', category: 'special', check: m => m.prestige >= 5, xp: 10000 },
        DAILY_5: { name: 'Daily Player', desc: 'Complete 5 daily challenges', icon: 'üìÖ', category: 'special', check: m => m.dailiesCompleted >= 5, xp: 300 },
        WEEKLY_3: { name: 'Weekly Warrior', desc: 'Complete 3 weekly challenges', icon: 'üìÜ', category: 'special', check: m => m.weekliesCompleted >= 3, xp: 500 },
        MISSIONS_50: { name: 'Mission Master', desc: 'Complete 50 missions', icon: 'üìã', category: 'special', check: m => m.missionsCompleted >= 50, xp: 500 },
        ACCOUNT_25: { name: 'Account Level 25', desc: 'Reach account level 25', icon: 'üìä', category: 'special', check: m => m.accountLevel >= 25, xp: 500 },
        ACCOUNT_50: { name: 'Account Level 50', desc: 'Reach account level 50', icon: 'üìä', category: 'special', check: m => m.accountLevel >= 50, xp: 1000 },
        ACCOUNT_100: { name: 'Account Level 100', desc: 'Reach account level 100', icon: 'üìä', category: 'special', check: m => m.accountLevel >= 100, xp: 2000 }
    };
    
    // ========== GAME MODES ==========
    const GAME_MODES = {
        ENDLESS: { name: 'Endless', desc: 'Standard mode', icon: '‚ôæÔ∏è', unlocked: true },
        TIME_ATTACK: { name: 'Time Attack', desc: '60s max score', icon: '‚è±Ô∏è', requirement: '10 runs', check: m => m.totalRuns >= 10 },
        SCORE_ATTACK: { name: 'Score Attack', desc: 'Fixed time', icon: 'üéØ', requirement: 'Score 5000', check: m => m.bestScore >= 5000 },
        BOSS_RUSH: { name: 'Boss Rush', desc: 'Elites only', icon: 'üëø', requirement: '25 elite kills', check: m => m.eliteKills >= 25 },
        CHAOS: { name: 'Chaos Mode', desc: 'All mutators', icon: 'üåÄ', requirement: '20 mutators unlocked', check: m => m.unlocks.mutators.length >= 20 },
        MINIMALIST: { name: 'Minimalist', desc: 'No upgrades', icon: 'üì¶', requirement: 'Level 15', check: m => m.bestLevel >= 15 },
        SANDBOX: { name: 'Sandbox', desc: 'Practice mode', icon: 'üß™', requirement: 'Account level 10', check: m => m.accountLevel >= 10 }
    };
    
    // ========== META PROGRESSION ==========
    const META = {
        load() {
            try {
                const data = localStorage.getItem('1hp_chaos_meta_v3');
                return data ? JSON.parse(data) : this.getDefault();
            } catch(e) { return this.getDefault(); }
        },
        save(data) {
            try { localStorage.setItem('1hp_chaos_meta_v3', JSON.stringify(data)); } catch(e) {}
        },
        getDefault() {
            return {
                totalRuns: 0, bestScore: 0, bestTime: 0, bestLevel: 1, totalKills: 0,
                totalScore: 0, totalPlaytime: 0, totalNearMisses: 0, bestNearMisses: 0,
                bestCombo: 0, bestNoDamageStreak: 0, bestKillsInRun: 0, eliteKills: 0,
                fastestDeath: 999, stillSurvival: 0, accountLevel: 1, accountXp: 0,
                prestige: 0, prestigeCurrency: 0, dailiesCompleted: 0, weekliesCompleted: 0,
                missionsCompleted: 0, lastDaily: null, lastWeekly: null,
                selectedSkin: 'DIAMOND', selectedMode: 'ENDLESS',
                settings: { musicVolume: 30, sfxVolume: 60, screenShake: true, visualEffects: true, showTrail: true, quickRestart: false },
                unlocks: {
                    skins: ['DIAMOND'],
                    triggers: ['ON_KILL', 'ON_NEAR_MISS'],
                    effects: ['PROJECTILE', 'SHOCKWAVE', 'REPEL', 'FROST_NOVA', 'PIERCING_VOLLEY', 'XP_BOMB'],
                    mutators: ['BOUNCY_BULLETS', 'ENEMY_TRAILS', 'MAGNETIC', 'THUNDERSTORM', 'BLAZING_TRAIL'],
                    bodies: ['SMALL', 'MEDIUM'],
                    movements: ['STRAIGHT', 'ZIGZAG'],
                    attacks: ['NONE', 'BULLET_SPRAY'],
                    modifiers: ['NONE', 'EXPLODE'],
                    achievements: [],
                    modes: ['ENDLESS']
                },
                missions: [],
                codex: { enemies: {}, upgrades: {}, mutators: {} },
                dailyChallenge: null, weeklyChallenge: null,
                streak: 0, lastPlayDate: null
            };
        },
        addAccountXp(data, amount) {
            data.accountXp += amount;
            while (data.accountXp >= CONFIG.ACCOUNT_XP_PER_LEVEL * (1 + data.accountLevel * 0.1)) {
                data.accountXp -= CONFIG.ACCOUNT_XP_PER_LEVEL * (1 + data.accountLevel * 0.1);
                data.accountLevel++;
            }
        },
        checkAllUnlocks(data) {
            const newUnlocks = [];
            
            // Check skin unlocks
            Object.keys(PLAYER_SKINS).forEach(key => {
                const skin = PLAYER_SKINS[key];
                if (!data.unlocks.skins.includes(key) && skin.check && skin.check(data)) {
                    data.unlocks.skins.push(key);
                    newUnlocks.push(`${skin.name} Skin (${skin.rarity})`);
                }
            });
            
            // Check achievement unlocks
            Object.keys(ACHIEVEMENTS).forEach(key => {
                if (!data.unlocks.achievements.includes(key) && ACHIEVEMENTS[key].check(data)) {
                    data.unlocks.achievements.push(key);
                    newUnlocks.push(`üèÜ ${ACHIEVEMENTS[key].name}`);
                    this.addAccountXp(data, ACHIEVEMENTS[key].xp);
                }
            });
            
            // Trigger unlocks based on progression
            const u = data.unlocks;
            if (data.bestScore >= 500 && !u.triggers.includes('ON_MOVE')) { u.triggers.push('ON_MOVE'); newUnlocks.push('On Move Trigger'); }
            if (data.bestScore >= 1000 && !u.effects.includes('AREA_BURST')) { u.effects.push('AREA_BURST'); newUnlocks.push('Area Burst'); }
            if (data.bestScore >= 2000 && !u.triggers.includes('ON_MULTI_KILL')) { u.triggers.push('ON_MULTI_KILL'); newUnlocks.push('Multi-Kill Trigger'); }
            if (data.bestScore >= 3000 && !u.effects.includes('CHAIN_LIGHTNING')) { u.effects.push('CHAIN_LIGHTNING'); newUnlocks.push('Chain Lightning'); }
            if (data.bestScore >= 5000 && !u.effects.includes('CONVERT')) { u.effects.push('CONVERT'); newUnlocks.push('Convert'); }
            if (data.bestScore >= 7500 && !u.triggers.includes('ON_DASH')) { u.triggers.push('ON_DASH'); newUnlocks.push('On Dash Trigger'); }
            if (data.bestScore >= 10000 && !u.effects.includes('BLACK_HOLE')) { u.effects.push('BLACK_HOLE'); newUnlocks.push('Black Hole'); }
            
            if (data.bestTime >= 30 && !u.triggers.includes('ON_STOP')) { u.triggers.push('ON_STOP'); newUnlocks.push('On Stop Trigger'); }
            if (data.bestTime >= 60 && !u.effects.includes('TIME_SLOW')) { u.effects.push('TIME_SLOW'); newUnlocks.push('Time Slow'); }
            if (data.bestTime >= 90 && !u.mutators.includes('DEATH_SLOW')) { u.mutators.push('DEATH_SLOW'); newUnlocks.push('Last Chance Mutator'); }
            if (data.bestTime >= 120 && !u.triggers.includes('ON_STREAK')) { u.triggers.push('ON_STREAK'); newUnlocks.push('Streak Trigger'); }
            if (data.bestTime >= 180 && !u.effects.includes('FREEZE_RAY')) { u.effects.push('FREEZE_RAY'); newUnlocks.push('Freeze Ray'); }
            
            if (data.totalKills >= 50 && !u.bodies.includes('TANK')) { u.bodies.push('TANK'); newUnlocks.push('Tank Enemy'); }
            if (data.totalKills >= 100 && !u.movements.includes('CHARGE')) { u.movements.push('CHARGE'); newUnlocks.push('Charge Movement'); }
            if (data.totalKills >= 200 && !u.bodies.includes('SPLITTER')) { u.bodies.push('SPLITTER'); newUnlocks.push('Splitter Enemy'); }
            if (data.totalKills >= 300 && !u.attacks.includes('BURST')) { u.attacks.push('BURST'); newUnlocks.push('Burst Attack'); }
            if (data.totalKills >= 500 && !u.bodies.includes('SHIELDED')) { u.bodies.push('SHIELDED'); newUnlocks.push('Shielded Enemy'); }
            if (data.totalKills >= 750 && !u.modifiers.includes('TRAIL')) { u.modifiers.push('TRAIL'); newUnlocks.push('Trail Modifier'); }
            if (data.totalKills >= 1000 && !u.bodies.includes('SWARM')) { u.bodies.push('SWARM'); newUnlocks.push('Swarm Enemy'); }
            if (data.totalKills >= 2000 && !u.bodies.includes('GIANT')) { u.bodies.push('GIANT'); newUnlocks.push('Giant Enemy'); }
            
            if (data.totalRuns >= 5 && !u.mutators.includes('ROTATING_SCREEN')) { u.mutators.push('ROTATING_SCREEN'); newUnlocks.push('Vertigo Mutator'); }
            if (data.totalRuns >= 10 && !u.movements.includes('ORBIT')) { u.movements.push('ORBIT'); newUnlocks.push('Orbit Movement'); }
            if (data.totalRuns >= 15 && !u.attacks.includes('LASER')) { u.attacks.push('LASER'); newUnlocks.push('Laser Attack'); }
            if (data.totalRuns >= 20 && !u.mutators.includes('GRAVITY_BULLETS')) { u.mutators.push('GRAVITY_BULLETS'); newUnlocks.push('Heavy Rounds'); }
            if (data.totalRuns >= 30 && !u.movements.includes('TELEPORT')) { u.movements.push('TELEPORT'); newUnlocks.push('Teleport Movement'); }
            if (data.totalRuns >= 40 && !u.attacks.includes('HOMING')) { u.attacks.push('HOMING'); newUnlocks.push('Homing Attack'); }
            if (data.totalRuns >= 50 && !u.movements.includes('ERRATIC')) { u.movements.push('ERRATIC'); newUnlocks.push('Erratic Movement'); }
            
            // Add many more unlock conditions...
            const mutatorsToUnlock = [
                [10, 'SHRINKING_ARENA'], [15, 'BULLET_HELL'], [20, 'SPEED_DEMON'], [25, 'CHAOS_SPAWN'],
                [30, 'ECHO'], [35, 'MIRROR_MODE'], [40, 'INVISIBLE_ENEMIES'], [45, 'BULLET_TIME_ZONES'],
                [50, 'PORTALS'], [60, 'GRAVITY_WELLS'], [70, 'WIND_CURRENTS'], [80, 'FOG_OF_WAR'],
                [90, 'SIZE_SHIFT'], [100, 'COLOR_CHAOS'], [110, 'RHYTHM_MODE'], [120, 'DOUBLE_SPEED'],
                [130, 'HALF_SPEED'], [140, 'NO_WALLS'], [150, 'MAZE_MODE'], [160, 'SPIRAL_SPAWN'],
                [170, 'BOSS_WAVES'], [180, 'RICOCHET'], [190, 'SWARM_MODE'], [200, 'GIANT_ENEMIES']
            ];
            mutatorsToUnlock.forEach(([runs, mutator]) => {
                if (data.totalRuns >= runs && !u.mutators.includes(mutator) && MUTATORS[mutator]) {
                    u.mutators.push(mutator);
                    newUnlocks.push(`${MUTATORS[mutator].name} Mutator`);
                }
            });
            
            // Check mode unlocks
            Object.keys(GAME_MODES).forEach(key => {
                const mode = GAME_MODES[key];
                if (!u.modes.includes(key) && mode.check && mode.check(data)) {
                    u.modes.push(key);
                    newUnlocks.push(`${mode.name} Mode`);
                }
            });
            
            return newUnlocks;
        }
    };
    
    // ========== AUDIO ENGINE ==========
    class AudioEngine {
        constructor() { this.ctx = null; this.enabled = true; this.musicGain = null; this.sfxGain = null; this.intensity = 0; this.musicVolume = 0.15; this.sfxVolume = 0.3; }
        init() { try { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); this.musicGain = this.ctx.createGain(); this.sfxGain = this.ctx.createGain(); this.musicGain.gain.value = this.musicVolume; this.sfxGain.gain.value = this.sfxVolume; this.musicGain.connect(this.ctx.destination); this.sfxGain.connect(this.ctx.destination); } catch(e) { this.enabled = false; } }
        setMusicVolume(v) { this.musicVolume = v; if (this.musicGain) this.musicGain.gain.value = v; }
        setSfxVolume(v) { this.sfxVolume = v; if (this.sfxGain) this.sfxGain.gain.value = v; }
        resume() { if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume(); }
        startMusic() { if (!this.enabled || !this.ctx) return; this.stopMusic(); this.bassOsc = this.ctx.createOscillator(); this.bassOsc.type = 'sine'; this.bassOsc.frequency.value = 55; const bg = this.ctx.createGain(); bg.gain.value = 0.2; this.bassOsc.connect(bg); bg.connect(this.musicGain); this.bassOsc.start(); this.startArpeggio(); }
        startArpeggio() { if (!this.enabled) return; const notes = [110, 138.59, 164.81, 220, 164.81, 138.59]; let ni = 0; const play = () => { if (!this.enabled || !this.ctx) return; const o = this.ctx.createOscillator(); const g = this.ctx.createGain(); o.type = 'square'; o.frequency.value = notes[ni] * (1 + this.intensity * 0.5); g.gain.setValueAtTime(0.1 + this.intensity * 0.05, this.ctx.currentTime); g.gain.setTargetAtTime(0.01, this.ctx.currentTime + 0.1, 0.05); o.connect(g); g.connect(this.musicGain); o.start(); o.stop(this.ctx.currentTime + 0.15); ni = (ni + 1) % notes.length; this.arpTimer = setTimeout(play, Math.max(80, 200 - this.intensity * 80)); }; play(); }
        stopMusic() { if (this.bassOsc) { try { this.bassOsc.stop(); } catch(e) {} this.bassOsc = null; } if (this.arpTimer) { clearTimeout(this.arpTimer); this.arpTimer = null; } }
        setIntensity(v) { this.intensity = Math.min(1, Math.max(0, v)); }
        playSound(type) { if (!this.enabled || !this.ctx) return; const o = this.ctx.createOscillator(); const g = this.ctx.createGain(); o.connect(g); g.connect(this.sfxGain); switch(type) { case 'shoot': o.type='square'; o.frequency.setValueAtTime(880,this.ctx.currentTime); o.frequency.exponentialRampToValueAtTime(220,this.ctx.currentTime+0.1); g.gain.setValueAtTime(0.08,this.ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.01,this.ctx.currentTime+0.1); o.start(); o.stop(this.ctx.currentTime+0.1); break; case 'kill': o.type='sawtooth'; o.frequency.setValueAtTime(200,this.ctx.currentTime); o.frequency.exponentialRampToValueAtTime(50,this.ctx.currentTime+0.15); g.gain.setValueAtTime(0.15,this.ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.01,this.ctx.currentTime+0.15); o.start(); o.stop(this.ctx.currentTime+0.15); break; case 'nearMiss': o.type='sine'; o.frequency.setValueAtTime(1200,this.ctx.currentTime); o.frequency.exponentialRampToValueAtTime(2400,this.ctx.currentTime+0.05); g.gain.setValueAtTime(0.12,this.ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.01,this.ctx.currentTime+0.08); o.start(); o.stop(this.ctx.currentTime+0.08); break; case 'death': o.type='sawtooth'; o.frequency.setValueAtTime(400,this.ctx.currentTime); o.frequency.exponentialRampToValueAtTime(30,this.ctx.currentTime+0.5); g.gain.setValueAtTime(0.3,this.ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.01,this.ctx.currentTime+0.5); o.start(); o.stop(this.ctx.currentTime+0.5); break; case 'levelUp': [523,659,784,1047].forEach((f,i)=>{const oo=this.ctx.createOscillator();const gg=this.ctx.createGain();oo.type='sine';oo.frequency.value=f;gg.gain.setValueAtTime(0,this.ctx.currentTime+i*0.08);gg.gain.linearRampToValueAtTime(0.12,this.ctx.currentTime+i*0.08+0.04);gg.gain.linearRampToValueAtTime(0,this.ctx.currentTime+i*0.08+0.18);oo.connect(gg);gg.connect(this.sfxGain);oo.start(this.ctx.currentTime+i*0.08);oo.stop(this.ctx.currentTime+i*0.08+0.2);}); break; case 'achievement': [440,554,659,880].forEach((f,i)=>{const oo=this.ctx.createOscillator();const gg=this.ctx.createGain();oo.type='sine';oo.frequency.value=f;gg.gain.setValueAtTime(0,this.ctx.currentTime+i*0.1);gg.gain.linearRampToValueAtTime(0.15,this.ctx.currentTime+i*0.1+0.05);gg.gain.linearRampToValueAtTime(0,this.ctx.currentTime+i*0.1+0.3);oo.connect(gg);gg.connect(this.sfxGain);oo.start(this.ctx.currentTime+i*0.1);oo.stop(this.ctx.currentTime+i*0.1+0.35);}); break; case 'combo': o.type='sine'; o.frequency.setValueAtTime(600,this.ctx.currentTime); o.frequency.exponentialRampToValueAtTime(900,this.ctx.currentTime+0.1); g.gain.setValueAtTime(0.1,this.ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.01,this.ctx.currentTime+0.15); o.start(); o.stop(this.ctx.currentTime+0.15); break; case 'click': o.type='sine'; o.frequency.setValueAtTime(800,this.ctx.currentTime); g.gain.setValueAtTime(0.08,this.ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.01,this.ctx.currentTime+0.05); o.start(); o.stop(this.ctx.currentTime+0.05); break; case 'select': o.type='sine'; o.frequency.setValueAtTime(600,this.ctx.currentTime); o.frequency.linearRampToValueAtTime(900,this.ctx.currentTime+0.1); g.gain.setValueAtTime(0.1,this.ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.01,this.ctx.currentTime+0.12); o.start(); o.stop(this.ctx.currentTime+0.12); break; } }
    }
    
    // ========== PARTICLE SYSTEM ==========
    class Particle {
        constructor(x, y, vx, vy, color, size, life, type = 'circle') { this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.color = color; this.size = size; this.life = life; this.maxLife = life; this.type = type; this.rotation = Math.random() * Math.PI * 2; this.rotationSpeed = (Math.random() - 0.5) * 5; }
        update(dt) { this.x += this.vx * dt * 60; this.y += this.vy * dt * 60; this.life -= dt; this.vx *= 0.96; this.vy *= 0.96; this.rotation += this.rotationSpeed * dt; }
        draw(ctx) { const a = Math.max(0, this.life / this.maxLife); ctx.globalAlpha = a; ctx.fillStyle = this.color; if (this.type === 'square') { ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation); const s = this.size * a; ctx.fillRect(-s/2, -s/2, s, s); ctx.restore(); } else { ctx.beginPath(); ctx.arc(this.x, this.y, this.size * a, 0, Math.PI * 2); ctx.fill(); } ctx.globalAlpha = 1; }
    }
    
    // ========== MAIN GAME CLASS ==========
    class Game {
        constructor() {
            this.canvas = document.getElementById('gameCanvas');
            this.ctx = this.canvas.getContext('2d');
            this.audio = new AudioEngine();
            this.meta = META.load();
            this.resize();
            window.addEventListener('resize', () => this.resize());
            this.setupInput();
            this.setupUI();
            this.generateDailyChallenges();
            this.generateMissions();
            this.showScreen('startScreen');
            this.updateStartScreen();
        }
        
        resize() { const ratio = CONFIG.CANVAS_WIDTH / CONFIG.CANVAS_HEIGHT; let w = window.innerWidth; let h = window.innerHeight; if (w / h > ratio) w = h * ratio; else h = w / ratio; this.canvas.width = CONFIG.CANVAS_WIDTH; this.canvas.height = CONFIG.CANVAS_HEIGHT; this.canvas.style.width = w + 'px'; this.canvas.style.height = h + 'px'; this.scale = w / CONFIG.CANVAS_WIDTH; }
        
        setupInput() {
            this.touch = { active: false, x: 0, y: 0, startX: 0, startY: 0 };
            const getPos = (e) => { const rect = this.canvas.getBoundingClientRect(); const cx = e.touches ? e.touches[0].clientX : e.clientX; const cy = e.touches ? e.touches[0].clientY : e.clientY; return { x: (cx - rect.left) / this.scale, y: (cy - rect.top) / this.scale }; };
            const start = (e) => { e.preventDefault(); this.audio.resume(); const pos = getPos(e); this.touch.active = true; this.touch.startX = pos.x; this.touch.startY = pos.y; this.touch.x = pos.x; this.touch.y = pos.y; };
            const move = (e) => { e.preventDefault(); if (!this.touch.active) return; const pos = getPos(e); this.touch.x = pos.x; this.touch.y = pos.y; };
            const end = (e) => { e.preventDefault(); this.touch.active = false; };
            this.canvas.addEventListener('touchstart', start, { passive: false });
            this.canvas.addEventListener('touchmove', move, { passive: false });
            this.canvas.addEventListener('touchend', end, { passive: false });
            this.canvas.addEventListener('mousedown', start);
            this.canvas.addEventListener('mousemove', move);
            this.canvas.addEventListener('mouseup', end);
            this.canvas.addEventListener('mouseleave', end);
        }
        
        setupUI() {
            document.getElementById('startBtn').onclick = () => { this.audio.init(); this.audio.playSound('select'); this.startGame(); };
            document.getElementById('progressionBtn').onclick = () => { this.audio.playSound('click'); this.showProgressionScreen(); };
            document.getElementById('achievementsBtn').onclick = () => { this.audio.playSound('click'); this.showAchievementsScreen(); };
            document.getElementById('challengesBtn').onclick = () => { this.audio.playSound('click'); this.showChallengesScreen(); };
            document.getElementById('codexBtn').onclick = () => { this.audio.playSound('click'); this.showCodexScreen(); };
            document.getElementById('modesBtn').onclick = () => { this.audio.playSound('click'); this.showModesScreen(); };
            document.getElementById('characterBtn').onclick = () => { this.audio.playSound('click'); this.showCharacterScreen(); };
            document.getElementById('settingsBtn').onclick = () => { this.audio.playSound('click'); this.showScreen('settingsScreen'); };
            document.getElementById('tutorialBtn').onclick = () => { this.audio.playSound('click'); this.showScreen('tutorialScreen'); };
            
            ['progressionBack', 'achievementsBack', 'challengesBack', 'codexBack', 'modesBack', 'characterBack', 'settingsBack', 'tutorialBack'].forEach(id => {
                document.getElementById(id).onclick = () => { this.audio.playSound('click'); this.showScreen('startScreen'); this.updateStartScreen(); };
            });
            
            document.getElementById('musicVolume').oninput = (e) => { this.meta.settings.musicVolume = parseInt(e.target.value); this.audio.setMusicVolume(this.meta.settings.musicVolume / 100 * 0.5); META.save(this.meta); };
            document.getElementById('sfxVolume').oninput = (e) => { this.meta.settings.sfxVolume = parseInt(e.target.value); this.audio.setSfxVolume(this.meta.settings.sfxVolume / 100 * 0.5); META.save(this.meta); };
            
            ['toggleShake', 'toggleEffects', 'toggleTrail', 'toggleQuickRestart'].forEach(id => {
                document.getElementById(id).onclick = (e) => { e.target.classList.toggle('active'); const key = id.replace('toggle', '').toLowerCase(); const settingKey = key === 'shake' ? 'screenShake' : key === 'effects' ? 'visualEffects' : key === 'trail' ? 'showTrail' : 'quickRestart'; this.meta.settings[settingKey] = e.target.classList.contains('active'); META.save(this.meta); this.audio.playSound('click'); };
            });
            
            document.getElementById('resetProgressBtn').onclick = () => document.getElementById('confirmOverlay').classList.add('active');
            document.getElementById('confirmCancel').onclick = () => document.getElementById('confirmOverlay').classList.remove('active');
            document.getElementById('confirmReset').onclick = () => { document.getElementById('confirmOverlay').classList.remove('active'); this.meta = META.getDefault(); META.save(this.meta); this.updateStartScreen(); this.showScreen('startScreen'); };
            
            document.querySelectorAll('#unlockTabs .unlock-tab').forEach(tab => {
                tab.onclick = () => { document.querySelectorAll('#unlockTabs .unlock-tab').forEach(t => t.classList.remove('active')); tab.classList.add('active'); this.renderUnlockGrid(tab.dataset.category); this.audio.playSound('click'); };
            });
            
            document.querySelectorAll('#achievementTabs .unlock-tab').forEach(tab => {
                tab.onclick = () => { document.querySelectorAll('#achievementTabs .unlock-tab').forEach(t => t.classList.remove('active')); tab.classList.add('active'); this.renderAchievements(tab.dataset.category); this.audio.playSound('click'); };
            });
            
            document.querySelectorAll('#skinTabs .unlock-tab').forEach(tab => {
                tab.onclick = () => { document.querySelectorAll('#skinTabs .unlock-tab').forEach(t => t.classList.remove('active')); tab.classList.add('active'); this.renderCharacterGrid(tab.dataset.rarity); this.audio.playSound('click'); };
            });
            
            document.getElementById('confirmCharacter').onclick = () => { this.audio.playSound('select'); this.showScreen('startScreen'); };
            document.getElementById('confirmMode').onclick = () => { this.audio.playSound('select'); this.showScreen('startScreen'); };
            document.getElementById('restartBtn').onclick = () => { this.audio.playSound('select'); this.startGame(); };
            document.getElementById('menuBtn').onclick = () => { this.audio.playSound('click'); this.showScreen('startScreen'); this.updateStartScreen(); };
            
            document.getElementById('musicVolume').value = this.meta.settings.musicVolume;
            document.getElementById('sfxVolume').value = this.meta.settings.sfxVolume;
            document.getElementById('toggleShake').classList.toggle('active', this.meta.settings.screenShake);
            document.getElementById('toggleEffects').classList.toggle('active', this.meta.settings.visualEffects);
            document.getElementById('toggleTrail').classList.toggle('active', this.meta.settings.showTrail);
            document.getElementById('toggleQuickRestart').classList.toggle('active', this.meta.settings.quickRestart);
        }
        
        showScreen(id) { document.querySelectorAll('.screen').forEach(s => s.classList.remove('active')); document.getElementById(id).classList.add('active'); }
        
        updateStartScreen() {
            document.getElementById('bestScoreDisplay').textContent = this.meta.bestScore.toLocaleString();
            document.getElementById('accountLevelDisplay').textContent = this.meta.accountLevel;
            const xpNeeded = CONFIG.ACCOUNT_XP_PER_LEVEL * (1 + this.meta.accountLevel * 0.1);
            document.getElementById('accountXpFill').style.width = (this.meta.accountXp / xpNeeded * 100) + '%';
        }
        
        showProgressionScreen() {
            this.showScreen('progressionScreen');
            document.getElementById('statRuns').textContent = this.meta.totalRuns;
            document.getElementById('statBestScore').textContent = this.meta.bestScore.toLocaleString();
            document.getElementById('statBestTime').textContent = this.formatTime(this.meta.bestTime);
            document.getElementById('statKills').textContent = this.meta.totalKills.toLocaleString();
            document.getElementById('statPlaytime').textContent = Math.floor(this.meta.totalPlaytime / 3600) + 'h';
            document.getElementById('statNearMisses').textContent = this.meta.totalNearMisses.toLocaleString();
            document.getElementById('statMaxCombo').textContent = this.meta.bestCombo + 'x';
            document.getElementById('statPrestige').textContent = this.meta.prestige;
            
            const total = Object.keys(PLAYER_SKINS).length + Object.keys(UPGRADE_TRIGGERS).length + Object.keys(UPGRADE_EFFECTS).length + Object.keys(MUTATORS).length;
            const current = this.meta.unlocks.skins.length + this.meta.unlocks.triggers.length + this.meta.unlocks.effects.length + this.meta.unlocks.mutators.length;
            const percent = Math.round(current / total * 100);
            document.getElementById('completionPercent').textContent = percent + '%';
            document.getElementById('completionFill').style.width = percent + '%';
            this.renderUnlockGrid('skins');
        }
        
        renderUnlockGrid(category) {
            const grid = document.getElementById('unlockGrid');
            grid.innerHTML = '';
            let items = [];
            const u = this.meta.unlocks;
            
            if (category === 'skins') {
                Object.keys(PLAYER_SKINS).forEach(key => {
                    const skin = PLAYER_SKINS[key];
                    items.push({ key, icon: this.getSkinEmoji(skin.shape), name: skin.name, desc: u.skins.includes(key) ? skin.rarity.toUpperCase() : skin.requirement, unlocked: u.skins.includes(key), rarity: skin.rarity });
                });
            } else if (category === 'triggers') {
                Object.keys(UPGRADE_TRIGGERS).forEach(key => {
                    const t = UPGRADE_TRIGGERS[key];
                    items.push({ key, icon: t.icon, name: t.name, desc: t.desc, unlocked: u.triggers.includes(key), rarity: 'common' });
                });
            } else if (category === 'effects') {
                Object.keys(UPGRADE_EFFECTS).forEach(key => {
                    const e = UPGRADE_EFFECTS[key];
                    items.push({ key, icon: e.icon, name: e.name, desc: e.desc, unlocked: u.effects.includes(key), rarity: 'common' });
                });
            } else if (category === 'mutators') {
                Object.keys(MUTATORS).forEach(key => {
                    const m = MUTATORS[key];
                    items.push({ key, icon: m.icon, name: m.name, desc: m.desc, unlocked: u.mutators.includes(key), rarity: 'common' });
                });
            } else if (category === 'enemies') {
                Object.keys(ENEMY_DNA.BODY).forEach(key => {
                    const b = ENEMY_DNA.BODY[key];
                    items.push({ key, icon: b.icon, name: b.name, desc: `HP: ${b.hp}, Speed: ${b.speed}x`, unlocked: u.bodies.includes(key), rarity: 'common' });
                });
            }
            
            items.forEach(item => {
                const card = document.createElement('div');
                card.className = `unlock-card ${item.unlocked ? 'unlocked' : 'locked'} rarity-${item.rarity}`;
                card.innerHTML = `<div class="unlock-icon">${item.icon}</div><div class="unlock-name">${item.name}</div><div class="unlock-desc">${item.desc}</div><div class="unlock-rarity">${item.rarity}</div>`;
                grid.appendChild(card);
            });
        }
        
        getSkinEmoji(shape) {
            const map = { diamond: 'üíé', circle: '‚ö™', triangle: 'üî∫', square: '‚¨ú', hexagon: '‚¨°', star: '‚≠ê', pentagon: '‚¨†', cross: '‚úö', ghost: 'üëª', blade: 'üó°Ô∏è', chaos: 'üåÄ', spiral: 'üåÄ', atom: '‚öõÔ∏è', crown: 'üëë', flame: 'üî•', frost: '‚ùÑÔ∏è', shadow: 'üåë', prism: 'üî∑', wing: 'ü™Ω', dragon: 'üêâ', phoenix: 'ü¶Ö', void: 'üï≥Ô∏è', neon: 'üíö', crystal: 'üíé', inferno: 'üî•', glacier: 'üßä', lightning: '‚ö°', nebula: 'üåå', toxic: '‚ò†Ô∏è', celestial: '‚ú®', darkmatter: '‚ö´', supernova: 'üí•', quantum: 'üîÆ', eclipse: 'üåë', omega: 'Œ©', infinity: '‚àû', eternal: '‚ôæÔ∏è', transcendent: 'üëÅÔ∏è' };
            return map[shape] || '‚¨ú';
        }
        
        showAchievementsScreen() { this.showScreen('achievementsScreen'); this.renderAchievements('all'); }
        
        renderAchievements(category) {
            const grid = document.getElementById('achievementsGrid');
            grid.innerHTML = '';
            Object.keys(ACHIEVEMENTS).forEach(key => {
                const a = ACHIEVEMENTS[key];
                if (category !== 'all' && a.category !== category) return;
                const completed = this.meta.unlocks.achievements.includes(key);
                const card = document.createElement('div');
                card.className = `achievement-card ${completed ? 'completed' : 'locked'}`;
                card.innerHTML = `<div class="achievement-icon">${a.icon}</div><div class="achievement-info"><h5>${a.name}</h5><p>${a.desc}</p><div class="achievement-progress"><div class="achievement-progress-fill" style="width: ${completed ? 100 : 0}%"></div></div></div>`;
                grid.appendChild(card);
            });
        }
        
        showChallengesScreen() {
            this.showScreen('challengesScreen');
            this.generateDailyChallenges();
            const daily = document.getElementById('dailyChallenge');
            const weekly = document.getElementById('weeklyChallenge');
            daily.innerHTML = `<div class="challenge-header"><h4>üìÖ DAILY CHALLENGE</h4><div class="challenge-timer">Resets in ${this.getTimeUntilReset('daily')}</div></div><div class="challenge-desc">${this.meta.dailyChallenge?.desc || 'Loading...'}</div><div class="challenge-reward">Reward: +500 XP</div>`;
            weekly.innerHTML = `<div class="challenge-header"><h4>üìÜ WEEKLY CHALLENGE</h4><div class="challenge-timer">Resets in ${this.getTimeUntilReset('weekly')}</div></div><div class="challenge-desc">${this.meta.weeklyChallenge?.desc || 'Loading...'}</div><div class="challenge-reward">Reward: +2000 XP</div>`;
            this.renderMissions();
        }
        
        generateDailyChallenges() {
            const today = new Date().toDateString();
            if (this.meta.lastDaily !== today) {
                const challenges = [
                    { desc: 'Score 3,000 points in a single run', check: (s) => s >= 3000 },
                    { desc: 'Survive for 90 seconds', check: (s, t) => t >= 90 },
                    { desc: 'Kill 50 enemies in one run', check: (s, t, k) => k >= 50 },
                    { desc: 'Reach level 8', check: (s, t, k, l) => l >= 8 },
                    { desc: 'Get a 10x combo', check: (s, t, k, l, c) => c >= 10 }
                ];
                this.meta.dailyChallenge = challenges[Math.floor(Math.random() * challenges.length)];
                this.meta.lastDaily = today;
                META.save(this.meta);
            }
            const week = Math.floor(Date.now() / (7 * 24 * 60 * 60 * 1000));
            if (this.meta.lastWeekly !== week) {
                const weeklies = [
                    { desc: 'Score 10,000 total points this week', target: 10000 },
                    { desc: 'Kill 200 enemies this week', target: 200 },
                    { desc: 'Complete 10 runs this week', target: 10 }
                ];
                this.meta.weeklyChallenge = weeklies[Math.floor(Math.random() * weeklies.length)];
                this.meta.lastWeekly = week;
                META.save(this.meta);
            }
        }
        
        generateMissions() {
            if (!this.meta.missions || this.meta.missions.length < 3) {
                const missionPool = [
                    { desc: 'Kill 20 enemies', icon: 'üíÄ', target: 20, type: 'kills', reward: 100 },
                    { desc: 'Survive 45 seconds', icon: '‚è±Ô∏è', target: 45, type: 'time', reward: 100 },
                    { desc: 'Score 1,500 points', icon: '‚≠ê', target: 1500, type: 'score', reward: 100 },
                    { desc: 'Get 5 near misses', icon: 'üòÖ', target: 5, type: 'nearMiss', reward: 150 },
                    { desc: 'Reach level 5', icon: 'üìà', target: 5, type: 'level', reward: 150 },
                    { desc: 'Get 5x combo', icon: 'üîó', target: 5, type: 'combo', reward: 200 }
                ];
                this.meta.missions = [];
                for (let i = 0; i < 3; i++) {
                    const idx = Math.floor(Math.random() * missionPool.length);
                    this.meta.missions.push({ ...missionPool[idx], progress: 0, completed: false });
                }
                META.save(this.meta);
            }
        }
        
        renderMissions() {
            const list = document.getElementById('missionList');
            list.innerHTML = '';
            this.meta.missions.forEach((m, i) => {
                const div = document.createElement('div');
                div.className = `mission-item ${m.completed ? 'completed' : ''}`;
                div.innerHTML = `<div class="mission-icon">${m.icon}</div><div class="mission-info"><h5>${m.desc}</h5><p>Progress: ${m.progress}/${m.target}</p></div><div class="mission-reward">+${m.reward} XP</div>`;
                list.appendChild(div);
            });
        }
        
        getTimeUntilReset(type) {
            const now = new Date();
            if (type === 'daily') {
                const tomorrow = new Date(now); tomorrow.setDate(tomorrow.getDate() + 1); tomorrow.setHours(0, 0, 0, 0);
                const diff = tomorrow - now;
                return Math.floor(diff / 3600000) + 'h ' + Math.floor((diff % 3600000) / 60000) + 'm';
            } else {
                const nextWeek = new Date(now); nextWeek.setDate(nextWeek.getDate() + (7 - nextWeek.getDay()));
                const diff = nextWeek - now;
                return Math.floor(diff / 86400000) + 'd';
            }
        }
        
        showCodexScreen() { this.showScreen('codexScreen'); this.renderCodex('enemies'); }
        
        renderCodex(category) {
            const grid = document.getElementById('codexGrid');
            grid.innerHTML = '';
            if (category === 'enemies') {
                Object.keys(ENEMY_DNA.BODY).forEach(key => {
                    const b = ENEMY_DNA.BODY[key];
                    const stats = this.meta.codex.enemies[key] || { killed: 0, killedBy: 0 };
                    const card = document.createElement('div');
                    card.className = 'unlock-card unlocked';
                    card.innerHTML = `<div class="unlock-icon">${b.icon}</div><div class="unlock-name">${b.name}</div><div class="unlock-desc">Killed: ${stats.killed}<br>Deaths: ${stats.killedBy}</div>`;
                    grid.appendChild(card);
                });
            }
        }
        
        showModesScreen() {
            this.showScreen('modesScreen');
            const grid = document.getElementById('modeGrid');
            grid.innerHTML = '';
            Object.keys(GAME_MODES).forEach(key => {
                const mode = GAME_MODES[key];
                const unlocked = this.meta.unlocks.modes.includes(key);
                const selected = this.meta.selectedMode === key;
                const card = document.createElement('div');
                card.className = `mode-card ${!unlocked ? 'locked' : ''} ${selected ? 'selected' : ''}`;
                card.innerHTML = `<div class="mode-icon">${mode.icon}</div><div class="mode-name">${mode.name}</div><div class="mode-desc">${unlocked ? mode.desc : mode.requirement}</div>`;
                if (unlocked) {
                    card.onclick = () => {
                        document.querySelectorAll('.mode-card').forEach(c => c.classList.remove('selected'));
                        card.classList.add('selected');
                        this.meta.selectedMode = key;
                        META.save(this.meta);
                        this.audio.playSound('select');
                    };
                }
                grid.appendChild(card);
            });
        }
        
        showCharacterScreen() {
            this.showScreen('characterScreen');
            this.renderCharacterGrid('all');
        }
        
        renderCharacterGrid(rarity) {
            const grid = document.getElementById('characterGrid');
            grid.innerHTML = '';
            Object.keys(PLAYER_SKINS).forEach(key => {
                const skin = PLAYER_SKINS[key];
                if (rarity !== 'all' && skin.rarity !== rarity) return;
                const unlocked = this.meta.unlocks.skins.includes(key);
                const selected = this.meta.selectedSkin === key;
                const card = document.createElement('div');
                card.className = `character-card ${selected ? 'selected' : ''} ${!unlocked ? 'locked' : ''} rarity-${skin.rarity}`;
                card.innerHTML = `<div class="character-preview">${this.getSkinEmoji(skin.shape)}</div><div class="character-name" style="color: ${skin.color}">${skin.name}</div><div class="character-req">${unlocked ? (selected ? 'EQUIPPED' : skin.rarity.toUpperCase()) : skin.requirement}</div>`;
                if (unlocked) {
                    card.onclick = () => {
                        document.querySelectorAll('.character-card').forEach(c => c.classList.remove('selected'));
                        card.classList.add('selected');
                        this.meta.selectedSkin = key;
                        META.save(this.meta);
                        this.audio.playSound('select');
                    };
                }
                grid.appendChild(card);
            });
        }
        
        showAchievementPopup(name) {
            const popup = document.getElementById('achievementPopup');
            document.getElementById('achievementName').textContent = name;
            popup.classList.add('active');
            this.audio.playSound('achievement');
            setTimeout(() => popup.classList.remove('active'), 3000);
        }
        
        startGame() {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById('upgradeMenu').style.display = 'none';
            
            const skin = PLAYER_SKINS[this.meta.selectedSkin] || PLAYER_SKINS.DIAMOND;
            
            this.player = {
                x: CONFIG.CANVAS_WIDTH / 2, y: CONFIG.CANVAS_HEIGHT * 0.7, vx: 0, vy: 0, size: CONFIG.PLAYER_SIZE,
                moving: false, wasMoving: false, nearMiss: false, perfectDodge: false, justKilled: false, justKilledElite: false, justLeveledUp: false,
                multiKill: 0, multiKillTimer: 0, nearWall: false, inCorner: false, inCenter: false, streak: 0, streakTick: false,
                trail: [], skin: skin, skinKey: this.meta.selectedSkin, invincible: 0, cursed: false, slowed: 1
            };
            
            this.enemies = []; this.enemyBullets = []; this.playerBullets = []; this.particles = [];
            this.xpOrbs = []; this.hazards = []; this.visualEffects = [];
            
            this.score = 0; this.scoreMult = 1; this.xp = 0; this.level = 1; this.time = 0; this.kills = 0;
            this.nearMissCount = 0; this.combo = 0; this.comboTimer = 0; this.maxCombo = 0;
            this.timeScale = 1; this.gameOver = false; this.paused = false; this.upgradeMenuOpen = false;
            
            this.arena = { shrinkAmount: 0, rotation: 0 };
            this.rules = {};
            this.screenEffects = { shake: 0, flash: 0, distort: 0, chromatic: 0 };
            this.upgrades = {}; this.upgradeCooldowns = {};
            this.spawnTimer = 0; this.spawnRate = CONFIG.SPAWN_RATE_INITIAL;
            this.orbitals = 0; this.orbitalTimer = 0; this.chaosLevel = 0;
            this.xpBombTimer = 0; this.thunderTimer = 0; this.playerTrailTimer = 0;
            
            this.activeMutators = this.selectMutators();
            this.activeMutators.forEach(m => MUTATORS[m].apply(this));
            this.updateMutatorUI();
            
            this.autoAttackTimer = 0;
            this.audio.setMusicVolume(this.meta.settings.musicVolume / 100 * 0.5);
            this.audio.setSfxVolume(this.meta.settings.sfxVolume / 100 * 0.5);
            this.audio.startMusic();
            this.lastTime = performance.now();
            this.gameLoop();
        }
        
        selectMutators() {
            const available = this.meta.unlocks.mutators;
            const count = 2 + Math.floor(Math.random() * 2);
            const selected = [];
            const pool = [...available];
            for (let i = 0; i < Math.min(count, pool.length); i++) {
                const idx = Math.floor(Math.random() * pool.length);
                selected.push(pool.splice(idx, 1)[0]);
            }
            return selected;
        }
        
        updateMutatorUI() {
            document.getElementById('mutators').innerHTML = this.activeMutators.map(m => 
                `<span class="mutator-tag" style="color:${MUTATORS[m].color}">${MUTATORS[m].icon} ${MUTATORS[m].name}</span>`
            ).join('');
        }
        
        gameLoop() {
            if (this.gameOver) return;
            const now = performance.now();
            let dt = (now - this.lastTime) / 1000;
            this.lastTime = now;
            dt = Math.min(dt, 0.1);
            if (!this.paused && !this.upgradeMenuOpen) {
                dt *= this.timeScale;
                if (this.rules.doubleSpeed) dt *= 2;
                if (this.rules.halfSpeed) dt *= 0.5;
                this.update(dt);
            }
            this.render();
            requestAnimationFrame(() => this.gameLoop());
        }
        
        update(dt) {
            this.time += dt;
            this.player.streak += dt;
            this.player.streakTick = Math.floor(this.player.streak) % 5 === 0 && Math.floor(this.player.streak - dt) % 5 !== 0;
            this.chaosLevel = Math.min(1, this.time / 120 + this.enemies.length / 20);
            this.audio.setIntensity(this.chaosLevel);
            
            this.player.nearMiss = false;
            this.player.perfectDodge = false;
            this.player.justKilled = false;
            this.player.justKilledElite = false;
            this.player.justLeveledUp = false;
            this.player.wasMoving = this.player.moving;
            this.player.cursed = false;
            this.player.slowed = 1;
            
            if (this.player.invincible > 0) this.player.invincible -= dt;
            if (this.orbitalTimer > 0) this.orbitalTimer -= dt;
            if (this.xpBombTimer > 0) this.xpBombTimer -= dt;
            if (this.rules.thunderstorm) {
                this.thunderTimer -= dt;
                if (this.thunderTimer <= 0) {
                    this.thunderTimer = 1.2 + Math.random() * 1.2;
                    const living = this.enemies.filter(e=>!e.dead);
                    if (living.length) {
                        const t = living[Math.floor(Math.random()*living.length)];
                        t.hp -= 1;
                        this.spawnHitEffect(t.x, t.y, '#0ff');
                        this.visualEffects.push({type:'lightning',x1:t.x, y1:0, x2:t.x, y2:t.y, timer:0.25, duration:0.25});
                        this.screenEffects.flash = Math.max(this.screenEffects.flash, 0.25);
                    }
                }
            }
            if (this.player.multiKillTimer > 0) { this.player.multiKillTimer -= dt; if (this.player.multiKillTimer <= 0) this.player.multiKill = 0; }
            
            // Combo decay
            if (this.comboTimer > 0) {
                this.comboTimer -= dt;
                if (this.comboTimer <= 0) this.combo = 0;
            }
            
            this.updatePlayer(dt);
            this.updateAutoAttack(dt);
            this.updateEnemies(dt);
            this.updateBullets(dt);
            this.updateHazards(dt);
            this.updateXPOrbs(dt);
            this.updateParticles(dt);
            this.updateVisualEffects(dt);
            this.checkCollisions();
            this.updateTriggers(dt);
            this.updateSpawning(dt);
            this.updateArena(dt);
            this.updateUI();
            this.updateComboUI();
            
            if (this.meta.settings.screenShake) this.screenEffects.shake *= 0.9;
            else this.screenEffects.shake = 0;
            this.screenEffects.flash *= 0.85;
            this.screenEffects.distort *= 0.95;
            this.screenEffects.chromatic *= 0.9;
            
            if (this.rules.deathSlow) {
                let minDist = Infinity;
                this.enemyBullets.forEach(b => { const d = Math.hypot(b.x - this.player.x, b.y - this.player.y); minDist = Math.min(minDist, d); });
                if (minDist < 50) this.timeScale = 0.3 + (minDist / 50) * 0.7;
                else this.timeScale = Math.min(1, this.timeScale + dt * 2);
            }
        }
        
        updatePlayer(dt) {
            const p = this.player;
            const speedMod = p.slowed * (p.cursed ? 0.7 : 1);
            
            if (this.touch.active) {
                let dx = this.touch.x - this.touch.startX;
                let dy = this.touch.y - this.touch.startY;
                if (this.rules.mirror) dx = -dx
;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > 5) {
                    const speed = Math.min(dist / 30, 1) * CONFIG.PLAYER_SPEED * speedMod;
                    p.vx += (dx / dist) * speed * dt * 60;
                    p.vy += (dy / dist) * speed * dt * 60;
                    p.moving = true;
                } else p.moving = false;
            } else p.moving = false;
            
            p.vx *= CONFIG.PLAYER_FRICTION;
            p.vy *= CONFIG.PLAYER_FRICTION;
            p.x += p.vx;
            p.y += p.vy;
            if (this.rules.blazingTrail) {
                this.playerTrailTimer += dt;
                if (this.playerTrailTimer > 0.08) {
                    this.hazards.push({ x: p.x, y: p.y, size: 10, color: 'rgba(255,136,0,0.35)', type: 'playertrail', timer: 1.2 });
                    this.playerTrailTimer = 0;
                }
            }
            
            const margin = this.arena.shrinkAmount;
            if (this.rules.noWalls) {
                if (p.x < margin) p.x = CONFIG.CANVAS_WIDTH - margin;
                if (p.x > CONFIG.CANVAS_WIDTH - margin) p.x = margin;
                if (p.y < margin) p.y = CONFIG.CANVAS_HEIGHT - margin;
                if (p.y > CONFIG.CANVAS_HEIGHT - margin) p.y = margin;
            } else {
                p.x = Math.max(p.size + margin, Math.min(CONFIG.CANVAS_WIDTH - p.size - margin, p.x));
                p.y = Math.max(p.size + margin, Math.min(CONFIG.CANVAS_HEIGHT - p.size - margin, p.y));
            }
            
            p.nearWall = p.x < p.size + margin + 30 || p.x > CONFIG.CANVAS_WIDTH - p.size - margin - 30 || p.y < p.size + margin + 30 || p.y > CONFIG.CANVAS_HEIGHT - p.size - margin - 30;
            p.inCorner = (p.x < 60 || p.x > CONFIG.CANVAS_WIDTH - 60) && (p.y < 60 || p.y > CONFIG.CANVAS_HEIGHT - 60);
            p.inCenter = Math.hypot(p.x - CONFIG.CANVAS_WIDTH/2, p.y - CONFIG.CANVAS_HEIGHT/2) < 50;
            
            if (this.meta.settings.showTrail) {
                p.trail.unshift({ x: p.x, y: p.y });
                if (p.trail.length > 12) p.trail.pop();
            }
        }
        
        updateAutoAttack(dt) {
            const fireRate = this.rules.overdrive ? 0.08 : 0.15;
            this.autoAttackTimer += dt;
            if (this.autoAttackTimer >= fireRate) {
                this.autoAttackTimer = 0;
                let nearest = null, minDist = Infinity;
                this.enemies.forEach(e => { if (e.dead || e.friendly) return; const d = Math.hypot(e.x - this.player.x, e.y - this.player.y); if (d < minDist) { minDist = d; nearest = e; } });
                if (nearest) {
                    const angle = Math.atan2(nearest.y - this.player.y, nearest.x - this.player.x);
                    const damage = this.rules.glassCannon ? 2 : 1;
                    this.playerBullets.push({ x: this.player.x, y: this.player.y, vx: Math.cos(angle) * CONFIG.BULLET_SPEED, vy: Math.sin(angle) * CONFIG.BULLET_SPEED, size: 4, damage });
                    this.audio.playSound('shoot');
                }
            }
        }
        
        updateEnemies(dt) {
            const speedMult = this.rules.speedDemon ? 1.5 : 1;
            this.enemies.forEach(e => {
                if (e.dead) return;
                e.moveTimer = (e.moveTimer || 0) + dt;
                if (e.frozen && e.frozen > 0) { e.frozen -= dt; return; }
                if (e.regen) { e.regenTimer = (e.regenTimer || 0) + dt; if (e.regenTimer > 2) { e.hp = Math.min(e.hp + 1, e.dna.body.hp); e.regenTimer = 0; } }
                
                if (e.dashing) {
                    e.x += Math.cos(e.dashAngle) * 15 * speedMult;
                    e.y += Math.sin(e.dashAngle) * 15 * speedMult;
                    e.dashTimer -= dt;
                    if (e.dashTimer <= 0) e.dashing = false;
                } else if (!e.isTurret) {
                    const moveDef = ENEMY_DNA.MOVEMENT[e.dna.movement];
                    if (moveDef && moveDef.fn && !e.friendly) moveDef.fn(e, this.player, dt);
                    else if (e.friendly) {
                        let target = this.enemies.find(o => !o.dead && !o.friendly && o !== e);
                        if (target) { const d = Math.hypot(target.x - e.x, target.y - e.y) || 1; e.vx = (target.x - e.x) / d * e.speed * CONFIG.ENEMY_BASE_SPEED; e.vy = (target.y - e.y) / d * e.speed * CONFIG.ENEMY_BASE_SPEED; }
                    }
                    const actualSpeed = speedMult * (e.buffed ? 1.5 : 1);
                    e.x += (e.vx || 0) * actualSpeed;
                    e.y += (e.vy || 0) * actualSpeed;
                }
                
                const margin = this.arena.shrinkAmount;
                e.x = Math.max(e.size + margin, Math.min(CONFIG.CANVAS_WIDTH - e.size - margin, e.x));
                e.y = Math.max(e.size + margin, Math.min(CONFIG.CANVAS_HEIGHT - e.size - margin, e.y));
                
                const attackDef = ENEMY_DNA.ATTACK[e.dna.attack];
                if (attackDef && !e.friendly && attackDef.cooldown < 9000) {
                    e.attackTimer = (e.attackTimer || attackDef.cooldown) - dt;
                    const cooldownMult = this.rules.bulletHell ? 0.5 : 1;
                    if (e.attackTimer <= 0) {
                        const bullets = attackDef.fire(e, this.player, this);
                        bullets.forEach(b => this.enemyBullets.push(b));
                        e.attackTimer = attackDef.cooldown * cooldownMult;
                    }
                }
                
                const modDef = ENEMY_DNA.MODIFIER[e.dna.modifier];
                if (modDef && modDef.onUpdate) modDef.onUpdate(e, dt, this);
                if (this.rules.enemyTrails && !e.friendly) {
                    e.globalTrailTimer = (e.globalTrailTimer || 0) + dt;
                    if (e.globalTrailTimer > 0.3) { this.hazards.push({ x: e.x, y: e.y, size: 6, color: '#0f04', type: 'trail', timer: 1.5 }); e.globalTrailTimer = 0; }
                }
                if (e.laserActive) {
                    const px = this.player.x - e.x, py = this.player.y - e.y;
                    const lx = Math.cos(e.laserAngle), ly = Math.sin(e.laserAngle);
                    const dot = px * lx + py * ly;
                    if (dot > 0 && dot < 400) { const perpDist = Math.abs(px * ly - py * lx); if (perpDist < this.player.size + 5) this.playerDeath(); }
                }
                e.buffed = false;
            });
            this.enemies = this.enemies.filter(e => !e.dead);
        }
        
        updateBullets(dt) {
            const speedMult = this.rules.speedDemon ? 1.5 : 1;
            this.playerBullets.forEach(b => {
                b.x += b.vx * speedMult;
                b.y += b.vy * speedMult;
                if (this.rules.ricochet && !b.bounced) {
                    if (b.x < 0 || b.x > CONFIG.CANVAS_WIDTH) { b.vx *= -1; b.bounced = true; }
                    if (b.y < 0 || b.y > CONFIG.CANVAS_HEIGHT) { b.vy *= -1; b.bounced = true; }
                }
            });
            this.playerBullets = this.playerBullets.filter(b => b.x > -10 && b.x < CONFIG.CANVAS_WIDTH + 10 && b.y > -10 && b.y < CONFIG.CANVAS_HEIGHT + 10);
            
            this.enemyBullets.forEach(b => {
                if (b.homing && b.life > 0) {
                    const d = Math.hypot(this.player.x - b.x, this.player.y - b.y) || 1;
                    b.vx += (this.player.x - b.x) / d * b.speed * 0.1;
                    b.vy += (this.player.y - b.y) / d * b.speed * 0.1;
                    const cs = Math.hypot(b.vx, b.vy);
                    if (cs > b.speed) { b.vx = (b.vx / cs) * b.speed; b.vy = (b.vy / cs) * b.speed; }
                    b.life -= dt;
                }
                if (b.boomerang && b.life > 0) {
                    b.life -= dt;
                    if (b.life < 1.5) { const d = Math.hypot(b.origin.x - b.x, b.origin.y - b.y) || 1; b.vx += (b.origin.x - b.x) / d * 0.3; b.vy += (b.origin.y - b.y) / d * 0.3; }
                }
                if (this.rules.gravityBullets) b.vy += 2 * dt;
                b.x += b.vx * speedMult;
                b.y += b.vy * speedMult;
                if (this.rules.bouncyBullets && !b.bounced) {
                    const margin = this.arena.shrinkAmount;
                    if (b.x < margin || b.x > CONFIG.CANVAS_WIDTH - margin) { b.vx *= -1; b.bounced = true; }
                    if (b.y < margin || b.y > CONFIG.CANVAS_HEIGHT - margin) { b.vy *= -1; b.bounced = true; }
                }
            });
            this.enemyBullets = this.enemyBullets.filter(b => {
                if (b.homing && b.life <= 0) return false;
                if (b.boomerang && b.life <= 0) return false;
                const margin = this.arena.shrinkAmount - 20;
                return b.x > margin && b.x < CONFIG.CANVAS_WIDTH - margin && b.y > margin && b.y < CONFIG.CANVAS_HEIGHT - margin;
            });
        }
        
        updateHazards(dt) {
            this.hazards.forEach(h => {
                h.timer -= dt;
                if (h.type === 'playertrail') {
                    this.enemies.forEach(e=>{ if(e.dead||e.friendly) return; const d=Math.hypot(e.x-h.x,e.y-h.y); if(d < h.size + e.size){ e.hp -= 0.02 * 60 * dt; if (Math.random()<0.08) this.spawnHitEffect(e.x,e.y,'#f80'); } });
                }
                if (h.type === 'mine' && h.timer <= 0 && !h.exploded) {
                    h.exploded = true;
                    for (let i = 0; i < 8; i++) { const a = (Math.PI * 2 / 8) * i; this.enemyBullets.push({ x: h.x, y: h.y, vx: Math.cos(a) * 4, vy: Math.sin(a) * 4, size: 5, color: '#f80' }); }
                    this.screenEffects.shake = 5;
                }
            });
            this.hazards = this.hazards.filter(h => h.type === 'mine' ? h.timer > -0.5 : h.timer > 0);
        }
        
        updateXPOrbs(dt) {
            const magnetRange = this.rules.magnetic ? 150 : 50;
            this.xpOrbs.forEach(orb => {
                const dx = this.player.x - orb.x, dy = this.player.y - orb.y;
                const d = Math.sqrt(dx*dx + dy*dy);
                if (d < magnetRange) { const speed = 5 + (1 - d/magnetRange) * 10; orb.x += (dx/d) * speed; orb.y += (dy/d) * speed; }
                if (d < this.player.size + orb.size) {
                    orb.collected = true;
                    this.xp += orb.value;
                    if (this.xpBombTimer > 0) {
                        const r = 40;
                        this.enemies.forEach(e=>{ const dd=Math.hypot(e.x-orb.x,e.y-orb.y); if(dd<r){ e.hp -= 1; this.spawnHitEffect(e.x,e.y,'#0ff'); } });
                        this.visualEffects.push({type:'burst',x:orb.x,y:orb.y,radius:r,timer:0.2,color:'#0ff'});
                    }
                    this.checkLevelUp();
                }
            });
            this.xpOrbs = this.xpOrbs.filter(o => !o.collected);
            if (this.rules.xpDrain && this.xp > 0) this.xp = Math.max(0, this.xp - dt * 5);
        }
        
        updateParticles(dt) { this.particles.forEach(p => p.update(dt)); this.particles = this.particles.filter(p => p.life > 0); }
        updateVisualEffects(dt) { this.visualEffects.forEach(e => e.timer -= dt); this.visualEffects = this.visualEffects.filter(e => e.timer > 0); }
        
        checkCollisions() {
            const p = this.player;
            if (p.invincible > 0) return;
            
            this.playerBullets.forEach(b => {
                this.enemies.forEach(e => {
                    if (e.dead || b.hit) return;
                    if (e.dna.body.shield) {
                        const bulletAngle = Math.atan2(b.y - e.y, b.x - e.x);
                        const enemyFacing = Math.atan2(p.y - e.y, p.x - e.x);
                        if (Math.abs(bulletAngle - enemyFacing) < Math.PI / 2) { b.hit = true; this.spawnHitEffect(b.x, b.y, '#88f'); return; }
                    }
                    const d = Math.hypot(b.x - e.x, b.y - e.y);
                    if (d < b.size + e.size) {
                        if (b.pierce && b.pierce > 0) { b.pierce--; if (b.pierce <= 0) b.hit = true; } else { b.hit = true; }
                        const dmg = e.armor ? Math.max(1, b.damage - e.armor) : b.damage;
                        e.hp -= dmg;
                        this.spawnHitEffect(b.x, b.y, e.dna.body.color);
                        if (this.rules.echo) { for (let i = 0; i < 2; i++) { const a = Math.random() * Math.PI * 2; this.playerBullets.push({ x: b.x, y: b.y, vx: Math.cos(a) * CONFIG.BULLET_SPEED * 0.7, vy: Math.sin(a) * CONFIG.BULLET_SPEED * 0.7, size: 3, damage: 1 }); } }
                        if (e.hp <= 0) this.killEnemy(e);
                    }
                });
            });
            this.playerBullets = this.playerBullets.filter(b => !b.hit);
            
            this.enemies.forEach(friendly => {
                if (!friendly.friendly || friendly.dead) return;
                this.enemies.forEach(e => {
                    if (e.friendly || e.dead || e === friendly) return;
                    const d = Math.hypot(friendly.x - e.x, friendly.y - e.y);
                    if (d < friendly.size + e.size) { e.hp -= 1; if (e.hp <= 0) this.killEnemy(e); }
                });
            });
            
            this.enemyBullets.forEach(b => {
                const d = Math.hypot(b.x - p.x, b.y - p.y);
                if (d < CONFIG.NEAR_MISS_DISTANCE && d > p.size) { p.nearMiss = true; this.nearMissCount++; this.screenEffects.chromatic = 0.3; this.audio.playSound('nearMiss'); this.score += Math.round(10 * this.scoreMult); }
                if (d < p.size + 5 && d > p.size) { p.perfectDodge = true; this.screenEffects.flash = 0.3; this.score += Math.round(50 * this.scoreMult); }
                if (d < p.size + b.size) this.playerDeath();
            });
            
            this.enemies.forEach(e => { if (e.dead || e.friendly) return; const d = Math.hypot(e.x - p.x, e.y - p.y); if (d < e.size + p.size) this.playerDeath(); });
            this.hazards.forEach(h => { if (h.type === 'mine' && h.timer > 0) return; const d = Math.hypot(h.x - p.x, h.y - p.y); if (d < h.size + p.size) this.playerDeath(); });
        }
        
        killEnemy(e) {
            e.dead = true;
            this.kills++;
            this.player.justKilled = true;
            if (e.elite) this.player.justKilledElite = true;
            this.player.multiKill++;
            this.player.multiKillTimer = 1;
            this.player.streak = 0;
            
            // Combo system
            this.combo++;
            this.comboTimer = CONFIG.COMBO_DECAY_TIME;
            if (this.combo > this.maxCombo) this.maxCombo = this.combo;
            if (this.combo % 5 === 0) this.audio.playSound('combo');
            
            const comboMult = 1 + Math.min(this.combo * 0.1, 5);
            this.score += Math.round(e.dna.body.xp * this.scoreMult * comboMult);
            this.audio.playSound('kill');
            
            this.xpOrbs.push({ x: e.x, y: e.y, size: 6, value: Math.round(e.dna.body.xp * comboMult), color: '#0ff' });
            
            for (let i = 0; i < 15; i++) {
                const a = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 5;
                this.particles.push(new Particle(e.x, e.y, Math.cos(a) * speed, Math.sin(a) * speed, e.dna.body.color, 3 + Math.random() * 4, 0.5 + Math.random() * 0.5, Math.random() > 0.5 ? 'square' : 'circle'));
            }
            
            const modDef = ENEMY_DNA.MODIFIER[e.dna.modifier];
            if (modDef && modDef.onDeath) modDef.onDeath(e, this);
            if (e.dna.body.splits) { for (let i = 0; i < 2; i++) { const a = Math.random() * Math.PI * 2; this.spawnEnemy(e.x + Math.cos(a) * 20, e.y + Math.sin(a) * 20, 'SMALL'); } }
            if (this.rules.eliteHunters && this.player.multiKill >= 5) { this.spawnElite(); this.player.multiKill = 0; }
            
            // Update codex
            const bodyType = e.dna.body.type;
            if (!this.meta.codex.enemies[bodyType]) this.meta.codex.enemies[bodyType] = { killed: 0, killedBy: 0 };
            this.meta.codex.enemies[bodyType].killed++;
        }
        
        updateTriggers(dt) {
            Object.keys(this.upgradeCooldowns).forEach(key => { if (this.upgradeCooldowns[key] > 0) this.upgradeCooldowns[key] -= dt; });
            Object.keys(this.upgrades).forEach(upgradeKey => {
	                const { trigger, effect } = parseUpgradeKey(upgradeKey);
                const triggerDef = UPGRADE_TRIGGERS[trigger];
                const effectDef = UPGRADE_EFFECTS[effect];
                if (!triggerDef || !effectDef) return;
                if ((this.upgradeCooldowns[upgradeKey] || 0) <= 0 && triggerDef.check(this)) {
                    effectDef.apply(this, this.upgrades[upgradeKey]);
                    this.upgradeCooldowns[upgradeKey] = triggerDef.cooldown;
                }
            });
        }
        
        checkLevelUp() {
            const xpNeeded = CONFIG.XP_TO_LEVEL * Math.pow(CONFIG.XP_SCALE, this.level - 1);
            if (this.xp >= xpNeeded) {
                this.xp -= xpNeeded;
                this.level++;
                this.player.justLeveledUp = true;
                this.audio.playSound('levelUp');
                this.showUpgradeMenu();
            }
        }
        
        showUpgradeMenu() {
            this.upgradeMenuOpen = true;
            this.timeScale = 0.1;
            const menu = document.getElementById('upgradeMenu');
            const options = document.getElementById('upgradeOptions');
            options.innerHTML = '';
            
            const available = [];
            this.meta.unlocks.triggers.forEach(t => { this.meta.unlocks.effects.forEach(e => { available.push({ trigger: t, effect: e }); }); });
            for (let i = available.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [available[i], available[j]] = [available[j], available[i]]; }
            
            available.slice(0, 3).forEach(choice => {
                const div = document.createElement('div');
                div.className = 'upgrade-option';
                const triggerDef = UPGRADE_TRIGGERS[choice.trigger];
                const effectDef = UPGRADE_EFFECTS[choice.effect];
	                const key = `${choice.trigger}${UPGRADE_KEY_SEP}${choice.effect}`;
                const stacks = this.upgrades[key] || 0;
                div.innerHTML = `<div class="upgrade-icon">${triggerDef.icon} ${effectDef.icon}</div><div class="upgrade-info"><h3>${triggerDef.name} ‚Üí ${effectDef.name}</h3><p>${effectDef.desc}</p><div class="upgrade-stack">Stack: ${stacks + 1}</div></div>`;
                div.onclick = () => {
                    this.upgrades[key] = (this.upgrades[key] || 0) + 1;
                    // Small, satisfying visual feedback when picking an upgrade (does not change gameplay)
                    this.spawnUpgradePickupEffect(choice.trigger, choice.effect, this.upgrades[key]);
                    this.closeUpgradeMenu();
                    this.audio.playSound('select');
                    this.updateUpgradeListUI();
                };
                options.appendChild(div);
            });
            menu.style.display = 'flex';
        }
        
        closeUpgradeMenu() { document.getElementById('upgradeMenu').style.display = 'none'; this.upgradeMenuOpen = false; this.timeScale = 1; }
        
        updateUpgradeListUI() {
            const el = document.getElementById('upgradeList');
            const upgrades = Object.entries(this.upgrades);
            if (upgrades.length === 0) { el.innerHTML = ''; return; }
            el.innerHTML = upgrades.slice(0, 5).map(([key, stacks]) => {
	                const { trigger, effect } = parseUpgradeKey(key);
                return `<div>${UPGRADE_TRIGGERS[trigger]?.icon || '‚Ä¢'} ‚Üí ${UPGRADE_EFFECTS[effect]?.icon || '‚Ä¢'} x${stacks}</div>`;
            }).join('');
        }
        
        updateSpawning(dt) {
            this.spawnTimer += dt * 1000;
            this.spawnRate = Math.max(CONFIG.SPAWN_RATE_MIN, CONFIG.SPAWN_RATE_INITIAL - this.time * 10);
            
            if (this.rules.chaosSpawn) {
                if (this.spawnTimer >= this.spawnRate * 3) { this.spawnTimer = 0; const waveSize = 3 + Math.floor(this.time / 30); for (let i = 0; i < waveSize; i++) setTimeout(() => this.spawnRandomEnemy(), i * 100); }
            } else if (this.rules.swarm) {
                if (this.spawnTimer >= this.spawnRate * 0.5) { this.spawnTimer = 0; this.spawnEnemy(0, 0, 'SWARM'); }
            } else {
                if (this.spawnTimer >= this.spawnRate) { this.spawnTimer = 0; this.spawnRandomEnemy(); }
            }
        }
        
        spawnRandomEnemy() {
            let x, y;
            const margin = this.arena.shrinkAmount + 20;
            const side = Math.floor(Math.random() * 4);
            switch(side) {
                case 0: x = margin; y = margin + Math.random() * (CONFIG.CANVAS_HEIGHT - margin * 2); break;
                case 1: x = CONFIG.CANVAS_WIDTH - margin; y = margin + Math.random() * (CONFIG.CANVAS_HEIGHT - margin * 2); break;
                case 2: x = margin + Math.random() * (CONFIG.CANVAS_WIDTH - margin * 2); y = margin; break;
                case 3: x = margin + Math.random() * (CONFIG.CANVAS_WIDTH - margin * 2); y = CONFIG.CANVAS_HEIGHT - margin; break;
            }
            this.spawnEnemy(x, y);
        }
        
        spawnEnemy(x, y, forceBody = null) {
            const u = this.meta.unlocks;
            let bodyType = forceBody || u.bodies[Math.floor(Math.random() * u.bodies.length)];
            if (this.rules.giantEnemies && Math.random() < 0.3) bodyType = 'GIANT';
            if (this.rules.tinyEnemies && Math.random() < 0.3) bodyType = 'TINY';
            
            const movement = u.movements[Math.floor(Math.random() * u.movements.length)];
            const complexity = Math.min(3, 1 + Math.floor(this.time / 45));
            const hasAttack = complexity >= 2 || Math.random() < 0.3;
            const hasModifier = complexity >= 3 || Math.random() < 0.2;
            const attack = hasAttack ? u.attacks[Math.floor(Math.random() * u.attacks.length)] : 'NONE';
            const modifier = hasModifier ? u.modifiers[Math.floor(Math.random() * u.modifiers.length)] : 'NONE';
            const body = ENEMY_DNA.BODY[bodyType] || ENEMY_DNA.BODY.SMALL;
            
            const enemy = { x, y, vx: 0, vy: 0, size: body.size, hp: body.hp, speed: body.speed, dna: { body: { ...body, type: bodyType }, movement, attack, modifier }, dead: false, moveTimer: Math.random() * 2 };
            if (this.rules.fragileFoes) { enemy.hp = Math.max(1, Math.ceil(enemy.hp * 0.6)); enemy.speed *= 1.3; }
            const modDef = ENEMY_DNA.MODIFIER[modifier];
            if (modDef && modDef.onSpawn) modDef.onSpawn(enemy);
            this.enemies.push(enemy);
        }
        
        spawnElite() {
            const margin = this.arena.shrinkAmount + 30;
            const angle = Math.random() * Math.PI * 2;
            let x = this.player.x + Math.cos(angle) * 150;
            let y = this.player.y + Math.sin(angle) * 150;
            x = Math.max(margin, Math.min(CONFIG.CANVAS_WIDTH - margin, x));
            y = Math.max(margin, Math.min(CONFIG.CANVAS_HEIGHT - margin, y));
            const enemy = { x, y, vx: 0, vy: 0, size: 25, hp: 8, speed: 1.2, elite: true, dna: { body: { ...ENEMY_DNA.BODY.TANK, color: '#f00', xp: 100, type: 'ELITE' }, movement: 'CHARGE', attack: 'BURST', modifier: 'EXPLODE' }, dead: false, moveTimer: 0 };
            this.enemies.push(enemy);
            this.audio.playSound('select');
            this.screenEffects.shake = 10;
        }
        
        updateArena(dt) {
            if (this.rules.shrinkingArena) { this.arena.shrinkAmount += dt * 2; this.arena.shrinkAmount = Math.min(this.arena.shrinkAmount, 100); }
            if (this.rules.rotatingScreen) this.arena.rotation += dt * 0.1;
        }
        
        spawnHitEffect(x, y, color) {
            for (let i = 0; i < 8; i++) {
                const a = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 4;
                this.particles.push(new Particle(x, y, Math.cos(a) * speed, Math.sin(a) * speed, color, 2 + Math.random() * 3, 0.3 + Math.random() * 0.2, Math.random() > 0.5 ? 'square' : 'circle'));
            }
        }

        spawnUpgradePickupEffect(triggerKey, effectKey, stacks) {
            // Purely cosmetic feedback when an upgrade is chosen.
            // Uses existing particle / visualEffects systems so it doesn't alter gameplay.
            if (!this.player) return;
            const triggerDef = UPGRADE_TRIGGERS[triggerKey];
            const effectDef = UPGRADE_EFFECTS[effectKey];

            const text = `${triggerDef?.icon || '‚ú®'} ${effectDef?.icon || '‚ú®'}  ${triggerDef?.name || 'Trigger'} ‚Üí ${effectDef?.name || 'Effect'}  x${stacks}`;

            // A small burst of particles
            this.spawnHitEffect(this.player.x, this.player.y, '#ffffff');
            this.spawnHitEffect(this.player.x, this.player.y, '#0ff');
            this.spawnHitEffect(this.player.x, this.player.y, '#f0f');

            // Floating label + ring
            this.visualEffects.push({
                type: 'upgrade',
                x: this.player.x,
                y: this.player.y - this.player.size - 8,
                text,
                color: '#ffffff',
                ringColor: '#0ff',
                radius: 22,
                timer: 0.75,
                duration: 0.75
            });

            // Tiny screen feedback (respects existing settings)
            if (this.meta?.settings?.screenShake) this.screenEffects.shake = Math.max(this.screenEffects.shake, 6);
            this.screenEffects.flash = Math.max(this.screenEffects.flash, 0.25);
        }
        
        playerDeath() {
            if (this.gameOver || this.player.invincible > 0) return;
            this.gameOver = true;
            this.audio.playSound('death');
            this.audio.stopMusic();
            
            for (let i = 0; i < 40; i++) {
                const a = Math.random() * Math.PI * 2;
                const speed = 3 + Math.random() * 10;
                this.particles.push(new Particle(this.player.x, this.player.y, Math.cos(a) * speed, Math.sin(a) * speed, ['#0ff', '#f0f', '#ff0', '#f00', '#fff'][Math.floor(Math.random() * 5)], 4 + Math.random() * 8, 0.8 + Math.random() * 0.6, ['circle', 'square'][Math.floor(Math.random() * 2)]));
            }
            this.screenEffects.shake = 25;
            this.screenEffects.flash = 1;
            
            // Update stats
            this.meta.totalRuns++;
            this.meta.totalKills += this.kills;
            this.meta.totalScore += this.score;
            this.meta.totalPlaytime += this.time;
            this.meta.totalNearMisses += this.nearMissCount;
            if (this.score > this.meta.bestScore) this.meta.bestScore = this.score;
            if (this.time > this.meta.bestTime) this.meta.bestTime = this.time;
            if (this.level > this.meta.bestLevel) this.meta.bestLevel = this.level;
            if (this.maxCombo > this.meta.bestCombo) this.meta.bestCombo = this.maxCombo;
            if (this.nearMissCount > this.meta.bestNearMisses) this.meta.bestNearMisses = this.nearMissCount;
            if (this.kills > this.meta.bestKillsInRun) this.meta.bestKillsInRun = this.kills;
            if (this.time < this.meta.fastestDeath) this.meta.fastestDeath = this.time;
            
            // Calculate XP gained
            const xpGained = Math.round(this.score / 10 + this.kills * 2 + this.time * 5);
            META.addAccountXp(this.meta, xpGained);
            
            // Update missions
            this.meta.missions.forEach(m => {
                if (m.completed) return;
                if (m.type === 'kills') m.progress = Math.min(m.target, m.progress + this.kills);
                if (m.type === 'score') m.progress = Math.min(m.target, Math.max(m.progress, this.score));
                if (m.type === 'time') m.progress = Math.min(m.target, Math.max(m.progress, Math.floor(this.time)));
                if (m.type === 'level') m.progress = Math.min(m.target, Math.max(m.progress, this.level));
                if (m.type === 'combo') m.progress = Math.min(m.target, Math.max(m.progress, this.maxCombo));
                if (m.type === 'nearMiss') m.progress = Math.min(m.target, Math.max(m.progress, this.nearMissCount));
                if (m.progress >= m.target) { m.completed = true; META.addAccountXp(this.meta, m.reward); this.meta.missionsCompleted++; }
            });
            
            const newUnlocks = META.checkAllUnlocks(this.meta);
            META.save(this.meta);
            
            setTimeout(() => {
                document.getElementById('finalScore').textContent = this.score.toLocaleString();
                document.getElementById('finalTime').textContent = this.formatTime(this.time);
                document.getElementById('finalLevel').textContent = this.level;
                document.getElementById('finalCombo').textContent = this.maxCombo + 'x';
                
                document.getElementById('xpGained').style.display = 'block';
                document.getElementById('xpGainedValue').textContent = xpGained.toLocaleString();
                
                const unlockContainer = document.getElementById('newUnlocksContainer');
                const unlocksList = document.getElementById('newUnlocksList');
                if (newUnlocks.length > 0) {
                    unlockContainer.style.display = 'block';
                    unlocksList.innerHTML = newUnlocks.slice(0, 5).join(' ‚Ä¢ ');
                } else {
                    unlockContainer.style.display = 'none';
                }
                
                this.showScreen('deathScreen');
            }, 600);
        }
        
        updateUI() {
            document.getElementById('score').textContent = this.score.toLocaleString();
            document.getElementById('level').textContent = 'LV ' + this.level;
            document.getElementById('time').textContent = this.formatTime(this.time);
            document.getElementById('accountLevel').textContent = 'ACC LV ' + this.meta.accountLevel;
        }
        
        updateComboUI() {
            const el = document.getElementById('comboDisplay');
            if (this.combo > 1) {
                el.style.display = 'block';
                el.textContent = this.combo + 'x COMBO';
                el.style.transform = `scale(${1 + Math.min(this.combo * 0.02, 0.5)})`;
            } else {
                el.style.display = 'none';
            }
        }
        
        formatTime(t) { const mins = Math.floor(t / 60); const secs = Math.floor(t % 60); return `${mins}:${secs.toString().padStart(2, '0')}`; }
        
        render() {
            const ctx = this.ctx;
            ctx.save();
            
            if (this.arena.rotation) { ctx.translate(CONFIG.CANVAS_WIDTH / 2, CONFIG.CANVAS_HEIGHT / 2); ctx.rotate(this.arena.rotation); ctx.translate(-CONFIG.CANVAS_WIDTH / 2, -CONFIG.CANVAS_HEIGHT / 2); }
            if (this.screenEffects.shake > 0.5 && this.meta.settings.screenShake) ctx.translate((Math.random() - 0.5) * this.screenEffects.shake, (Math.random() - 0.5) * this.screenEffects.shake);
            
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
            
            const margin = this.arena.shrinkAmount;
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.strokeRect(margin, margin, CONFIG.CANVAS_WIDTH - margin * 2, CONFIG.CANVAS_HEIGHT - margin * 2);
            
            if (margin > 0) {
                ctx.fillStyle = 'rgba(255, 0, 64, 0.1)';
                ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, margin);
                ctx.fillRect(0, CONFIG.CANVAS_HEIGHT - margin, CONFIG.CANVAS_WIDTH, margin);
                ctx.fillRect(0, margin, margin, CONFIG.CANVAS_HEIGHT - margin * 2);
                ctx.fillRect(CONFIG.CANVAS_WIDTH - margin, margin, margin, CONFIG.CANVAS_HEIGHT - margin * 2);
            }
            
            ctx.strokeStyle = '#1a1a2e';
            ctx.lineWidth = 1;
            const gridSize = 40;
            for (let x = margin; x < CONFIG.CANVAS_WIDTH - margin; x += gridSize) { ctx.beginPath(); ctx.moveTo(x, margin); ctx.lineTo(x, CONFIG.CANVAS_HEIGHT - margin); ctx.stroke(); }
            for (let y = margin; y < CONFIG.CANVAS_HEIGHT - margin; y += gridSize) { ctx.beginPath(); ctx.moveTo(margin, y); ctx.lineTo(CONFIG.CANVAS_WIDTH - margin, y); ctx.stroke(); }
            
            // Hazards
            this.hazards.forEach(h => { ctx.fillStyle = h.color; ctx.beginPath(); ctx.arc(h.x, h.y, h.size, 0, Math.PI * 2); ctx.fill(); if (h.type === 'mine' && h.timer > 0) { const pulse = 1 + Math.sin(h.timer * 10) * 0.3; ctx.strokeStyle = '#f80'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(h.x, h.y, h.size * pulse, 0, Math.PI * 2); ctx.stroke(); } });
            
            // XP Orbs
            this.xpOrbs.forEach(orb => { ctx.shadowColor = orb.color; ctx.shadowBlur = 10; ctx.fillStyle = orb.color; ctx.beginPath(); ctx.arc(orb.x, orb.y, orb.size, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(orb.x, orb.y, orb.size * 0.4, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0; });
            
            // Enemies
            this.enemies.forEach(e => { if (e.dead) return; this.renderEnemy(ctx, e); });
            
            // Enemy bullets
            this.enemyBullets.forEach(b => { ctx.fillStyle = b.color || '#f00'; ctx.shadowColor = b.color || '#f00'; ctx.shadowBlur = 8; ctx.beginPath(); ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2); ctx.fill(); if (b.homing) { ctx.strokeStyle = '#f0f'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(b.x, b.y, b.size + 3, 0, Math.PI * 2); ctx.stroke(); } });
            ctx.shadowBlur = 0;
            
            // Player bullets
            ctx.fillStyle = this.player.skin.color;
            ctx.shadowColor = this.player.skin.color;
            ctx.shadowBlur = 6;
            this.playerBullets.forEach(b => { ctx.beginPath(); ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2); ctx.fill(); });
            ctx.shadowBlur = 0;
            
            // Player trail
            if (this.player && this.player.trail && this.meta.settings.showTrail) {
                this.player.trail.forEach((pos, i) => { const alpha = 1 - i / this.player.trail.length; ctx.fillStyle = this.player.skin.trailColor.replace('0.3', (alpha * 0.3).toString()); ctx.beginPath(); ctx.arc(pos.x, pos.y, this.player.size * (1 - i / this.player.trail.length * 0.5), 0, Math.PI * 2); ctx.fill(); });
            }
            
            // Player
            if (this.player && !this.gameOver) this.renderPlayer(ctx);
            
            // Particles
            this.particles.forEach(p => p.draw(ctx));
            
            // Visual effects
            if (this.meta.settings.visualEffects) {
                this.visualEffects.forEach(e => {
                    const dur = e.duration || 0.3;
                    const alpha = Math.min(1, Math.max(0, e.timer / dur));
                    if (e.type === 'shockwave' || e.type === 'burst' || e.type === 'shield' || e.type === 'blackhole') {
                        ctx.strokeStyle = e.color || '#0ff';
                        ctx.lineWidth = 3;
                        ctx.globalAlpha = alpha;
                        ctx.beginPath();
                        ctx.arc(e.x, e.y, e.radius * (1 - alpha * 0.5), 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    } else if (e.type === 'lightning') {
                        ctx.strokeStyle = '#0ff';
                        ctx.lineWidth = 3;
                        ctx.globalAlpha = alpha;
                        ctx.beginPath();
                        ctx.moveTo(e.x1, e.y1);
                        for (let i = 1; i <= 5; i++) { const t = i / 5; ctx.lineTo(e.x1 + (e.x2 - e.x1) * t + (Math.random() - 0.5) * 20, e.y1 + (e.y2 - e.y1) * t + (Math.random() - 0.5) * 20); }
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    } else if (e.type === 'lasergrid') {
                        // Cross lasers (cosmetic)
                        ctx.globalAlpha = alpha;
                        ctx.strokeStyle = '#ff0';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(0, e.y); ctx.lineTo(CONFIG.CANVAS_WIDTH, e.y);
                        ctx.moveTo(e.x, 0); ctx.lineTo(e.x, CONFIG.CANVAS_HEIGHT);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    } else if (e.type === 'clone') {
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = 'rgba(255,255,255,0.25)';
                        ctx.beginPath();
                        ctx.arc(e.x, e.y, 18*(1-alpha*0.5), 0, Math.PI*2);
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(0,255,255,0.35)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(e.x, e.y, 24*(1-alpha*0.5), 0, Math.PI*2);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    } else if (e.type === 'upgrade') {
                        // Floating "Upgrade acquired" text + ring
                        const rise = (1 - alpha) * 24;
                        ctx.globalAlpha = alpha;
                        ctx.font = 'bold 18px Orbitron, monospace';
                        ctx.textAlign = 'center';
                        ctx.shadowColor = '#000';
                        ctx.shadowBlur = 10;
                        ctx.fillStyle = e.color || '#ffffff';
                        ctx.fillText(e.text || 'UPGRADE!', e.x, e.y - rise);
                        ctx.shadowBlur = 0;
                        // ring
                        ctx.strokeStyle = e.ringColor || '#0ff';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(e.x, e.y, (e.radius || 22) * (1 + (1 - alpha) * 0.8), 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.textAlign = 'left';
                        ctx.globalAlpha = 1;
                    }
                });
            }
            
            // Screen flash
            if (this.screenEffects.flash > 0.1) { ctx.fillStyle = `rgba(255, 255, 255, ${this.screenEffects.flash * 0.5})`; ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT); }
            if (this.screenEffects.chromatic > 0.1 && this.meta.settings.visualEffects) { ctx.fillStyle = `rgba(255, 0, 0, ${this.screenEffects.chromatic * 0.08})`; ctx.fillRect(-3, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT); ctx.fillStyle = `rgba(0, 0, 255, ${this.screenEffects.chromatic * 0.08})`; ctx.fillRect(3, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT); }
            
            // XP bar
            const xpNeeded = CONFIG.XP_TO_LEVEL * Math.pow(CONFIG.XP_SCALE, this.level - 1);
            const xpPercent = this.xp / xpNeeded;
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(10, CONFIG.CANVAS_HEIGHT - 25, CONFIG.CANVAS_WIDTH - 20, 15);
            ctx.fillStyle = '#333';
            ctx.fillRect(12, CONFIG.CANVAS_HEIGHT - 23, CONFIG.CANVAS_WIDTH - 24, 11);
            const gradient = ctx.createLinearGradient(12, 0, CONFIG.CANVAS_WIDTH - 12, 0);
            gradient.addColorStop(0, '#0ff');
            gradient.addColorStop(1, '#f0f');
            ctx.fillStyle = gradient;
            ctx.fillRect(12, CONFIG.CANVAS_HEIGHT - 23, (CONFIG.CANVAS_WIDTH - 24) * xpPercent, 11);
            
            // Combo display on canvas
            if (this.combo > 1) {
                ctx.fillStyle = '#ff8800';
                ctx.font = 'bold 16px Orbitron, monospace';
                ctx.textAlign = 'right';
                ctx.fillText(`${this.combo}x`, CONFIG.CANVAS_WIDTH - 15, 75);
                ctx.textAlign = 'left';
            }
            
            ctx.restore();
        }
        
        renderPlayer(ctx) {
            const p = this.player;
            const skin = p.skin;
            
            ctx.shadowColor = skin.glowColor;
            ctx.shadowBlur = p.invincible > 0 ? 30 : 20;
            ctx.fillStyle = p.invincible > 0 ? '#fff' : skin.color;
            ctx.beginPath();
            
            switch(skin.shape) {
                case 'diamond': ctx.moveTo(p.x, p.y - p.size); ctx.lineTo(p.x + p.size, p.y); ctx.lineTo(p.x, p.y + p.size); ctx.lineTo(p.x - p.size, p.y); break;
                case 'circle': case 'dot': case 'oval': ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); break;
                case 'triangle': case 'wedge': const angle = Math.atan2(p.vy || 0.01, p.vx || 0.01); ctx.moveTo(p.x + Math.cos(angle) * p.size, p.y + Math.sin(angle) * p.size); ctx.lineTo(p.x + Math.cos(angle + 2.4) * p.size, p.y + Math.sin(angle + 2.4) * p.size); ctx.lineTo(p.x + Math.cos(angle - 2.4) * p.size, p.y + Math.sin(angle - 2.4) * p.size); break;
                case 'square': case 'rhombus': ctx.rect(p.x - p.size * 0.7, p.y - p.size * 0.7, p.size * 1.4, p.size * 1.4); break;
                case 'hexagon': for (let i = 0; i < 6; i++) { const a = (Math.PI / 3) * i - Math.PI / 2; const px = p.x + Math.cos(a) * p.size; const py = p.y + Math.sin(a) * p.size; if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py); } break;
                case 'star': for (let i = 0; i < 10; i++) { const a = (Math.PI / 5) * i - Math.PI / 2; const r = i % 2 === 0 ? p.size : p.size * 0.5; const px = p.x + Math.cos(a) * r; const py = p.y + Math.sin(a) * r; if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py); } break;
                case 'pentagon': for (let i = 0; i < 5; i++) { const a = (Math.PI * 2 / 5) * i - Math.PI / 2; const px = p.x + Math.cos(a) * p.size; const py = p.y + Math.sin(a) * p.size; if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py); } break;
                case 'cross': case 'plus': const s = p.size * 0.4; ctx.moveTo(p.x - s, p.y - p.size); ctx.lineTo(p.x + s, p.y - p.size); ctx.lineTo(p.x + s, p.y - s); ctx.lineTo(p.x + p.size, p.y - s); ctx.lineTo(p.x + p.size, p.y + s); ctx.lineTo(p.x + s, p.y + s); ctx.lineTo(p.x + s, p.y + p.size); ctx.lineTo(p.x - s, p.y + p.size); ctx.lineTo(p.x - s, p.y + s); ctx.lineTo(p.x - p.size, p.y + s); ctx.lineTo(p.x - p.size, p.y - s); ctx.lineTo(p.x - s, p.y - s); break;
                case 'chaos': case 'spiral': case 'nebula': case 'quantum': case 'omega': case 'infinity': case 'eternal': case 'transcendent': const time = Date.now() / 200; for (let i = 0; i < 8; i++) { const a = (Math.PI / 4) * i + time; const r = p.size * (0.7 + Math.sin(time * 2 + i) * 0.3); const px = p.x + Math.cos(a) * r; const py = p.y + Math.sin(a) * r; if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py); } break;
                default: ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            }
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * 0.25, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        renderEnemy(ctx, e) {
            if (this.rules.invisibleEnemies && !e.visible) { ctx.globalAlpha = 0.2; }
            
            ctx.fillStyle = e.friendly ? '#0ff' : e.dna.body.color;
            const bodyType = e.dna.body.type;
            ctx.beginPath();
            
            if (bodyType === 'SMALL' || bodyType === 'SWARM' || bodyType === 'TINY') {
                const angle = Math.atan2(this.player.y - e.y, this.player.x - e.x);
                ctx.moveTo(e.x + Math.cos(angle) * e.size, e.y + Math.sin(angle) * e.size);
                ctx.lineTo(e.x + Math.cos(angle + 2.4) * e.size, e.y + Math.sin(angle + 2.4) * e.size);
                ctx.lineTo(e.x + Math.cos(angle - 2.4) * e.size, e.y + Math.sin(angle - 2.4) * e.size);
                ctx.closePath();
            } else if (bodyType === 'TANK' || bodyType === 'ELITE' || bodyType === 'GIANT' || bodyType === 'ARMORED') {
                for (let i = 0; i < 6; i++) { const angle = (Math.PI / 3) * i; const px = e.x + Math.cos(angle) * e.size; const py = e.y + Math.sin(angle) * e.size; if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py); }
                ctx.closePath();
            } else if (bodyType === 'SPLITTER' || bodyType === 'MORPHING') {
                ctx.moveTo(e.x, e.y - e.size); ctx.lineTo(e.x + e.size, e.y); ctx.lineTo(e.x, e.y + e.size); ctx.lineTo(e.x - e.size, e.y); ctx.closePath();
            } else if (bodyType === 'SHIELDED') {
                for (let i = 0; i < 5; i++) { const angle = (Math.PI * 2 / 5) * i - Math.PI / 2; const px = e.x + Math.cos(angle) * e.size; const py = e.y + Math.sin(angle) * e.size; if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py); }
                ctx.closePath();
            } else {
                ctx.arc(e.x, e.y, e.size, 0, Math.PI * 2);
            }
            ctx.fill();
            
            if (e.dna.body.shield) { const shieldAngle = Math.atan2(this.player.y - e.y, this.player.x - e.x); ctx.strokeStyle = '#88f'; ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(e.x, e.y, e.size + 5, shieldAngle - 0.8, shieldAngle + 0.8); ctx.stroke(); }
            if (e.buffed) { ctx.strokeStyle = '#f0f'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(e.x, e.y, e.size + 8, 0, Math.PI * 2); ctx.stroke(); }
            if (e.elite) { ctx.shadowColor = '#f00'; ctx.shadowBlur = 20; ctx.strokeStyle = '#f00'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(e.x, e.y, e.size + 3, 0, Math.PI * 2); ctx.stroke(); ctx.shadowBlur = 0; }
            if (e.friendly) { ctx.strokeStyle = '#0ff'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]); ctx.beginPath(); ctx.arc(e.x, e.y, e.size + 5, 0, Math.PI * 2); ctx.stroke(); ctx.setLineDash([]); }
            if (e.laserWarning || e.laserActive) { const color = e.laserActive ? '#f00' : '#f008'; const width = e.laserActive ? 10 : 3; ctx.strokeStyle = color; ctx.lineWidth = width; if (e.laserActive) { ctx.shadowColor = '#f00'; ctx.shadowBlur = 15; } ctx.beginPath(); ctx.moveTo(e.x, e.y); ctx.lineTo(e.x + Math.cos(e.laserAngle) * 400, e.y + Math.sin(e.laserAngle) * 400); ctx.stroke(); ctx.shadowBlur = 0; }
            if (e.justTeleported) { ctx.fillStyle = '#fff'; ctx.globalAlpha = 0.8; ctx.beginPath(); ctx.arc(e.x, e.y, e.size * 1.5, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; e.justTeleported = false; }
            
            ctx.globalAlpha = 1;
        }
    }
    
    let game;
    window.addEventListener('load', () => { game = new Game(); window.game = game; });
})();
</script>
</body>
</html>
